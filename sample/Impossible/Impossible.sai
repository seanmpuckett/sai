// SAI "Sums and Products" a.k.a. "Impossible Puzzle" solver
//
// X and Y are two different integers, greater than 1, with sum less than 100.
// S and P are two mathematicians; S knows the sum X+Y, P knows the product X*Y, 
// and both know the information in these two sentences. 
//
// The following conversation occurs.
//
// 1) P says "I cannot find these numbers."
// 2) S says "I was sure that you could not find them. I cannot find them either."
// 3) P says "Then, I found these numbers."
// 4) S says "If you could find them, then I also found them."
//
// What are these numbers?
//
//
// This solution based in part on sample Python and Scala code in 
// http://en.wikipedia.org/wiki/Impossible_Puzzle
//


// Declare a global variable

reference:
  MAX 100


// Object declaration

object Impossible 1.0.0


// Object 'method' which runs once on object instantiation.

Instantiate task


  // Define an iterable process yielding candidate solutions.
  // It would be easy to optimize the loops, but this doing it this
  // way allows the conditions to be specified in one expression.
  //
  // What is being YIELDed for each valid candidate is a plain
  // object with named traits for x, y, s (sum) and p (product).
  
  set Candidates to process
    count 1 to ~MAX as x
      count 1 to ~MAX as y
        if 1<x and x<y and x+y<100
          yield: x x, y y, s x+y, p x*y


  // simple instrument to count the length of an array

  set Countem to task as obj, label
    debug '${label} candidate count: ${obj.length}'


  // Working storage.
  // EMPTY means an array with no elements.
  
  set pgood to empty
  set sbad to empty
  set pgood2 to empty
  set sgood to empty


  // Banner
  // Backtick specifies a string that runs to EOL.
  
  debug `Mathemetician's "Impossible" puzzle solver.


  // Print calculated result
  //
  // CHAIN is the special keyword here, allowing an indented series of operations 
  // to be applied, in this case to an array of values reaped from Candidates(). 
  // 
  // Because the algorithm uses tabular accumulation, it won't work as a lazy iterator.
  // Nevertheless, it's clearer and more maintainable to abstract away the
  // candidate generator into a process.
  
  debug chain Candidates() reap
    
    
    // Notice the indent level has changed, we're now in the "chain"
    // 
    // OBSERVE is a chain operator that receives the current object without
    // any iteration. It allows you to inspect the object without changing it. 
    // Because this is the first link in the chain, we get the value declared at
    // the start of the chain, in this case the result of 'Candidates() reap',
    // which is an array.

    observe Countem(it, 'Initial')


    // Phase 1 -- establish P's knowledge
    // count how many rows have a given product as a solution (PGood)
    // 
    // AUDIT is similar to observe, but is triggered for every item in a container
    // In this case we're counting solutions by product (.p) in the pgood array.
    //
    // the DEFAULT operator is used to ensure that uninitialized array elements
    // get a starting value of 0.

    audit 
      set pgood[.p] to (self default 0)+1
    

    // Phase 2 -- if P could have known, S knows it isn't the answer.
    // remove trivial solutions for .p (product) from the solutions for s. (sum)
    //
    // If pgood indicates a trivial solution for P, then flag S's solution as bad  
    
    audit 
      if pgood[.p]=1
        set sbad[.s] to true

    // HAS is a filtration operator: if the expression is true, the row is kept.
    // We keep all solutions that are not marked bad.
    
    has not sbad[.s] 

    observe Countem(it, 'Phase 2')


    // phase 3 -- Since S didn't know either, P can eliminate non-trivial solutions
    // Filter for a new list of solutions where there is only one answer for .p
    //
    // The remaining patterns should be familiar.

    audit 
      set pgood2[.p] to (self default 0)+1

    has pgood2[.p]=1
    
    observe Countem(it, 'Phase 3')


    // phase 4 -- Since P now knows, S can eliminate non-trivial solutions 
    // Filter for a new list of solutions where there is only one answer for .s

    audit 
      set sgood[.s] to (self default 0)+1

    has sgood[.s]=1
    
    observe Countem(it, 'Results')


    // phase 5 -- Nicely format remaining solution(s)
    //
    // THRU is a map-like operator used as a transformation tool. Used on one
    // line instead of as an indented block of code, we just supply
    // an expression to be evaluated; in this case a string literal 
    // that uses the ${} string composition tool.
     
    thru `Solution ${key+1}: X=${.x}, Y=${.y}; sum=${.s}, product=${.p}
    
    
    // JOIN is not a keyword, it's a member method of Array. CHAIN knows how to
    // apply object methods, and is smart enough to handle situations where the methd
    // doesn't return a usable "this" by passing forward the previous "this".
    //
    // Here we're turning a list into a single string with elements delimited 
    // by newlines. And as this is the last indented clause in the chain,
    // the result is the final value that is given to DEBUG to display.
    
    join '\n'

