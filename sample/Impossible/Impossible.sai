#!/usr/bin/env sai-run

// SAI "Sums and Products" a.k.a. "Impossible Puzzle" solver
//
// X and Y are two different integers, greater than 1, with sum less than 100.
// S and P are two mathematicians; S knows the sum X+Y, P knows the product X*Y, 
// and both know the information in these two sentences. 
//
// The following conversation occurs.
//
// 1) P says "I cannot find these numbers."
// 2) S says "I was sure that you could not find them. I cannot find them either."
// 3) P says "Then, I found these numbers."
// 4) S says "if you could find them, then I also found them."
//
// What are these numbers?
//
//
// This solution based in part on sample Python and Scala code in 
// http://en.wikipedia.org/wiki/Impossible_Puzzle
//

// Declare a global variable

reference:
  max 100


// Object declaration

object Impossible main 1.0.0


// Object 'method' which runs once on object instantiation.

Instantiate task


  // Define an iterable process yielding candidate solutions.
  //
  // What is being yielded for each valid candidate is a plain
  // object with named traits for x, y, s (sum) and p (product).
  //
  // SAI does not use = for assignment. Every line of code begins with
  // a verb. Here it is set, used for variable assignment.

  set Candidates to process
    count 2 to max as x                    // greater than 1 
      count x+1 to max as y                // greater than x
        if x+y<max                         // sum less than max 
          yield fields
            x x
            y y
            sum x+y
            product x*y

  // simple instrument to count the length of an array

  set Countem to task given obj, label
    debug '${label} candidate count: ${obj.length}'


  // Working storage.
  // empty means an array with no elements. (Must be lowercase.)
  //
  // The set verb can perform multiple assignments when they
  // are indented as below. This can make for clearer code.

  set
    pgood to empty
    sbad to empty
    pgood2 to empty    
    sgood to empty


  // Banner
  // Backtick specifies a string that runs to EOL.
  
  debug `Mathemetician's "Impossible" puzzle solver.


  // Print calculated result
  //
  // CHAIN is the special keyword here, allowing an indented series of operations 
  // to be applied, in this case to an array of values reaped from Candidates(). 
  // 
  // Because the algorithm uses tabular accumulation, it won't work as a lazy iterator.
  // Nevertheless, it's clearer and more maintainable to abstract away the
  // candidate generator into a process and then extract candidates into a list 
  
  debug chain from Candidates; collect
    
    
    // Notice the indent level has changed, we're now in the "chain"
    // 
    // observe is a chain operator that receives the current object without
    // any iteration. It allows you to inspect the object without changing it. 
    // Because this is the first link in the chain, we get the value declared at
    // the start of the chain, in this case the result of 'Candidates() collect',
    // which is an array.

    observe from Countem it, 'Initial'


    // Phase 1 -- establish P's knowledge
    // count how many rows have a given product as a solution (PGood)
    // 
    // audit is similar to observe, but is triggered for every item in a container
    // In this case we're counting solutions by product (.p) in the pgood array.
    //
    // the default operator is used to ensure that uninitialized array elements
    // get a starting value of 0.

    audit 
      set pgood\.product to self?0 + 1
    

    // Phase 2 -- if P could have known, S knows it isn't the answer.
    // remove trivial solutions for .product from the solutions for .sum
    //
    // if pgood indicates a trivial solution for P, then flag S's solution as bad  
    
    audit 
      if pgood\.product = 1
        set sbad\.sum to true

    // Has is a filtration operator: if the expression is true, the row is kept.
    // We keep all solutions that are not marked bad.
    
    has not sbad\.sum 

    observe from Countem it, 'Phase 2'


    // phase 3 -- Since S didn't know either, P can eliminate non-trivial solutions
    // Filter for a new list of solutions where there is only one answer for .product
    //
    // The remaining patterns should be familiar.

    audit 
      set pgood2\.product to self?0 + 1

    has pgood2\.product=1
    
    observe from Countem it, 'Phase 3'


    // phase 4 -- Since P now knows, S can eliminate non-trivial solutions 
    // Filter for a new list of solutions where there is only one answer for .sum

    audit 
      set sgood\.sum to self?0 + 1

    has sgood\.sum = 1
    
    observe from Countem it, 'Results'


    // phase 5 -- Nicely format remaining solution(s)
    //
    // THRU is a map-like operator used as a transformation tool. Used on one
    // line instead of as an indented block of code, we just supply
    // an expression to be evaluated; in this case a string literal 
    // that uses the ${} string composition tool.
     
    thru `Solution ${key+1}: X=${.x}, Y=${.y}; sum=${.sum}, product=${.product}
    
    
    // JOIN is not a keyword, it's a member method of Array. CHAIN knows how to
    // apply object methods, and is smart enough to handle situations where the methd
    // doesn't return a usable "this" by passing forward the previous "this".
    //
    // Here we're turning a list into a single string with elements delimited 
    // by newlines. And as this is the last indented clause in the chain,
    // the resulting string is the final value that is given to debug to display.
    
    join '\n'

