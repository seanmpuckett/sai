
{
  var _bindings={};
  var _locals={};
  var reCache={};
  var Entity=false;
  var FunctionChain=false;
  var SafetyFetch=false;
  var LeakedMagic=/\^\{([a-z0-9]+)\}/;
  var References={};
  var lp='_'; // prefix for bareword variables
  
  function addLocal(v,a) { 
    if (References[v]) return;
    if (_bindings[v]) return;
    _locals._hasLocals=true;
    if (!_locals[v]) {
      _locals[v]=a?(v+a):v;
    } else if (a) {
      _locals[v]=v+a;
    }
  }
  
  function removeLocal(v) {
    delete _locals[v];
  }
  
  function getLocals() { 
    if (!_locals._hasLocals) return ''; 
    var k=[]; 
    for (var i in _locals) if (i!=='_hasLocals') {
      if (i!=_locals[i]) {
        k.push(_locals[i]);
      } else {
        k.unshift(_locals[i]);
      }
    } 
    var finalk=[];
    //console.log("references");
    //console.log(References);
    for (var i in k) {
      //console.log(k[i]);
      if (!References[k[i]]) finalk.push(k[i]);
    }
    //console.log(finalk);
    var r='var '+finalk.join(',')+';\n'; 
    _locals={};
    return r; 
  }

  function rep(list,val) {
    var j;
    for (var i in list) {
      if (j==val[list[i]]) list[i]=j;
    }
  }
 
  function RV(code,varnames) {
    if (!varnames) varnames={};
    if (!code.replace) {
      code=code.toString();
    }
    var repl=function(key) {
      var val=varnames[key];
      if (undefined===val || null===val || false===val) val=tempvar();
      var re=reCache[key]; if (!re) re=reCache[i]=new RegExp('\\^\\{'+key+'\\}','g');
      //console.log(" -- replace "+key+" with "+val)
      code=code.replace(re,val);
    };
    //console.log("###############################")
    //console.log(code);
    //console.log("........................");
    //console.log(varnames);
    var completed={};
    var precedence=['block','this','key','list','counter'];
    for (var j in precedence) {
      var i=precedence[j];
      if (varnames.hasOwnProperty(i)) {
        //console.log("intercept "+i+" with "+varnames[i]);
        repl(i);
        completed[i]=true;
      }
    }
    for (var i in varnames) {
      if (undefined===completed[i]) {
        repl(i);
      }
    }
    //console.log(code)
    //console.log("---------------------------------")
    return code;
  }
  
  var varnum=0;
  function tempvar() {
    var v="$"+(varnum++);
    return v;
  }
  
  function quoted(v) {
    return "'"+v.replace(/\'/g,"\\\'")+"'";
  }
  
  var accessors = {
    firstfetch: { // [0]+key+[1]
      this: [ '$' , '' ],
      local: [ '' , '' ], 
      arguments: [ 'arguments','' ],
      parameters: [ 'p','' ],
      it: [ '^{this}','' ],
      key: [ '^{key}','' ],
      counter: [ '^{counter}','' ],
      trial: [ '^{trial}','' ],
      sum: [ '^{sum}','' ],
      error: [ '^{error}','' ],
      self: [ '^{self}','' ],
      super: [ '^{super}','' ],
      paren: [ '', '' ],
      bound: [ '' , '' ],
      global: [ '' , '' ],
      function: [ '' , '' ],
      literal: ['','']
    },
    nextfetch: { // +[0]+key+[1]
      function: [ '(' , ')' ],
      attribute: [ '.' , '' ], 
      index: [ '[' , ']' ],
    },
    firststore: { //[0]+key+[1]
      function: [ '' , '' ],
      paren: [ '', '' ],
      local: [ '' , ''  ],
      error: [ '^{error}','' ],
      attribute: [ '^{this}.' ,  '' ],
      self: [ '^{self}','' ],
      sum: [ '^{sum}' , '' ],
      property: [ '$["' , '"]' ], 
      parameter: [ 'p["','"]' ],
    },
    laststore: { // +[0]+key+[1]
      attribute: [ '.' , '' ], 
      index: [ '[' , ']'  ],
    }
  };

  function safetyFetch(root,leaf) {
    SafetyFetch=true;
    return '(undefined===($_b=('+root+'))?undefined:($_b'+leaf+'))';
  }

  function ValueCompositor(v,safe) {
    //console.log("Value Compositor...");
    //console.log(v);
    var code='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    if (v[0][0]=='local') {
      code+=VarUse(v[0][1]);
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("RV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      var leaf=pattern[0] + v[i][1] + pattern[1];
      if (i>0 && safe) {
        code=safetyFetch(code,leaf);
      } else {
        code=code+leaf;
      }
      i++;
    }
    return code;
  }

  var itselfops = {
    '+': '^{1} += ^{2}' , // test 'self +'
    '-': '^{1} -= ^{2}' , // test 'self -'
    
    '*': '^{1} *= ^{2}' , // test 'self *'
    '/': '^{1} /= ^{2}' , // test 'self /'
    '%': '^{1} %= ^{2}' , // test 'self %'
    '<<': '^{1} <<= ^{2}' , // 
    '>>': '^{1} >>= ^{2}' , // 
    '>>>': '^{1} >>>= ^{2}' , // 
    '**': '^{1} = Math.pow(^{1},^{2})' , // test 'self **'

    xorb: '^{1} ^= ^{2}' , // test 'self xorb'
    andb: '^{1} &= ^{2}' , // test 'self andb'
    orb: '^{1} |= ^{2}' , // test 'self orb'

    and: '^{1} = ^{1} && ^{2}', // test 'self and'
    or: '^{1} = ^{1} || ^{2}', // test 'self or'
    xor: '^{1} = $AI.xor(^{1},^{2})',  // test 'self xor'
    nand: '^{1} = (!((^{1})&&(^{2})))', // test 'self nand'
    nor: '^{1} = (!((^{1})||(^{2})))', // test 'self nor'

    '?>': '^{1} = Math.max(^{1},^{2})', // test 'self ?>'
    '?<': '^{1} = Math.min(^{1},^{2})', // test 'self ?<'
    
    update: '^{1} = $AI.update(^{1},^{2})', // test 'self update'
    delete: '$AI.delete(^{1},^{2})', // test 'self delete*'
    default: 'if (undefined===^{1}) ^{1}=^{2}', // test 'self default*'
    concat: '^{1} = $AI.concat(^{1},^{2}, true)', // test 'self concat inplace*'
  };

  var unops={
    '-': '^{1}=-(^{1})' , // test 'self negate'
    'not': '^{1}=!(^{1})', // test 'self not'
    'notb': '^{1}=~(^{1})', // test 'self notb'
    'inc': '^{1}++', // test 'self inc'
    'dec': '^{1}--', // test 'self dec'
    'delete': 'delete ^{1}', // test 'self delete'
    'collect': '^{1} = $AI.collect(^{1})' // test 'self collect*'
  };  

  
  function assembleLiteral(v) {
    var build='';
    var result=[];
    for (var i in v) {
      var c=v[i];
      if (c[0]) {
        build+=c[1];
      } else {
        if (build.length) result.push(quoted(build));
        build='';
        if (!result.length) result.push(quoted(''));
        result.push(c[1]);
      }
    }
    if (build.length) result.push(quoted(build));
    if (!result.length) result=[quoted('')];
    return result.join('+');
  }

  var Lists={};
  function addToList(list,e) {
    var list=Lists[list] || (Lists[list]=[]);
    list.push(e);
  }
  function getList(list) {
    var list=Lists[list] || (Lists[list]=[]);
    if (list.length) {
      return '["'+list.join('","')+'"]';
    } 
    return '[]';
  }
  function clearLists() {
    Lists={};
  }
    
  function GetExpectsTester(x,name) {
    var l =[];
    for (var i in x) {
      var t=x[i][1] || 'true';
      var p='"'+x[i][0][1]+'":'+x[i][1];
      l.push(p);
    }
    return '$AI.expectsThrow(p,{'+l.join(',')+'},'+quoted(name)+');\n';
  }
  
  
  // expects
  // as
  // kind
  // body
  // preface
  // appendix
  function TaskClauseFormatter(o) {
    var params=['p'];
    var expects='',locals=[];//$unused=this';
    if (o.expects && o.as) Error("cannot have both EXPECTS and AS in a function declaration");
    if (o.expects && o.expects.length) {
      expects=GetExpectsTester(o.expects,'in-line');
    } else if (o.as) {
      for (var i in o.as) {
        if (i==0) {
          locals.push(o.as[i][0][1]+'=p');
        } else {
          params.push(o.as[i][0][1]);
        }
      }
    }
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    var finallocals=[];
    for (var i in locals) if (!References[locals[i]]) finallocals.push(locals[i]);
    locals=locals.length?('var '+finallocals.join(',')+';'):'';
    var code = o.kind+'('+params.join(',')+'){'+o.preface+FunStart()+locals+expects+'{'+o.block+'}'+FunStop()+o.postface+'}';
    if (o.execute) code+='()';
    return code;
  }

  
  // prefix (v0)
  // name (v1)
  // as (v2)
  // expects (v3)
  // kind 
  // body (k)
  function TaskFormatter(o) {
    
    var fn=(o.prefix?o.prefix+'_':'')+o.name;
    var params='p';
    var paramspec=o.as||[];
    
    for (var i in paramspec) {
      var pname=paramspec[i][0][1];
      if (i==0) {
        addLocal(pname,'=p');
      } else {
        removeLocal(pname);
        params+=','+pname;
      }
    }

    if (SafetyFetch) { addLocal('$_b'); SafetyFetch=false; }
    if (FunctionChain) { addLocal('$_c'); addLocal('$_d'); FunctionChain=false; }
    addLocal('$','=this');
    var head='', tail='';
    var sup=GlobVar();
    if (o.prefix!='get' && o.prefix!='set') {
      addToList('lock',fn);
      head='var '+sup+'=prototype['+fn+'];\n';
      head+='prototype['+fn+']=';
      tail=';\n';
    }
  
    var fun=o.kind+'('+params+') {\n'+FunStart()+getLocals();
    if (o.expects) {
      fun+=GetExpectsTester(o.expects,fn);
    }
    fun+='{'+o.body+'}'+FunStop(); // function body
    fun+='}';
  
    if (o.name) {
      if (fun.indexOf('^{this}')>-1) error("Cannot use unrooted . accessor without a context\n\n"+fun);
    }
    var r=RV(head+fun+tail,{this:false,super:sup});
  
    return r;

  }

  function VerbCat(v) {
//       console.log("VerbCat");
//       console.log(v);
     if (v.left) {
       return v.left+v.base+v.right;
//     } else if (v.call) {
//       if (test) {
//         return RV('((undefined===($_c=^{verb}(($_d=^{base}),^{param})))?$_d:$_c)',v);
//       } else {
//         return v.verb+'('+v.base+(v.param?(','+v.param):'')+')';
//       }
     } else {
       if (v.test) {
         return RV('((undefined===($_c=(($_d=^{base})^{verb}(^{param}))))?$_d:$_c)',v);
       } else {
         return v.base+v.verb+'('+v.param+')';
       }
     }
  }
 
  function AssembleVerb(v) {
     if (v.length==1) {
//       console.log("AV 1");
//       console.log(v[0]);
       return VerbCat(v[0]);
     }
     FunctionChain=true;
     var base=v[0].base;
     for (var i in v) {
       v[i].base=base;
       v[i].test=true;
       base=VerbCat(v[i]);
     }
     return base;
  }
  
  function EnumCheck(v) {
    var start=1;
    for (var i in v) {
      if (v[i][1]==='enum') {
        v[i][1]=start++;
      } else {
        var n=parseInt(v[i][1],10);
        if (!isNaN(n)) {
          start=n+1;
        }
      }
    }
    return v;
  }
  
  function GlobVar() {
    return '$'+(options.persist.globalcount++)+'g';
  }
  function FunStart() {
    return '';
    //return ' /*:FUNSTART:*/ ';
  }
  function FunStop() {
    return '';
    //return ' /*:FUNSTOP:*/ ';
  }
  function VarUse(v) {
    return '';
    //return [].concat(v).map(function(v) { return ' /*:VAR:'+v+':*/ '});
  }
  function FixVars(code) {
  }

  function MagicCheck(code) {
    var lm=LeakedMagic.exec(code);
    if (lm) error("Magic variable '"+lm[1]+"' used in the wrong place (but I can't tell you where yet, please search for your use of this variable and make sure it is contained within a construct that uses it.)");
  }
}


startFile
  = OptionalEOLs r:Reference? o:Object+ {
    var code='';
    if (r) code+=r;
    code+=o.join('\n')
    MagicCheck(code);
    return code;
  }
  
startExpression
 = code:Expression EOLs {
   MagicCheck(code); 
   return code;
 }
  
Reference 
= REFERENCE _ v:ParameterList EOLs {
  if (v[0]!='fields') error("REFERENCE requires a trait list.");
  var code='';
  for (var i in v[2]) {
    var r=v[2][i];
    References[lp+r[0]]=true; 
    code+='var '+lp+r[0]+'='+r[1]+';\n'; 
  }
  return code;
}

Object
 = OBJECT _ k:Identifier _ main:MAIN? _ v:SemVer? _ EOLs s:Segment+ {
    if (!v) v=quoted('0.0.0-unspecified');
    var code='',isof='';
    var isa=quoted(k);
    addToList('lock','isa')
    addToList('freeze','isof')
    code+='var isa=prototype.isa='+isa+';\n';
    isof+='version:'+v+',';
    isof+='isa:isa,';
    isof+='context:__context,';
    if (main) {
      isof+='main:true,';
    }
    code+='prototype.isof['+isa+']={'+isof+'};\n';
    var l;
    if (l=getList('lock')) code+='prototype.__tobelocked=prototype.__tobelocked.concat('+l+');\n';
    if (l=getList('freeze')) code+='prototype.__tobefrozen=prototype.__tobefrozen.concat('+l+');\n';
    code+=s.join('\n');
    clearLists();
    return code;
  }

Segment
 = v:(Inherit / Contract / PropertyDef / Task / Define) { return v }
 / EOLs


Inherit
 = INHERIT _ v:SimpleList EOLs {
   var inherit='['+v.join(',')+']';
   var code='prototype.isof[prototype.isa].inherit=prototype.__inherits='+inherit+';\n';
   return code;
  }

Contract
 = CONTRACT _ v:SimpleList EOLs {
   return 'prototype.__contracts=prototype.__contracts.concat(['+v.join(',')+']);\n';
  }

PropertyDef
 = v:Identifier p1:PropertyClause p2:PropertyClause?  {
   var prop={get: undefined, set: undefined};
   prop[p1[0]]=p1[1];
   if (p2) {
     prop[p2[0]]=p2[1]; 
   }
   var ret='Object.defineProperty(prototype,"'+v+
     '",{configurable:true,enumerable:true,get:'+prop.get+
     ',set:'+prop.set+
     '});\n';
   addToList('lock',v);
   return ret;
}

PropertyClause
 = _ g:(GET/SET) _ w:MultiOutput? _ b:Block EOLs { 
   if (!g) g='get'; 
   if (g=='get') w=null; 
   return [g,TaskFormatter({prefix:g,as:w,body:b,kind:'function'})]; 
  }

Task
 = v:TaskEvent k:Block EOLs {
   v.body=k;
   return TaskFormatter(v);    
  } 

TaskEvent
 = v:Identifier _ TASK _ x:Expects? _ w:MultiOutput? _ { 
   return  {name:"'"+v+"'",expects:x,as:w,kind:'function'};
 } 
 / v:ProcessName _ PROCESS _ x:Expects? _ w:MultiOutput? _ { 
   return  {name:v,expects:x,as:w,kind:'function*'};
 } 

ProcessName
 = v:ITERATOR { return "Symbol.iterator" }
 / v:Identifier { return "'"+v+"'" }

TaskClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:'return '+b+';',kind:'function'});
}

IteratorClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}

PromiseClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({
    expects:x
    ,as:o
    ,block:b
    ,kind:'function'
    ,preface:'return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
  });
}



ExpectsParameter
 = i:Parameter _ t:Term? _ { return [i[1],t?t:true] }

Expects 
 = EXPECTS _ is:(i:ExpectsParameter COMMA _ {return i})* i:ExpectsParameter { is.push(i); return is; }
 / EXPECTS _ t:Term _ { return [[['','_root'],t]] }
 
Block
 = _ EOLs INDENT EOLs v:Lines DEDENT { return v }
 / _ '..' _ v:Line &EOLs { return v+';' }

Lines
 = v:(LineTerm)+ { return v.join('') }

LineTerm
 = v:Line EOLs { return v }

Line
 = IfStatement
 / SetStatement
 / ReturnStatement
 / IterateStatement
 / WithStatement
 / SwitchStatement
 / TryStatement
 / ThrowStatement
 / SwapStatement
 // LocalStatement
 / MiscStatement
 / VerbStatement
 


 

MiscStatement
 = BREAK _ { return 'break;\n'; }
 / CONTINUE _ { return 'continue;\n' }
 / ORPHAN _ { return 'var $=this;\n' }
 / NOP _ { return ';' }


SwitchStatement // test 'switch*'
 = s:SwitchClause o:Output? EOLs INDENT c:(EOLs c:CaseClause {return c})+ d:(EOLs d:DefaultClause {return d})? EOLs DEDENT {
   o=o?o:tempvar();
   addLocal(o);
   var repl={trial:o};
   var r=RV('switch (^{trial}=('+s+')) {\n',repl);
   for (var i in c) {
     for (var j in c[i][0]) {
       r+='case ('+c[i][0][j]+'): ';
     }
     r+=RV(c[i][1]+' break; \n',repl);
   }
   if (d) r+=RV('default: '+d+' break; \n',repl);
   r+='}\n';
   return r;
 }

SwitchClause
 = SWITCH Sep e:Expression { return e; }

CaseClause
 = CASE Sep e:Items _ b:Block { return [e,b]; }

DefaultClause
 = DEFAULT Sep b:Block { return b; }



ThrowStatement // maybe get an accurate line number in here someday?!
 = THROW _ p:Expression { // test 'throw'
 return 'throw '+p+';\n' }

TryStatement // test 'try*'
 = t:TryClause c:(EOLs c:CatchClause {return c})? f:(EOLs f:FinallyClause {return f})? {
   if (!(c||f)) error("TRY needs a CATCH and/or FINALLY");
   return t+(c?c:'')+(f?f:'');
 }

TryClause
 = TRY _ b:Block { return 'try {'+b+'}\n'; }
 
CatchClause // test 'catch*'
 = CATCH _ o:Output? _ b:Block { 
   o=o?o:tempvar();
   addLocal(o);
   return RV('catch (^{error}) {'+b+'}\n',{error:o}); 
 }
 
FinallyClause // test 'finally*'
 = FINALLY _ b:Block { return 'finally {'+b+'}\n' }
 


IfStatement
 = i:IfClause l:(EOLs l:ElseIfClause {return l})* e:(EOLs e:ElseClause {return e})? { return i+l.join('')+(e?e:'') }


IfClause
 = EXISTS _ c:Expression out:Output? b:Block  { // test 'exists*'
   if (!out) out=tempvar();
   addLocal(out);
   return RV('if (undefined !==(^{this}=(^{condition}))) {\n'+b+'\n}\n',{this:out,condition:c}); 
 }
 / IF _ c:Expression out:Output? b:Block  { // test 'if*'
   if (!out) out=tempvar();
   addLocal(out);
   return RV('if ((^{trial}=(^{condition}))) {\n'+b+'\n}\n',{trial:out,condition:c}); 
 }
 / UNLESS _ c:Expression b:Block  { // test 'unless*'
   return 'if (!('+c+')) {\n'+b+'\n}\n' }

ElseIfClause
 = ELSE _ b:IfClause { return 'else '+b+'\n' }
 
ElseClause
 = ELSE _ b:Block   { return 'else {'+b+'}\n' }
 
LocalStatement
 = LOCAL _ l:(l:Local _ ',' _ { return l } )* o:Local _ {
   l=l||[]; l.push(o);
   var j=[]; for (var i in l) j.push(l[i][0][1]);
   console.log(j);
   console.log(References);
   for (var i in j) if (References[j[i]]) error("Cannot re-define reference variable "+j[i].substr(1)+" as a local."); 
   return 'var '+j.join(',')+';\n';
 } 
 
 
WithStatement
  = WITH Sep value:Expression out:Output? block:Block {
      var r={this:(out?out:tempvar())};
      var code=RV('var ^{this}=',r)+value+RV(';\n'+block+'\n',r);
      return code; 
  }
 
SwapStatement
 = SWAP Sep a:LValue Sep b:LValue {
   return RV('var ^{t1}=^{v1}; var ^{t2}=^{v2}; ^{v2}=^{t1}; ^{v1}=^{t2};',{t1:tempvar(),t2:tempvar(),v1:a,v2:b});
 }
 

SetStatement
 = SET Sep t:SetTerms { return t }
 / SET Sep EOLs INDENT EOLs t:SetBlock DEDENT { return t.join(''); } 
 / LOCAL Sep t:LocalTerms { return t }
 / LOCAL Sep EOLs INDENT EOLs t:LocalBlock DEDENT { return t.join(''); } 
 / INC Sep v:LValue _ { return v+'++;\n'; } // test 'inc a'
 / DEC Sep v:LValue _ { return v+'--;\n'; } // test 'dec a'
 / DELETE Sep v:RValue _ { return 'delete '+v+';\n'; }

SetTerms
 = t:SetTerm _ v:(',' _ v:SetTerm _ { return v })*  { return v.concat(t) }
  
SetLine
 = v:SetTerms EOLs { return v }

SetBlock
 = v:(SetLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

SetTerm
 = l:RValues _ o:Itselfop _ e:Expression {
   for (var i in l) if (References[l[i]]) error("Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(itselfops[o], {'1':l[i], '2':RV(e,{self:l[i]}) } )+';\n';
   }
   return code;
 }
 / l:LValues _ (TO?/&FROM/&CHAIN) _ e:Expression {
   for (var i in l) if (References[l[i]]) error("Cannot assign to reference variable "+l[i].substr(1)+"."); 
   if (l.length==1) return l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+=l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   for (var i in l) if (References[l[i]]) error("Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(unops[o],{'1':l[i]})+';\n';
   }
   return code;
 }


LocalTerms
 = t:LocalTerm _ v:(',' _ v:LocalTerm _ { return v })*  { return v.concat(t) }
  
LocalLine
 = v:LocalTerms EOLs { return v }

LocalBlock
 = v:(LocalLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

LocalTerm
 = l:RValues _ o:Itselfop _ e:Expression {
   var code='';
   for (var i in l) if (References[l[i]]) error("Cannot re-define reference variable "+l[i].substr(1)+" as a local."); 
   for (var i in l) {
     code+='let '+RV(itselfops[o], {'1':l[i], '2':RV(e,{self:l[i]}) } )+';\n';
   }
   return code;
 }
 / l:LValues _ (TO?/&FROM/&CHAIN) _ e:Expression {
   for (var i in l) if (References[l[i]]) error("Cannot re-define reference variable "+l[i].substr(1)+" as a local."); 
   if (l.length==1) return 'let '+l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+='let '+l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   for (var i in l) if (References[l[i]]) error("Cannot re-define reference variable "+l[i].substr(1)+" as a local."); 
   var code='';
   for (var i in l) {
     code+='let '+RV(unops[o],{'1':l[i]})+';\n';
   }
   return code;
 }



LocalAdj
 = LOCAL Sep { return 'local '; }


UnOp // test 'self*'
 = '-' / INC / DEC  / DELETE / NOTB / NOT 

Itselfop // test 'self*'
 = '+' / '-' 
 / '**' / '*' / '/' / '%' / '<<' / '>>' / '>>>'
 / ANDB / ORB / XORB
 / AND / OR / XOR / NAND / NOR
 / '?>' / '?<'
 / UPDATE / THRU / DELETE
 / DEFAULT
 / CONCAT 



VerbStatement
 = v:VerbSentence  { return v+";\n"; }
 / v:VerbChain { return '$AI.drain('+v+');\n'; }
 
ReturnStatement
 = RETURN k:(Sep k:Expression { return k })?  { 
   return 'return '+(k?k:'')+';\n' 
  }
 / r:(ResolveReject) Sep k:Expression?   { 
   return r+'('+(k?k:'')+');\n' ;
  }
 / YIELDING Sep k:Expression { 
   return 'yield *'+'('+k+');\n' ;
  }
 / YIELD Sep k:Expression { 
   return 'yield '+'('+k+');\n' ;
  }

ResolveReject
 = RESOLVE { return '$_resolve' }
 / REJECT { return '$_reject' }

NoneClause
 = ELSE Sep b:Block  { return '{'+b+'}\n' }


IterateStatement
 = EVERY Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
   var w={block:b,t1:tempvar(),t2:tempvar(),v:v,none:n,key:(o?o[1]:false),this:(o?o[0]:false)};
   var setup='var ^{t1}=$AI.kviterate(^{v}), ^{t2}=^{t1}.next();\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'if (!^{t2}.done) ';
   var iterate='for (; !^{t2}.done; ^{t2}=^{t1}.next()) { ^{this}=^{t2}.value[1]; ^{key}=^{t2}.value[0]; ^{block}; }\n';
   return RV(setup+none+iterate,w); 
  }
 / EVERY Sep v:Expression _ USING Sep task:Value n:(EOLs n:NoneClause {return n})? {
   var w={task:task,t1:tempvar(),t2:tempvar(),v:v,none:n,key:tempvar()};
   var setup='var ^{t1}=$AI.kviterate(^{v}), ^{t2}=^{t1}.next();\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'';
   var iterate='while (!^{t2}.done) { ^{task}(^{t2}.value[1],^{t2}.value[0]); ^{t2}=^{t1}.next();}\n';
   return RV(setup+none+iterate,w); 
  }
 / ITERATE Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
   var w={block:b,t1:tempvar(),t2:tempvar(),v:v,none:n,key:(o?o[1]:false),this:(o?o[0]:false)};
   var setup='var ^{t1}=$AI.iterator(^{v}), ^{t2}=^{t1}.next();\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'if (!^{t2}.done) ';
   var iterate='for (var ^{key}=0; !^{t2}.done; ^{t2}=^{t1}.next(), ^{key}++) { ^{this}=^{t2}.value; ^{block}; }\n';
   return RV(setup+none+iterate,w); 
  }
 / ITERATE Sep v:Expression _ USING Sep task:Value n:(EOLs n:NoneClause {return n})? {
   var w={task:task,t1:tempvar(),t2:tempvar(),v:v,none:n,key:tempvar()};
   var setup='var ^{t1}=$AI.iterator(^{v}), ^{t2}=^{t1}.next(), ^{key}=0;\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'';
   var iterate='while (!^{t2}.done) { ^{task}(^{t2}.value,^{key}); ^{t2}=^{t1}.next(); ^{key}++; }\n';
   return RV(setup+none+iterate,w); 
  }
 / EACH Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
     var w={block:b,j:tempvar(),v:v,n:n,k:tempvar(),key:(o?o[1]:false),this:(o?o[0]:false),list:(o?o[2]:false)};
     var setup='var ^{list}=^{v};\nif (undefined===^{list}) ^{list}=[];';
     var iterate='for (var ^{key} in ^{list}) { var ^{this}=^{list}[^{key}];\n^{block}}\n'+(n?'if (undefined===^{key}) { ^{n} }\n':'');
     return RV(setup+iterate,w); 
  }
 / EACH Sep list:Expression _ USING Sep task:Value none:(EOLs n:NoneClause {return n})? {
     var w={task:task,list:list,j:tempvar(),k:tempvar(),none:none};
     var setup='var ^{j}=^{list};\nif (undefined===^{j}) ^{j}=[]; ';
     var iterate='for (var ^{k} in ^{j}) ^{task}(^{j}[^{k}],^{k},^{j});\n';
     var final=none?'if (^{k}===undefined) { ^{none} }\n':'';
     return RV(setup+iterate+final,w); 
  }
 / PLY Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
     var w={block:b,j:tempvar(),v:v,n:n,k:tempvar(),l:tempvar(),key:(o?o[1]:false),this:(o?o[0]:false),list:(o?o[2]:false)};
     var setup='var ^{list}=^{v};\nif (undefined===^{list}) ^{list}=[]; ';
     var iterate='var ^{l}=^{list}.length; if (^{l}) { var ^{this},^{key}=0; for (;^{key}<^{l};^{key}++) { ^{this}=^{list}[^{key}];\n^{block}\n} } '+(n?'else { ^{n} }':'')+'\n';
     return RV(setup+iterate,w); 
  }
 / PLY Sep list:Expression _ USING Sep task:Value none:(EOLs n:NoneClause {return n})? {
     var w={task:task,list:list,l:tempvar(),j:tempvar(),k:tempvar(),none:none};
     var setup='var ^{j}=^{list};\nif (undefined===^{j}) ^{j}=[]; var ^{l}=^{j}.length;\n';
     var test=none?'if (!^{l}) ^{none} else ':'';
     var iterate='for (var ^{k}=0; ^{k}<^{l}; ^{k}++) { ^{task}(^{j}[^{k}],^{k},^{j}) };\n';
     return RV(setup+test+iterate,w); 
  }
 / COUNT Sep DOWN Sep start:Expression stop:(TO Sep x:Expression {return x})? step:(StepCount)? out:IterateOutput? block:Block none:(EOLs n:NoneClause {return n})? { // test 'count to*'
     if (!stop) stop=0;
     var w={start:start,stop:stop,out:out,block:block,none:none,dest:tempvar(),counter:(out?out[0]:false),step:(step?step:'-1')};
     var setup='var ^{counter}=^{start},^{dest}=^{stop};\n ';
     var alternate=none ? 'if (^{counter}<=^{dest}) { ^{none} } else ' : '';
     var iterate='for (^{counter}+=^{step}; ^{counter}>=^{dest}; ^{counter}+=^{step}) { ^{block} }\n';
     return RV(setup+alternate+iterate,w); 
  }
 / COUNT Sep start:(x:Expression _ TO Sep { return x })? stop:Expression step:(StepCount)? out:IterateOutput? block:Block none:(EOLs n:NoneClause {return n})? { // test 'count to*'
     if (!start) start=0;
     var w={start:start,stop:stop,out:out,block:block,none:none,dest:tempvar(),counter:(out?out[0]:false),step:(step?step:'1')};
     var setup='var ^{counter}=^{start},^{dest}=^{stop};\n ';
     var alternate=none ? 'if (^{counter}>=^{dest}) { ^{none} } else ' : '';
     var iterate='for (; ^{counter}<^{dest}; ^{counter}+=^{step}) { ^{block} }\n';
     return RV(setup+alternate+iterate,w); 
  }
  / WHILE Sep v:Expression o:IterateOutput? b:Block {
    return RV('var ^{this}; while (^{this}=( ^{v})) { ^{block} }\n',{v:v,block:b,this:(o?o[0]:false)});
  }
  / UNTIL Sep v:Expression b:Block {
    return 'while (!('+v+')) { '+b+' }\n';
  }
  / DO Sep WHILE Sep v:Expression b:Block {
    return 'do { '+b+' } while ('+v+');\n';
  }
  / DO Sep UNTIL Sep v:Expression b:Block {
    return 'do { '+b+' } while (!('+v+'));\n';
  }

StepCount
 = STEP Sep v:Expression _ { return v }


LValues
 = v:LValue a:LValueSep* _ { return [v].concat(a) }
 
LValueSep
 = ',' _ v:LValue { return v }

LValue 
 = v:LStem
  {
    var j=v.length;
    if (!j) error("Expected something to assign into");
    if (j==1) {
      var pattern=accessors.firststore[v[0][0]];
      if (!pattern) error("Couldn't construct recipient from "+v);
      return pattern[0] + v[0][1] + pattern[1];
    }
    j--;
    var code='';
    var patternbase=accessors.firstfetch;
    var i=0; while (i<j) {
      var pattern=patternbase[v[i][0]]; patternbase=accessors.nextfetch;
      if (!pattern) error("Couldn't construct recipient from "+v);
      code+=pattern[0] + v[i][1] + pattern[1];
      i++;
    }
    var pattern=accessors.laststore[v[j][0]];
    if (!pattern) error("Couldn't construct recipient from "+v);
    code= code+pattern[0]+v[j][1]+pattern[1];
    return code;
  }


RValues
 = v:RValue a:RValueSep* { return [v].concat(a) }
 
RValueSep
 = ',' _ v:RValue { return v }

SimpleValue
 = v:SimpleTerm
  { return ValueCompositor(v,false) }

RValue 
 = v:RStem
  { return ValueCompositor(v,false) }

RValueSafe
 = v:RStem
  { return ValueCompositor(v,true) }

VerbValue  
 = v:RStem
  {
    var verb='',stem='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("VV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      stem+=verb;
      verb=pattern[0] + v[i][1] + pattern[1];
//      console.log("VV"+i+": stem:"+stem+" verb:"+verb);
      i++;
    }
    return [stem,verb];
  }
 


LStem
 = RStem
 ///ItStem / RootedStem / PropertyStem / ParameterStem / LocalStem 

RStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / LocalStem / GlobalStem / ParenStem 



SuperStem
 = SUPER _ { return [['super','']]; }

PropertyStem 
 = x:Property y:(Attribute/Index/Call)*  { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RootedStem
 = x:Root y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

GlobalStem
 = x:Global y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

LocalStem
 = x:Local y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

ParameterStem
 = x:Parameter y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }

ItStem
 = x:(It) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }
 
ParenStem
 = x:(Parenthetic/LiteralElm) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }


It
 = IT Sep { return [['it','']] }
 / KEY Sep { return [['key','']]}
 / COUNTER Sep { return [['counter','']]}
 / TRIAL Sep { return [['trial','']]}
 / SUM Sep { return [['sum','']]}
 / SELF Sep { return [['self','']]}
 / ERROR Sep { return [['error','']]}

Attribute
 = DOT v:IdentifierProto { return [[ 'attribute', v ]] }
 
Call
 = LPAREN _ p:ParameterList? _ RPAREN _ { 
   return [[ 'function', p?p[1]:'' ]] 
}
 
Root
 = DOT !DOT v:IdentifierProto { return [[ 'it', ''],[ 'attribute', v ]] }
 / DOT v:PositiveInteger { return [[ 'it', ''],[ 'index', v ]] }
 / DOT !DOT { return [[ 'it', '']] }

Index
 = '[' _ v:Expression _ ']' { return [[ 'index', v ]] }
 / '.' v:PositiveInteger { return [[ 'index', v ]] }

Parenthetic
 = LPAREN _ v:Expression _ RPAREN { return [[ 'paren', v ]] }

Local
 = v:Identifier { 
   if (!options.globals[v]) addLocal(lp+v); 
   return [[ 'local',lp+v ]];
}

Parameter
 = '$$' { return [['arguments','']]}
 / '$' v:IdentifierProto { return [[ 'parameters','' ],['attribute',v]] }
 / '$' { return [[ 'parameters','' ]]}

LiteralElm
 = v:Literal { return [['literal',v]]}

Global
 = '~' v:JSIdentifier { return [['global',v]] }

Property
 = '@' v:IdentifierProto { return [['this',''],[ 'attribute',v ]] }
 / '@' { return [['this','']] }

SimpleTerm
 = It/Local/Parameter/Property/Root
 / v:Number { return [['literal',v]] }
 / v:StringLiteral { return [['literal',v]] }

// DEFINITIONS

 
 


Define
  = GIVEN _ k:Identifier _ v:Definition EOLs { 
     addToList('freeze',k);
     return 'prototype["'+k+'"]='+v[1]+';\n';
   } 
  / GIVEN _ v:Definition EOLs { 
//    addToList('lock',i);
    var code='';
    code+='var t='+v[1]+';\nfor (var i in t) { prototype.__tobelocked.push(i); prototype[i]=t[i]; };\n'; 
    return code;
  }
  / INSTANCE _ v:Definition EOLs {
    var ivar=GlobVar(); 
    var proof='var '+ivar+'=function(){ return '+v[1]+'; }\nfor (var i in '+ivar+'()) { prototype[i]="uninitialized instance attribute"; };\n'; 
    //prototype.__ivars=function(){ return '+v[1]+';}\n;\nfor (var i in prototype.__ivars()) { prototype[i]="uninitialized instance attribute"; };\n'; 
    var sup=GlobVar();
    var setup= 'var '+sup+'=prototype.Constructor || function(){};\nprototype.Constructor=function() {\n'+sup+'.call(this);\n  var t='+ivar+'();\n  for (var i in t) this[i]=t[i];\n};\n'; 
    return proof+setup;
  }



SemVer
 = maj:PositiveInteger DOT min:PositiveInteger DOT patch:PositiveInteger {
   return "'"+maj+"."+min+"."+patch+"'";
 }


ParameterList
 = COLON _ EOLs INDENT EOLs v:FieldBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields', '{'+w.join(',')+'}',v] }
 / COLON _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['array',v.join(','),v] }
 / v:Items ';'? { return ['array',v.join(','),v] }
 / v:Fields ';'? { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields','{'+w.join(',')+'}',v] }
 / ';' { return null }

Definition
 = _ v:Item { return ['literal',v] }

 
NestedDefinition
 = _ EMPTY _ { return ['literal','[]']; }
 / _ BLANK _ { return ['literal','{}']; }
 / _ LIST _ v:Terms _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ LIST _ EOLs INDENT EOLs v:TermBlock DEDENT { return ['literal','['+v.join(',')+']'] }
 / _ TRAITS _ v:Traits _ SEMI? _ { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ TRAITS _ EOLs INDENT EOLs v:TraitBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/ARRAY) _ v:Items _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ (COLON/ARRAY) _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['literal','['+v.join(',')+']'] }


SimpleList
 = _ (COLON/LIST) _ v:Terms _ SEMI? _ { return v }
 / _ (COLON/LIST) _ EOLs INDENT EOLs v:TermBlock DEDENT { return v }


Term
 = EQUALS _ v:Expression { return v }
 / v:NestedDefinition { return v[1] }
 / MultiString
 / Number
 / TRUE
 / FALSE
 / UNDEFINED
 / NULL
 / StringLiteral
 / BareString
  
BareString
 = v:[^\n\},);|]+ &('|' / ',' / ')' / ';' / EOLs) { return quoted(v.join('').trim()) } 


TermSep
 = v:Term _ COMMA _  { return v }
 
Terms
 = v:(TermSep)* t:(Term) { return v.concat(t) }
  
TermLine
 = v:Terms EOLs { return v }

TermBlock
 = v:(TermLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Item
 = Expression

ItemSep
 = v:Expression _ COMMA _  { return v }
 
Items
 = v:(ItemSep)* t:(Item) { return v.concat(t) }
  
ItemLine
 = v:Items EOLs { return v }

ItemBlock
 = v:(ItemLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 

Trait
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:Term _ { return [[k,v]] }
 
TraitSep
 = v:Trait _ COMMA _ { return v }

Traits
 = v:(TraitSep)* t:(Trait) { 
   var r=[]; 
   for (var i in v) r=r.concat(v[i]); 
   r=r.concat(t);  
   return r; 
}
 
TraitLine
 = v:Traits EOLs { return v }
 
TraitBlock
 = v:(TraitLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Field
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:(Expression/ENUM) _ { return [[k,v]] }
 
FieldSep
 = v:Field _ COMMA _ { return v }

Fields
 = v:(FieldSep)* t:(Field) { var r=[]; for (var i in v) r=r.concat(v[i]); r=r.concat(t); return r; }
 
FieldLine
 = v:Fields EOLs { return v }
 
FieldBlock
 = v:(FieldLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 
 
Output
 = AS _ v:Local _ { return v[0][1] }

IterateOutput
 = o:MultiOutput {
   var v=[];
   for (var i in o) v.push(o[i][0][1]);
   return v;
 }
 
MultiOutput
 = (AS/GIVEN) _ k:(k:Local _ COMMA _ {return k})* _ v:Local { k.push(v); return k; }
 
 


Expression
 = v:ListQualify
 

ListQualify
 = v:Logical _ c:(c:Comprehension _ {return c})* {
   for (var i in c) {
     v=c[i][0]+v+c[i][1];
   }
   return v;
 } 


Comprehension
 = MapComprehension 
 / AuditComprehension
 / ReduceComprehension 
 / KeysComprehension 
 / ValuesComprehension
 / IterateComprehension
 / CollectComprehension
 / SetComprehension
 / ObserveComprehension
 / OtherComprehension
 / FilterComprehension 
 / SortComprehension 
 / ConcatComprehension


IterateComprehension
 = ITERATE { // test 'sow *'
     return ['$AI.iterate(',')'];
   }

KeysComprehension
 = KEYS { // test 'keys comp*'
     return ['$AI.keys(',')'];
   }

ValuesComprehension
 = VALUES { // test 'values comp*'
     return ['$AI.values(',')'];
   }

ConcatComprehension
 = CONCAT Sep x:Expression {
   return ['$AI.concat(' , ','+x+')' ];
 }

CollectComprehension
 = COLLECT { return ['$AI.collect(',')']; }
 / ENLIST { return ['$AI.enlist(',')']; }
 / ENTRAIT { return ['$AI.entrait(',')']; }

SortComprehension
 = BY Sep x:SortComprehension2 { return x }
SortComprehension2
 = o:IterateOutput? b:Block {
    if (!o) o=[lp+'a',lp+'b'];
    var block=RV('function('+o[0]+','+o[1]+'){'+b+'}');
    return ['$AI.sort(' , ','+block+')']; 
  }
 / USING Sep x:Value {
   return ['$AI.sort(' , ','+x+')' ];
  }

MapComprehension
 = THRU Sep x:MapComprehension2 { return x }
MapComprehension2
 = x:Expression  { // test 'thru inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'}',{this:'$_v',key:'$_k'});
     return ['$AI.map(' , ','+block+' )']; 
  }
 / LPAREN _ x:Expression _ RPAREN _ { // test 'thru inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'}',{this:'$_v',key:'$_k'});
     return ['$AI.map(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'thru block'
     var block=RV('function(^{this},^{key}){'+b+'; return ^{this};}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.map(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'thru using'
   return ['$AI.map(' , ','+x+')' ];
  }

AuditComprehension
 = AUDIT Sep x:AuditComprehension2 { return x }
AuditComprehension2
 = LPAREN _ x:Expression _ RPAREN _ { // test 'audit inline *'
     var block=RV('function(^{this},^{key}){ '+x+'; }',{this:'$_v',key:'$_k'});
     return ['$AI.audit(' , ','+block+' )']; 
  }
 / x:Expression { // test 'audit inline *'
     var block=RV('function(^{this},^{key}){ '+x+'; }',{this:'$_v',key:'$_k'});
     return ['$AI.audit(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'audit block*'
     var block=RV('function(^{this},^{key}){'+b+' }',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.audit(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'audit using*'
   return ['$AI.audit(' , ','+x+')' ];
  }

ReduceComprehension
 = INTO Sep x:ReduceComprehension2 { return x }
ReduceComprehension2
 = into:IntoClause o:IterateOutput? b:Block {
    if (!o) o=[];
    if (!o[0]) o[0]=lp+'sum'; 
    if (!o[1]) o[1]='$_v';
    if (!o[2]) o[2]='$_k';
    b+='return ^{sum};\n';
    var block=RV('function(^{sum},^{this},^{key}){'+b+'}',{sum:o[0],this:o[1],key:o[2]});
    if (into=='it') {
      return ['$AI.reduce(' , ','+block+')' ];
    } else {
      return ['$AI.reduce(' , ','+block+','+into+')' ];
    }
  }
 / into:IntoClause b:Expression {
    var block=RV('function(^{sum},^{this},^{key}){ return '+b+';}',{sum:lp+'sum',this:'$_v',key:'$_k'});
    if (into=='it') {
      return ['$AI.reduce(' , ','+block+')' ];
    } else {
      return ['$AI.reduce(' , ','+block+','+into+')' ];
    }
  }
  / into:IntoClause USING Sep x:Value  {
    if (into=='it') {
      return ['$AI.reduce(' , ','+x+')' ];
    } else {
      return ['$AI.reduce(' , ','+x+','+into+')' ];
    }
  }

FilterComprehension
 = HAS Sep x:FilterComprehension2 { return x }
FilterComprehension2
 = x:Expression { // test 'filter inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'; }',{this:'$_v',key:'$_k'});
     //console.log("filter comp exp");
     return ['$AI.filter(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block {
     var block=RV('function(^{this},^{key}){'+b+'}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.filter(' , ','+block+')']; 
  }
  / USING Sep x:Value {
    return ['$AI.filter(' , ','+x+')' ];
  }

/*
ViaComprehensionUNUSED
 = VIA Sep x:ViaComprehension2 { return x }
ViaComprehension2UNUSED
 = x:Expression { // test 'via inline*'
    return [ '$AI.alter(' , ','+x+')']; 
  }
*/  

SetComprehension
 = SET Sep x:AlterComprehension2 { return x }
AlterComprehension2
 = x:Expression { // test 'alter inline*'
     var block=RV('function(^{this}){ return '+x+'; }',{this:'$_v'});
     return [ '$AI.alter(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'alter block*'
     var block=RV('function(^{this}){'+b+'; return ^{this}; }',{this:o?o[0]:'$_v'});
     return [ '$AI.alter(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'alter using'
     return [ '$AI.alter(' , ','+x+')']; 
  }
  
ObserveComprehension
 = OBSERVE Sep x:ObserveComprehension2 { return x }
ObserveComprehension2
 = x:Expression { // test 'observe inline'
     var block=RV('function(^{this}){ '+x+'; }',{this:'$_v'});
     return [ '$AI.observe(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'observe block'
     var block=RV('function(^{this}){'+b+'; }',{this:o?o[0]:'$_v'});
     return [ '$AI.observe(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'observe using'
     return [ '$AI.observe(' , ','+x+')']; 
  }



OtherComprehension
 = _ q:(Quality / Criteria / Sequence / Limit)+ _ 
 {
   var code='({<>})';
   q=[].concat(q);
   var expr={quality:[],having:[],by:[],map:[],limit:[]};
   for (var i in q) { 
     for (var j=0; j<q[i].length; j+=2) {
       expr[q[i][j]].push(q[i][j+1]); 
     }
   }
   var conds=[];
   if (expr.quality.length) {
     for (var i in expr.quality) { 
       conds.push(expr.quality[i]); 
      }
   }
   if (expr.having.length) {
     var conds=conds.concat(expr.having.map(function(c){ return '('+c+')';}));
   }
   if (conds.length) {
     code=RV('$AI.filter(^{source},function($_v,$_k){ return ^{block}; })',{source:code,block:conds.join(' && '),this:'$_v',key:'$_k'});
   }
   if (expr.limit.length && expr.limit[0].extract && expr.by.length) { // first/last singleton with a sort
     code='$AI.reduce('+code+',function(a,b) { if (undefined===a) return b; var r; ';
     expr.by[0][1]*=expr.limit[0].sort; // flip sort if looking for "last"
     var conds=expr.by.map(function(c){
       c[0]=c[0]||'^{this}';
       var x1=RV(c[0],{this:'a'});
       var x2=RV(c[0],{this:'b'});
       return RV('r=$AI.compare(^{x1},^{x2}); if (r<0) return ^{lt}; if (r>0) return ^{gt};\n',{x1:x1,x2:x2,lt:(c[1]>0?'a':'b'),gt:(c[1]>0?'b':'a')});
     });
     code+=conds.join(' ')+'return a; },undefined)';     
   } else {
     if (expr.by.length) {
       code='$AI.sort('+code+',function(a,b) { var aa,bb; ';
       var conds=expr.by.map(function(c){
         c[0]=c[0]||'^{this}';
         var x1=RV('aa='+c[0]+'; ',{this:'a'});
         var x2=RV('bb='+c[0]+'; ',{this:'b'});
         return x1+x2+RV('if (aa<bb) return ^{lt}; if (aa>bb) return ^{gt}; ',{c:c[0],lt:-c[1],gt:c[1]});
       });
       code+=conds.join(' ')+'return 0; })';
     }
     if (expr.limit.length) {
       var l=expr.limit[0];
       if (l.slice) {
         code='$AI.slice('+code+','+l.start+','+l.len+')';
       }
       if (l.extract) { 
         code='$AI.element('+code+',0)';
       }
       if (l.count) {
         code='$AI.count('+code+')';
       }
     }
   } 
   return code.split('{<>}');
 }


 
Limit 
 = FIRST _ { return ['limit',{extract:true,sort:1}]; } 
 / LAST _ { return ['limit',{extract:true,slice:true,start:-1}]; } 
 / LIMIT _ s:Logical _ COMMA _ c:Logical _ { return ['limit',{slice:true,start:s,len:c}]; } 
 / LIMIT _ s:Logical _ { return ['limit',{slice:true,start:undefined,len:s}]; } 
 / COUNT _ { return ['limit',{count:true}]; }
 
Quality
 = HASH v:Keyword _ { return ['quality', '^{this}["'+v+'"]'] }
 / BANG HASH v:Keyword _ { return ['quality', '(!^{this}["'+v+'"])'] }

Criteria
 = HAS _ v:Logical _ { return ['having',v] }

Sequence
 = BY _ d:SortDirection _ { return ['by',[null,d?d:1]] }
 / BY _ v:Logical d:SortDirection? _ { return ['by',[v,d?d:1]] }
 / HIGHEST _ v:Logical _ { return ['by',[v,-1],'limit',{extract:true,sort:1}]}
 / LOWEST _ v:Logical _ { return ['by',[v,1],'limit',{extract:true,sort:1}]}

SortDirection
 = (ASCENDING/ASC) _ { return 1 }
 / (DESCENDING/DESC) _ { return -1 }



Logical
 = l:Comparison _ o:LogicalOp _ r:Logical { return '('+l+o+r+')' }
// / l:Comparison _ VIA _ f:VerbValue { return '('+f[0]+f[1]+')('+l+')' } // test 'via'
 / c:Comparison _ XOR _ l:Logical  { return '($AI.xor('+c+','+l+'))' } // test 'xor' 
 / l:Comparison _ NAND _ f:Logical { return '(!('+l+' && '+f+'))' } // test 'nand'
 / l:Comparison _ NOR _ f:Logical { return '(!('+l+' || '+f+'))' } // test 'nor'
 / c:Comparison _ '??' _ l:Logical _ '::' _ r:Logical { 
     return RV('((^{c})?(^{l}):(^{r}))',{c:c,l:l,r:r}); 
   } 
 / c:Comparison _ DEFAULT _ v:Logical  {  // test 'default*'
     SafetyFetch=true; 
     return RV('((undefined!==($_b=^{c}))?$_b:^{v})',{c:c,v:v}); 
   } 
 / v:Comparison _ { return v }

LogicalOp
 = AND Sep { return '&&' } // test 'and'
 / OR Sep { return '||' } // test 'or'
 
Comparison
 = l:Addition _ o:MathOp _ r:Comparison { return o+'('+l+','+r+')' }
 / l:Addition _ o:ComparisonOp _ r:Comparison { return '('+l+o+r+')' }
 / v:Addition _ { return v }
 
ComparisonOp
  = '>=' { return '>=' } // test '>='
  / '>' !'>' { return '>' } // test '>'
  / '=' { return '==' } // test '='
  / ISNT Sep { return '!==' } // test 'isnt'
  / IS Sep { return '===' } // test 'is *'
  / '<=' { return '<=' } // test '<='
  / '<' !'<' { return '<' } // test '<'
  / '!=' { return '!=' } // test '!='


MathOp
 = '?>' { return '$AI.max' } // test '?>'
 / '?<' { return '$AI.min' } // test '?<'
 / '<=>' { return '$AI.compare' } // test '<=>'

   
   
Addition
 = l:Multiplication _ o:AdditionOp _ r:Addition { return '('+l+o+r+')' }
 / v:Multiplication _ { return v }

AdditionOp
 = '+' // test '+'
 / '-' // test '-'
 / ORB Sep {return '|' } // test 'binary or'
 / ANDB Sep {return '&'} // test 'binary and'
 / XORB Sep { return '^'}  // test 'binary xor'

Multiplication 
 = l:Value _ o:MultiplicationOp _ r:Multiplication { return '('+l+o+r+')' }
 / l:Value _ '**' _ r:Multiplication { // test '**'
   return 'Math.pow('+l+','+r+')' 
 } 
 / l:Value _ OVERLAY Sep r:Multiplication { // test 'overlay *'
   return '$AI.overlay('+l+','+r+')' 
 }
 / l:Value _ SELECT Sep r:Multiplication { // test 'select *'
   return '$AI.select('+l+','+r+')' 
 }
 / l:Value _ DELETE Sep r:Multiplication { // test 'delete *'
   return '$AI.delete($AI.clone('+l+'),'+r+')' 
 }
 / l:Value _ EXPECTS Sep r:Multiplication { 
   return '$AI.expects('+l+','+r+')' 
 }
 / l:Value _ ISOF Sep r:Multiplication { 
   return '('+l+').isof['+r+']'; 
 }
 / v:Value _ { return v }

MultiplicationOp
 = '*' // test '*'
 / '/' // test '/'
 / '%' // test '%'
 / '>>>' // test 'rshz'
 / '>>' // test 'rsh'
 / '<<' // test 'lsh'

 
Value
 = '-' _ v:Value _ { return '(0-('+v+'))' } // test 'unary -'
 / NOTB Sep v:Value _ { return '(~('+v+'))' } // test 'unary binary not' 
 / NOT Sep v:Value _ { return '(!('+v+'))' } // test 'unary not'
 / TYPEOF Sep v:Value _ { return 'typeof ('+v+')'; }
 / ISNAN Sep v:Value _ { return 'isNaN('+v+')'; }
 / NUMBER Sep v:Value { return '($AI.number('+v+'))'; } // test 'number *'
 / EXISTS Sep v:Value _ { return '(undefined!=='+v+')' } // test 'exists'
 / COPY Sep v:Value _ { return '$AI.clone('+v+')'; } // test 'copy'
 / TASK Sep v:TaskClause _ { return v }
 / PROCESS Sep v:IteratorClause _ { return v }
 / PROMISE Sep v:PromiseClause _ { return v }
 / FROM Sep v:VerbSentence _ { return v }
 / YIELDING Sep v:Value _ { return 'yield *'+v; }
 / YIELD Sep v:Value _ { return 'yield'+v; }
 / '?' v:RValueSafe _ { return v }
 / v:RValue _ { return v }
 / VerbChain 
 / v:NestedDefinition { return v[1] }
 / o:NewObject _ { return o }
 / '(' _ v:Expression _ o:Output? ')' _ { 
   if (o) {
     addLocal(o);
     return RV('(^{out}='+v+')',{out:o}); 
   } else {
     return '('+v+')'; 
   }
  }
 / x:Regex _ { return x }

Regex
 = '/' x:(RegexEscape/RegexChar)+ '/' m:[igm]* _ {
   var re= '/'+x.join('')+'/'+m.join('');
   return re;
 }

RegexEscape 
 = '\\/' 
 
RegexChar
 = [^\n\r/]

Keyword
 = v:Identifier ![.(\[|] { return v } 
 / StringLiteral 
 // n:Number { return quoted(n.toString()); }
 
Identifier
 = !ReservedWord v:IdentifierProto { return v; }  

JSIdentifier
 = v1:[a-zA-Z_] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

IdentifierProto
 = v1:[a-zA-Z] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

Literal
 = Number 
 / StringLiteral
 / TRUE 
 / FALSE
 / UNDEFINED 
 / NULL
 / NaN { return 'NaN' }
 / INFINITY { return 'Infinity' }
 
IntoClause
 = IT Sep { return 'it' }
 / r:Expression 


////////////////////////////////////////////////////////// VERBS


VerbSentence
 = v:VerbClause {
   return AssembleVerb(v);
 }

VerbClause
= v:(VerbValue) _ o:ParameterList?  { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$'+(o?(','+o[1]):'') }]; 
     return [{ base:v[0], verb:v[1], param:(o?o[1]:'') }]
  }
 / v:(VerbValue) _ { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$' }]; 
     return [{ base:v[0], verb:v[1], param:'' }]
   }


VerbChain
 = CHAIN _ v:Expression _ c:VerbChainBlock {
   c[0].base=v;
   return AssembleVerb(c);
 }

VerbChainBlock
 = EOLs INDENT EOLs l:(VerbChainLine)+ DEDENT { 
     return l ;
   }
 
VerbChainLine
 = c:Comprehension _ EOLs {
     return {left:c[0], right: c[1]}
  }
 / i:Identifier _ o:ParameterList? _ EOLs {
     return {verb:'.'+i, param:(o?o[1]:''), test:true}; 
  }

NewObject
 = CREATE _ v:Value _ o:ParameterList?  { 
   return '$AI.create('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / NEW _ v:Value _ o:ParameterList? {
   return 'new '+v+'('+(o?o[1]:'')+')'; 
 }

VerbTerminal
 = &EOLs / &CBRACE / &')' 

ClassName
 = n:[a-zA-Z0-9_/]+ { return n.join('') }


/////////////////////////////////////////////

Number
 = v:NumericLiteral 'o' { return v*(Math.PI/180) } 
 / NumericLiteral

NumericLiteral
 = Scientific
 / Real
 / Integer
 / NaN

Scientific
 = r:(Real/Integer) 'e' x:Integer { return r+'e'+x }
 
Real
 = w:Integer DOT f:Fraction { return Number(w+'.'+f) }

Integer 
 = PositiveInteger
 / '-' v:PositiveInteger { return -v }

PositiveInteger
 = v:[0-9]+ { return parseInt(v.join('')) } 

Fraction
 = v:[0-9]+ { return v.join('') } 

SimpleStringLiteral
 = '\'' v:(EscapedChar/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringLiteral
 = MultiString
 / '\`' v:Bareline { return v }
 / '\'' v:(EscapedChar/StringTemplate/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringTemplate/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringTickChar
 = v:[^\'\n] { return [true,v] }

StringQuoteChar
 = v:[^\"\n] { return [true,v] }

MultiString
 = "'''" _ EOLs INDENT EOLs v:(v:Bareline EOL { return v} )* DEDENT &EOLs { return v.join("+'\\n'+") } 


Bareline
 = v:(EscapedChar/StringTemplate/BarelineStringChar)* &EOLs { return assembleLiteral(v) }

BarelineStringChar
 = v:[^\n}] { return [true,v] }  
  
EscapedChar
 = '\\' "'" { return [true,'\\'+"'"] }
 / '\\' '"' { return [true,'\\'+'"'] }
 / '\\' '$' { return [true,'\\'+'$'] }
 / '\\&#123;' { return [true,'\\'+'&#123;'] }
 / '\\&#125;' { return [true,'\\'+'&#125;'] }
 / '\\' 'n' { return [true,'\\'+'n'] }
 / '\\' 'r' { return [true,'\\'+'r'] }
 / '\\' 't' { return [true,'\\'+'t'] }
 / '\\' 'b' { return [true,'\\'+'b'] }
 / '\\' 'f' { return [true,'\\'+'f'] }
 / '\\' 'x' a:[0-9a-fA-F] b:[0-9a-fA-F] { return [true,'\\'+'x'+a+b ] }
 / '\\' 'u' a:[0-9a-fA-F] b:[0-9a-fA-F] c:[0-9a-fA-F] d:[0-9a-fA-F] { return [true,'\\'+'u'+a+b+c+d] }
 / '\\' 'u' '{' a:[0-9a-fA-F]+ '}' { return [true,'\\'+'u{'+a.join('')+'}' ] }

StringTemplate
 = '${' v:Expression '}' { return [false,v] }


__
 = Whitespace+

Sep
 = Whitespace
 / &[^a-zA-Z0-9_]
 
_
 = Whitespace*

Whitespace
 = EOL '...'
 / [\ ]
 
 
 
OptionalEOLs
 = EOL*
 
EOLs
 = EOL+

EOL
 = '//' [^\r\n]* CR
 / CR
 

CR
 = [\n\r]

OBRACE
 = '{'
 
CBRACE
 = '}'


ReservedWord
 = ReservedWords ![a-zA-Z_0-9] 

ReservedWords
 = SET
 / ANDB 
 / AND
 / ARRAY
 / AS 
 / ASCENDING / ASC
 / AUDIT
 / BLANK
 / BREAK
 / BY
 / CASE
 / CHAIN
 / CREATE
 / COLLECT
 / CONCAT
 / COPY
 / DEC
 / DEFAULT
 / DELETE
 / DESCENDING / DESC
 / DOWN
 / EMPTY
 / ENLIST
 / ENTRAIT
 / ENUM
 / ERROR
 / EXISTS
 / EXPECTS
 / FALSE
 / FIELDS
 / FIRST 
 / FROM
 / GET
 / HAS 
 / HIGHEST 
 / INC
 / INTO
 / ISNT
 / ISNAN
 / IS
 / ITERATE
// / ITERATOR
 / KEYS
 / LAST
 / LIMIT
 / LIST
// / LOCAL
 / LOWEST 
 / NaN
 / NAND
 / NEW
 / NOR
 / NOTB
 / NOT
 / NUMBER
 / NULL
 / OBSERVE
 / ORB
// / ORPHAN
 / OR
 / OVERLAY
 / PROMISE
 / PROCESS
// / SELECT
 / SELF
 / SWAP
 / TASK
 / TRIAL
 / THROW
 / THRU
 / TO
 / TRAITS
 / TRUE
 / TYPEOF
 / UNDEFINED
 / UPDATE
 / USING
 / VALUES
 / XORB
 / XOR
// / YIELDING
// / YIELD
 
__SOURCE = '__source'
__OFFSET = '__offset'
__COLUMN = '__column'
__LINE = '__line'

AND = 'and'
ANDB = 'andb'
ARRAY = 'array'
AS = 'as'
ASC = 'asc'
ASCENDING = 'ascending'
AUDIT = 'audit'
BLANK = 'blank'
BREAK = 'break'
BY = 'by'
CASE = 'case'
CATCH = 'catch'
CHAIN = 'chain'
COLLECT = 'collect'
COPY = 'copy'
CONCAT = 'concat'
CONTINUE = 'continue'
CONTRACT = 'contract'
COUNT = 'count'
COUNTER = 'counter'
CREATE = 'create'
DEC = 'dec'
DEFAULT = 'default'
DELETE = 'delete'
DESC = 'desc'
DESCENDING = 'descending'
DO = 'do'
DOWN = 'down'
EACH = 'each'
ELSE = 'else'
EMPTY = 'empty'
ENUM = 'enum'
ENLIST = 'enlist'
ENTRAIT = 'entrait'
ERROR = 'error'
EVERY = 'every'
EXISTS = 'exists'
EXPECTS = 'expects'
FINALLY = 'finally'
FIELDS = 'fields'
FIRST = 'first'
FROM = 'from'
GET = 'get'
GIVEN = 'given'
HAS = 'has'
HIGHEST = 'highest'
IF = 'if'
INFINITY = 'Infinity'
INSTANCE = 'instance'
INTO = 'into'
INC = 'inc'
INHERIT = 'inherit'
ISNT = 'isnt'
ISNAN = 'isNaN'
IS = 'is'
ISOF = 'isof'
ITERATE = 'iterate'
ITERATOR = 'Iterator'
IT = 'it'
KEYS = 'keys'
KEY = 'key'
LAST = 'last'
LIMIT = 'limit'
LIST = 'list'
LOCAL = 'local'
LOWEST = 'lowest'
MAIN = 'main'
NaN = 'NaN'
NAND = 'nand'
NEW = 'new'
NOP = 'nop'
NOR = 'nor'
NOT = 'not'
NOTB = 'notb'
NUMBER = 'number'
NULL = 'null'
OBJECT = 'object'
OBSERVE = 'observe'
ORPHAN = 'orphan'
OR = 'or'
ORB = 'orb'
OVERLAY = 'overlay'
TRUE = 'true'
FALSE = 'false'
PLY = 'ply'
PROMISE = 'promise'
PROCESS = 'process'
RESOLVE = 'resolve'
REJECT = 'reject'
REFERENCE = 'reference'
RETURN = 'return'
SELECT = 'select'
SELF = 'self'
SET = 'set'
STEP = 'step'
SUM = 'sum'
SWAP = 'swap'
SUPER = 'super'
SWITCH = 'switch'
TASK = 'task'
THROW = 'throw'
THRU = 'thru'
TRAITS = 'traits'
TRIAL = 'trial'
TRY = 'try'
TO = 'to'
TYPEOF = 'typeof'
UNLESS = 'unless'
UNTIL = 'until'
UNDEFINED = 'undefined'
UPDATE = 'update'
USING = 'using'
VALUES = 'values'
WHILE = 'while'
WITH = 'with'
XOR  = 'xor'
XORB  = 'xorb'
YIELDING = 'yielding'
YIELD = 'yield'

BANG = '!'
DOT = '.'
HASH = '#'
SEMI = ';'
COMMA = ','
COLON  = ':' !':' { return ':' }
INDENT = '{'
DEDENT = '}'
EQUALS = '='
LPAREN = '('
RPAREN = ')'

 