
{
  var _bindings={};
  var _locals={};
  var reCache={};
  var Entity=false;
  var FunctionChain=false;
  var SafetyFetch=false;
  
  function addLocal(v,a) { 
    if (_bindings[v]) return;
    _locals._hasLocals=true;
    if (!_locals[v]) {
      _locals[v]=a?(v+a):v;
    } else if (a) {
      _locals[v]=v+a;
    }
  }
  
  function removeLocal(v) {
    delete _locals[v];
  }
  
  function getLocals() { 
    if (!_locals._hasLocals) return ''; 
    var k=[]; 
    for (var i in _locals) if (i!=='_hasLocals') {
      if (i!=_locals[i]) {
        k.push(_locals[i]);
      } else {
        k.unshift(_locals[i]);
      }
    } 
    var r='var '+k.join(',')+';\n'; 
    _locals={};
    return r; 
  }

  function rep(list,val) {
    var j;
    for (var i in list) {
      if (j==val[list[i]]) list[i]=j;
    }
  }
 
  function RV(code,varnames) {
    if (!code.replace) {
      code=code.toString();
    }
    for (var i in varnames) {
      var val=varnames[i];
      if (undefined===val || null===val || false===val) val=tempvar();
      var re=reCache[i]; if (!re) re=reCache[i]=new RegExp('\\^\\{'+i+'\\}','g');
      code=code.replace(re,val);
    }
    return code;
  }
  
  var varnum=0;
  function tempvar() {
    var v="$"+(varnum++);
    return v;
  }
  
  function quoted(v) {
    return "'"+v.replace(/\'/g,"\\\'")+"'";
  }
  
  var accessors = {
    firstfetch: { // [0]+key+[1]
      this: [ '$' , '' ],
      local: [ '' , '' ], 
      parameters: [ 'p','' ],
      it: [ '^{this}','' ],
      key: [ '^{key}','' ],
      trial: [ '^{trial}','' ],
      accum: [ '^{accum}','' ],
      error: [ '^{error}','' ],
      self: [ '^{self}','' ],
      super: [ '^{super}','' ],
      paren: [ '', '' ],
      bound: [ '' , '' ],
      global: [ '' , '' ],
      function: [ '' , '' ],
      literal: ['','']
    },
    nextfetch: { // +[0]+key+[1]
      function: [ '(' , ')' ],
      attribute: [ '.' , '' ], 
      index: [ '[' , ']' ],
    },
    firststore: { //[0]+key+[1]
      function: [ '' , '' ],
      paren: [ '', '' ],
      local: [ '' , ''  ],
      error: [ '^{error}','' ],
      attribute: [ '^{this}.' ,  '' ],
      self: [ '^{self}','' ],
      accum: [ '^{accum}' , '' ],
      property: [ '$["' , '"]' ], 
      parameter: [ 'p["','"]' ],
    },
    laststore: { // +[0]+key+[1]
      attribute: [ '.' , '' ], 
      index: [ '[' , ']'  ],
    }
  };

  function safetyFetch(root,leaf) {
    SafetyFetch=true;
    return '(undefined===($_b=('+root+'))?undefined:($_b'+leaf+'))';
  }

  function ValueCompositor(v,safe) {
    //console.log("Value Compositor...");
    //console.log(v);
    var code='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(1,v[0][1].length-1);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    if (v[0][0]=='local') {
      code+=VarUse(v[0][1]);
    }
    var patternbase=accessors.firstfetch;
    i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("RV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      var leaf=pattern[0] + v[i][1] + pattern[1];
      if (i>0 && safe) {
        code=safetyFetch(code,leaf);
      } else {
        code=code+leaf;
      }
      i++;
    }
    return code;
  }

  var itselfops = {
    '+': '^{1} += ^{2}' , // test 'self +'
    '-': '^{1} -= ^{2}' , // test 'self -'
    
    '*': '^{1} *= ^{2}' , // test 'self *'
    '/': '^{1} /= ^{2}' , // test 'self /'
    '%': '^{1} %= ^{2}' , // test 'self %'
    '<<': '^{1} <<= ^{2}' , // 
    '>>': '^{1} >>= ^{2}' , // 
    '>>>': '^{1} >>>= ^{2}' , // 
    '**': '^{1} = Math.pow(^{1},^{2})' , // test 'self **'

    xorb: '^{1} ^= ^{2}' , // test 'self xorb'
    andb: '^{1} &= ^{2}' , // test 'self andb'
    orb: '^{1} |= ^{2}' , // test 'self orb'

    and: '^{1} = ^{1} && ^{2}', // test 'self and'
    or: '^{1} = ^{1} || ^{2}', // test 'self or'
    xor: '^{1} = _$AI.xor(^{1},^{2})',  // test 'self xor'
    nand: '^{1} = (!((^{1})&&(^{2})))', // test 'self nand'
    nor: '^{1} = (!((^{1})||(^{2})))', // test 'self nor'

    '?>': '^{1} = Math.max(^{1},^{2})', // test 'self ?>'
    '?<': '^{1} = Math.min(^{1},^{2})', // test 'self ?<'
    
    via: '^{1} = ^{2}(^{1})', // test 'self via'
    update: '_$AI.update(^{1},^{2})', // test 'self update'
    delete: '_$AI.delete(^{1},^{2})', // test 'self delete*'
    default: 'if (undefined===^{1}) ^{1}=^{2}' // test 'self default*'
  };

  var unops={
    '-': '^{1}=-(^{1})' , // test 'self negate'
    'not': '^{1}=!(^{1})', // test 'self not'
    'notb': '^{1}=~(^{1})', // test 'self notb'
    'inc': '^{1}++', // test 'self inc'
    'dec': '^{1}--', // test 'self dec'
    'delete': 'delete ^{1}' // test 'self delete'
  }; 

  
  function assembleLiteral(v) {
    var build='';
    var result=[];
    for (var i in v) {
      var c=v[i];
      if (c[0]) {
        build+=c[1];
      } else {
        if (build.length) result.push(quoted(build));
        build='';
        result.push(c[1]);
      }
    }
    if (build.length) result.push(quoted(build));
    if (!result.length) result=[quoted('')];
    return result.join('+');
  }

  var Lists={};
  function addToList(list,e) {
    var list=Lists[list] || (Lists[list]=[]);
    list.push(e);
  }
  function getList(list) {
    var list=Lists[list] || (Lists[list]=[]);
    if (list.length) {
      return '["'+list.join('","')+'"]';
    } 
    return '[]';
  }
  function clearLists() {
    Lists={};
  }
    
  function GetExpectsTester(x,name) {
    var l =[];
    for (var i in x) {
      var t=x[i][1] || 'true';
      var p='"'+x[i][0][1]+'":'+x[i][1];
      l.push(p);
    }
    return '_$AI.expectsThrow(p,{'+l.join(',')+'},'+quoted(name)+');\n';
  }
  
  
  // expects
  // as
  // kind
  // body
  // preface
  // appendix
  function TaskClauseFormatter(o) {
    var params=['p'];
    var expects='',locals=[];//$unused=this';
    if (o.expects && o.as) Error("cannot have both EXPECTS and AS in a function declaration");
    if (o.expects && o.expects.length) {
      expects=GetExpectsTester(o.expects,'in-line');
    } else if (o.as) {
      for (var i in o.as) {
        if (i==0) {
          locals.push(o.as[i][0][1]+'=p');
        } else {
          params.push(o.as[i][0][1]);
        }
      }
    }
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    locals=locals.length?('var '+locals.join(',')+';'):'';
    return o.kind+'('+params.join(',')+'){'+o.preface+FunStart()+locals+expects+o.block+FunStop()+o.postface+'}';
  }

  
  // prefix (v0)
  // name (v1)
  // as (v2)
  // expects (v3)
  // kind 
  // body (k)
  function TaskFormatter(o) {
    
    var fn=(o.prefix?o.prefix+'_':'')+o.name;
    var params='p';
    var paramspec=o.as||[];
    
    for (var i in paramspec) {
      var pname=paramspec[i][0][1];
      if (i==0) {
        addLocal(pname,'=p');
      } else {
        removeLocal(pname);
        params+=','+pname;
      }
    }

    if (SafetyFetch) { addLocal('$_b'); SafetyFetch=false; }
    if (FunctionChain) { addLocal('$_c'); addLocal('$_d'); FunctionChain=false; }
    addLocal('$','=this');
    var head='', tail='';
    if (o.prefix!='get' && o.prefix!='set') {
      addToList('lock',fn);
      head='var _'+fn+'=prototype["'+fn+'"];\n';
      head+='prototype.'+fn+'=';
      tail=';\n';
    }
  
    var fun=o.kind+'('+params+') {\n'+FunStart()+getLocals();
    if (o.expects) {
      fun+=GetExpectsTester(o.expects,fn);
    }
    fun+=o.body+FunStop(); // function body
    fun+='}';
  
    if (fun.indexOf('^{this}')>-1) error("Cannot use unrooted . accessor without a context\n\n"+fun);
    fun=RV(fun,{this:false,super:'_'+fn});
  
    r=head+fun+tail;
    return r;

  }

  function VerbCat(v) {
//       console.log("VerbCat");
//       console.log(v);
     if (v.left) {
       return v.left+v.base+v.right;
//     } else if (v.call) {
//       if (test) {
//         return RV('((undefined===($_c=^{verb}(($_d=^{base}),^{param})))?$_d:$_c)',v);
//       } else {
//         return v.verb+'('+v.base+(v.param?(','+v.param):'')+')';
//       }
     } else {
       if (v.test) {
         return RV('((undefined===($_c=($_d=^{base})^{verb}(^{param})))?$_d:$_c)',v);
       } else {
         return v.base+v.verb+'('+v.param+')';
       }
     }
  }
 
  function AssembleVerb(v) {
     if (v.length==1) {
//       console.log("AV 1");
//       console.log(v[0]);
       return VerbCat(v[0]);
     }
     FunctionChain=true;
     var base=v[0].base;
     for (var i in v) {
       v[i].base=base;
       v[i].test=true;
       base=VerbCat(v[i]);
     }
     return base;
  }
  
  
  function FunStart() {
    return '';
    //return ' /*:FUNSTART:*/ ';
  }
  function FunStop() {
    return '';
    //return ' /*:FUNSTOP:*/ ';
  }
  function VarUse(v) {
    return '';
    //return [].concat(v).map(function(v) { return ' /*:VAR:'+v+':*/ '});
  }
  function FixVars(code) {
  }
  
  
}


start
  = OptionalEOLs r:Reference? o:Object+ {
    code='';
    if (r) code+=r;
    code+=o.join('\n');
    return code;
  }
  
Reference 
= REFERENCE _ v:ParameterList EOLs {
  if (v[0]!='fields') error("REFERENCE requires a trait list.");
  code='';
  for (var i in v[2]) {
    var r=v[2][i];
    code+='var '+r[0]+'='+r[1]+';\n';
  }
  return code;
}

Object
 = OBJECT _ k:Identifier _ v:SemVer? _ EOLs s:Segment+ {
    if (!v) v=quoted('0.0.0-unspecified');
    var code='',isof='';
    var isa=quoted(k);
    addToList('lock','isa')
    addToList('freeze','isof')
    code+='prototype.isa='+isa+';\n';
    isof+='version:'+v+',';
    isof+='isa:'+isa+',';
    isof+='info:__info';
    code+='prototype.isof['+isa+']={'+isof+'};\n';
    var l;
    if (l=getList('lock')) code+='prototype.__tobelocked=prototype.__tobelocked.concat('+l+');\n';
    if (l=getList('freeze')) code+='prototype.__tobefrozen=prototype.__tobefrozen.concat('+l+');\n';
    code+=s.join('\n');
    clearLists();
    return code;
  }

Segment
 = v:(Inherit / Contract / PropertyDef / Task / Define) { return v }
 / EOLs


Inherit
 = INHERIT _ v:SimpleList EOLs {
   var inherit='['+v.join(',')+']';
   var code='prototype.isof[prototype.isa].inherit=prototype.__inherits='+inherit+';\n';
   return code;
  }

Contract
 = CONTRACT _ v:SimpleList EOLs {
   return 'prototype.__contracts=prototype.__contracts.concat(['+v.join(',')+']);\n';
  }

PropertyDef
 = v:Identifier p1:PropertyClause p2:PropertyClause?  {
   var prop={get: undefined, set: undefined};
   prop[p1[0]]=p1[1];
   if (p2) {
     prop[p2[0]]=p2[1]; 
   }
   var ret='Object.defineProperty(prototype,"'+v+
     '",{configurable:true,enumerable:true,get:'+prop.get+
     ',set:'+prop.set+
     '});\n';
   addToList('lock',v);
   return ret;
}

PropertyClause
 = _ g:(GET/SET) _ w:Output? _ b:Block EOLs { 
   if (!g) g='get'; 
   if (g=='get') w=null; 
   return [g,TaskFormatter({prefix:g,name:w,body:b})]; 
  }

Task
 = v:TaskEvent k:Block EOLs {
   v.body=k;
   return TaskFormatter(v);    
  } 

TaskEvent
 = v:Identifier _ TASK _ x:Expects? _ w:MultiOutput? _ { 
   return  {name:v,expects:x,as:w,kind:'function'};
 } 
 / v:Identifier _ PROCESS _ x:Expects? _ w:MultiOutput? _ { 
   return  {name:v,expects:x,as:w,kind:'function*'};
 } 



TaskClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:'return '+b+';',kind:'function'});
}

IteratorClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}

PromiseClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({
    expects:x,
    as:o,
    block:b,
    kind:'function',
    preface:'return new Promise(function($_resolve,$_reject) {',
    postface:'}'
  });
}



ExpectsParameter
 = i:Parameter _ t:Term? _ { return [i[1],t?t:true] }

Expects 
 = EXPECTS _ is:(i:ExpectsParameter COMMA _ {return i})* i:ExpectsParameter { is.push(i); return is; }
 / EXPECTS _ t:Term _ { return [[['','_root'],t]] }
 
Block
 = _ EOLs INDENT EOLs v:Lines DEDENT { return v }
 / _ '..' _ v:Line &EOLs { return v+';' }

Lines
 = v:(LineTerm)+ { return v.join('') }

LineTerm
 = v:Line EOLs { return v }

Line
 = IfStatement
 / SetStatement
 / ReturnStatement
 / IterateStatement
 / WithStatement
 / SwitchStatement
 / TryStatement
 / ThrowStatement
 / LocalStatement
 / MiscStatement
 / VerbStatement
 




MiscStatement
 = BREAK _ { return 'break;\n'; }
 / CONTINUE _ { return 'continue;\n' }
 / ORPHAN _ { return 'var $=this;\n' }


SwitchStatement // test 'switch*'
 = s:SwitchClause o:Output? EOLs INDENT c:(EOLs c:CaseClause {return c})+ d:(EOLs d:DefaultClause {return d})? EOLs DEDENT {
   o=o?o:tempvar();
   addLocal(o);
   var r=RV('switch (^{output}=('+s+')) {\n',{output:o});
   for (var i in c) {
     for (var j in c[i][0]) {
       r+='case ('+c[i][0][j]+'): ';
     }
     r+=c[i][1]+' break; \n';
   }
   if (d) r+='default: '+d+' break; \n';
   r+='}\n';
   return r;
 }

SwitchClause
 = SWITCH Sep e:Expression { return e; }

CaseClause
 = CASE Sep e:Items _ b:Block { return [e,b]; }

DefaultClause
 = DEFAULT Sep b:Block { return b; }



ThrowStatement // maybe get an accurate line number in here someday?!
 = THROW _ p:Expression { // test 'throw'
 return 'throw '+p+';\n' }

TryStatement // test 'try*'
 = t:TryClause c:(EOLs c:CatchClause {return c})? f:(EOLs f:FinallyClause {return f})? {
   if (!(c||f)) error("TRY needs a CATCH and/or FINALLY");
   return t+(c?c:'')+(f?f:'');
 }

TryClause
 = TRY _ b:Block { return 'try {'+b+'}\n'; }
 
CatchClause // test 'catch*'
 = CATCH _ o:Output? _ b:Block { 
   o=o?o:tempvar();
   addLocal(o);
   return RV('catch (^{error}) {'+b+'}\n',{error:o}); 
 }
 
FinallyClause // test 'finally*'
 = FINALLY _ b:Block { return 'finally {'+b+'}\n' }
 


IfStatement
 = i:IfClause l:(EOLs l:ElseIfClause {return l})* e:(EOLs e:ElseClause {return e})? { return i+l.join('')+(e?e:'') }


IfClause
 = EXISTS _ c:Expression out:Output? b:Block  { // test 'exists*'
   if (!out) out=tempvar();
   addLocal(out);
   return RV('if (undefined !==(^{this}=(^{condition}))) {\n'+b+'\n}\n',{this:out,condition:c}); 
 }
 / IF _ c:Expression out:Output? b:Block  { // test 'if*'
   if (!out) out=tempvar();
   addLocal(out);
   return RV('if ((^{trial}=(^{condition}))) {\n'+b+'\n}\n',{trial:out,condition:c}); 
 }
 / UNLESS _ c:Expression b:Block  { // test 'unless*'
   return 'if (!('+c+')) {\n'+b+'\n}\n' }

ElseIfClause
 = ELSE _ b:IfClause { return 'else '+b+'\n' }
 
ElseClause
 = ELSE _ b:Block   { return 'else {'+b+'}\n' }
 
LocalStatement
 = LOCAL _ l:(l:Local _ ',' _ { return l } )* o:Local _ {
   l=l||[]; l.push(o);
   j=[]; for (i in l) j.push(l[i][0][1]);
   return 'var '+j.join(',')+';\n';
 } 
 
 
WithStatement
  = WITH _ value:Expression out:Output? block:Block {
      var r={this:(out?out:tempvar())};
      var code=RV('var ^{this}=',r)+value+RV(';\n'+block+'\n',r);
      return code; 
  }
 

 
SetStatement
 = SET Sep t:SetTerms { return t }
 / SET Sep EOLs INDENT EOLs t:SetBlock DEDENT { return t.join(''); } 
 / INC Sep v:LValue _ { return v+'++;\n'; } // test 'inc a'
 / DEC Sep v:LValue _ { return v+'--;\n'; } // test 'dec a'
 / DELETE Sep v:RValue _ { return 'delete '+v+';\n'; }

SetTerms
 = t:SetTerm _ v:(',' _ v:SetTerm _ { return v })*  { return v.concat(t) }
  
SetLine
 = v:SetTerms EOLs { return v }

SetBlock
 = v:(SetLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

SetTerm
 = local:LocalAdj? _ l:LValues _ (TO/&FROM/&CHAIN) _ e:Expression {
   local=local?'var ':'';
   if (l.length==1) return local+l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_=[].concat('+e+');\n';
   for (var i in l) {
     code+=local+l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / local:LocalAdj? _ l:RValues _ o:Itselfop _ e:Expression {
   local=local?'var ':'';
   code='';
   for (var i in l) {
     code+=local+RV(itselfops[o], {'1':l[i], '2':RV(e,{self:l[i]}) } )+';\n';
   }
   return code;
 }
 / local:LocalAdj? _ l:RValues _ o:UnOp {
   code='';
   local=local?'var ':'';
   for (var i in l) {
     code+=local+RV(unops[o],{'1':l[i]})+';\n';
   }
   return code;
 }


LocalAdj
 = LOCAL Sep { return 'local '; }


UnOp // test 'self*'
 = '-' / INC / DEC  / DELETE / NOTB / NOT

Itselfop // test 'self*'
 = '+' / '-' 
 / '**' / '*' / '/' / '%' / '<<' / '>>' / '>>>'
 / ANDB / ORB / XORB
 / AND / OR / XOR / NAND / NOR
 / '?>' / '?<'
 / UPDATE / DELETE
 / VIA / DEFAULT



VerbStatement
 = v:VerbSentence  { return v+";\n"; }
 / v:VerbChain { return v+';\n'; }
 
ReturnStatement
 = RETURN k:(Sep k:Expression { return k })?  { 
   return 'return '+(k?k:'')+';\n' 
  }
 / r:(ResolveReject) Sep k:Expression?   { 
   return r+'('+(k?k:'')+');\n' ;
  }
 / YIELDING Sep k:Expression { 
   return 'yield *'+'('+k+');\n' ;
  }
 / YIELD Sep k:Expression { 
   return 'yield '+'('+k+');\n' ;
  }

ResolveReject
 = RESOLVE { return '$_resolve' }
 / REJECT { return '$_reject' }

NoneClause
 = ELSE Sep b:Block  { return '{'+b+'}\n' }


IterateStatement
 = ITERATE Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
   var w={block:b,t1:tempvar(),t2:tempvar(),v:v,none:n,k:tempvar(),this:(o?o[0]:false)};
   var setup='var ^{t1}=^{v}; var ^{t2}=^{t1}.next();\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'';
   var iterate='while (!^{t2}.done) { ^{this}=^{t2}.value; ^{block}; ^{t2}=^{t1}.next(); }\n';
   return RV(setup+none+iterate,w); 
  }
 / ITERATE Sep v:Expression _ USING Sep task:Value n:(EOLs n:NoneClause {return n})? {
   var w={task:task,t1:tempvar(),t2:tempvar(),v:v,none:n,k:tempvar()};
   var setup='var ^{t1}=^{v}; var ^{t2}=^{t1}.next();\n';
   var none=n?'if (^{t2}.done) { ^{none} } else \n':'';
   var iterate='while (!^{t2}.done) { ^{task}(^{t2}.value); ^{t2}=^{t1}.next(); }\n';
   return RV(setup+none+iterate,w); 
  }
 / EACH Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
     var w={b:b,j:tempvar(),v:v,n:n,k:tempvar(),key:(o?o[1]:false),this:(o?o[0]:false),list:(o?o[2]:false)};
     var setup='var ^{list}=^{v};\nif (undefined===^{list}) ^{list}=[];';
     var iterate='for (var ^{key} in ^{list}) { var ^{this}=^{list}[^{key}];\n^{b}}\n'+(n?'if (undefined===^{key}) { ^{n} }\n':'');
     return RV(setup+iterate,w); 
  }
 / EACH Sep list:Expression _ USING Sep task:Value none:(EOLs n:NoneClause {return n})? {
     var w={task:task,list:list,j:tempvar(),k:tempvar(),none:none};
     var setup='var ^{j}=^{list};\nif (undefined===^{j}) ^{j}=[]; ';
     var iterate='for (var ^{k} in ^{j}) ^{task}(^{j}[^{k}],^{k},^{j});\n';
     var final=none?'if (^{k}===undefined) { ^{none} }\n':'';
     return RV(setup+iterate+final,w); 
  }
 / PLY Sep v:Expression o:IterateOutput? b:Block n:(EOLs n:NoneClause {return n})? {
     var w={b:b,i:i,j:tempvar(),v:v,n:n,k:tempvar(),l:tempvar(),key:(o?o[1]:false),this:(o?o[0]:false),list:(o?o[2]:false)};
     var setup='var ^{list}=^{v};\nif (undefined===^{list}) ^{list}=[]; ';
     var iterate='var ^{l}=^{list}.length; if (^{l}) { var ^{this},^{key}=0; while (^{key}<^{l}) { ^{this}=^{list}[^{key}];\n^{b}\n^{key}++; } } '+(n?'else { ^{n} }':'')+'\n';
     return RV(setup+iterate,w); 
  }
 / PLY Sep list:Expression _ USING Sep task:Value none:(EOLs n:NoneClause {return n})? {
     var w={task:task,list:list,l:tempvar(),j:tempvar(),k:tempvar(),none:none};
     var setup='var ^{j}=^{list};\nif (undefined===^{j}) ^{j}=[]; var ^{l}=^{j}.length;\n';
     var test=none?'if (!^{l}) ^{none} else ':'';
     var iterate='for (var ^{k}=0; ^{k}<^{l}; ^{k}++) { ^{task}(^{j}[^{k}],^{k},^{j}) };\n';
     return RV(setup+test+iterate,w); 
  }
 / COUNT Sep DOWN Sep start:Expression stop:(TO Sep x:Expression {return x})? out:IterateOutput? block:Block none:(EOLs n:NoneClause {return n})? { // test 'count to*'
     if (!stop) stop=0;
     var w={start:start,stop:stop,out:out,block:block,none:none,dest:tempvar(),key:(out?out[0]:false)};
     var setup='var ^{key}=^{start},^{dest}=^{stop};\n ';
     var alternate=none ? 'if (^{key}<=^{dest}) { ^{none} } else ' : '';
     var iterate='while (^{key}>^{dest}) { ^{key}--; ^{block} }\n';
     return RV(setup+alternate+iterate,w); 
  }
 / COUNT Sep start:(x:Expression _ TO Sep { return x })? stop:Expression out:IterateOutput? block:Block none:(EOLs n:NoneClause {return n})? { // test 'count to*'
     if (!start) start=0;
     var w={start:start,stop:stop,out:out,block:block,none:none,dest:tempvar(),key:(out?out[0]:false)};
     var setup='var ^{key}=^{start},^{dest}=^{stop};\n ';
     var alternate=none ? 'if (^{key}>=^{dest}) { ^{none} } else ' : '';
     var iterate='while (^{key}<^{dest}) { ^{block} ^{key}++; }\n';
     return RV(setup+alternate+iterate,w); 
  }
  / WHILE Sep v:Expression b:Block {
    return 'while ('+v+') { '+b+' }\n';
  }



LValues
 = v:LValue a:LValueSep* _ { return [v].concat(a) }
 
LValueSep
 = ',' _ v:LValue { return v }

LValue 
 = v:LStem
  {
    j=v.length;
    if (!j) error("Expected something to assign into");
    if (j==1) {
      var pattern=accessors.firststore[v[0][0]];
      if (!pattern) error("Couldn't construct recipient from "+v);
      return pattern[0] + v[0][1] + pattern[1];
    }
    j--;
    var code='';
    var patternbase=accessors.firstfetch;
    i=0; while (i<j) {
      var pattern=patternbase[v[i][0]]; patternbase=accessors.nextfetch;
      if (!pattern) error("Couldn't construct recipient from "+v);
      code+=pattern[0] + v[i][1] + pattern[1];
      i++;
    }
    var pattern=accessors.laststore[v[j][0]];
    if (!pattern) error("Couldn't construct recipient from "+v);
    code= code+pattern[0]+v[j][1]+pattern[1];
    return code;
  }


RValues
 = v:RValue a:RValueSep* { return [v].concat(a) }
 
RValueSep
 = ',' _ v:RValue { return v }

SimpleValue
 = v:SimpleTerm
  { return ValueCompositor(v,false) }

RValue 
 = v:RStem
  { return ValueCompositor(v,false) }

RValueSafe
 = v:RStem
  { return ValueCompositor(v,true) }

VerbValue  
 = v:RStem
  {
    var verb='',stem='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(1,v[0][1].length-1);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    var patternbase=accessors.firstfetch;
    i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("VV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      stem+=verb;
      verb=pattern[0] + v[i][1] + pattern[1];
//      console.log("VV"+i+": stem:"+stem+" verb:"+verb);
      i++;
    }
    return [stem,verb];
  }
 


LStem
 = RStem
 ///ItStem / RootedStem / PropertyStem / ParameterStem / LocalStem 

RStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / LocalStem / GlobalStem / ParenStem



SuperStem
 = SUPER _ { return [['super','']]; }

PropertyStem 
 = x:Property y:(Attribute/Index/Call)*  { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RootedStem
 = x:Root y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

GlobalStem
 = x:Global y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

LocalStem
 = x:Local y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

ParameterStem
 = x:Parameter y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }

ItStem
 = x:(It) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }
 
ParenStem
 = x:(Parenthetic) y:(Attribute/Index/Call)+ {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }
 

It
 = IT Sep { return [['it','']] }
 / KEY Sep { return [['key','']]}
 / TRIAL Sep { return [['trial','']]}
 / ACCUM Sep { return [['accum','']]}
 / SELF Sep { return [['self','']]}
 / ERROR Sep { return [['error','']]}

Attribute
 = DOT v:IdentifierProto { return [[ 'attribute', v ]] }
 
Call
 = '(' _ p:ParameterList? _ ')' _ { 
   return [[ 'function', p?p[1]:'' ]] 
}
 
Root
 = DOT !DOT v:IdentifierProto { return [[ 'it', ''],[ 'attribute', v ]] }
 / DOT !DOT { return [[ 'it', '']] }
 / '|' v:SimpleValue { return [['it',''],['index',v]] }

Index
 = '[' _ v:Expression _ ']' _ { return [[ 'index', v ]] }
 / '|' v:SimpleValue { return [[ 'index', v ]] }

Parenthetic
 = '(' _ v:Expression _ ')' { return [[ 'paren', v ]] }

Local
 = v:Identifier { 
   if (!options.globals[v]) addLocal('$'+v); 
   return [[ 'local','$'+v ]];
}

Parameter
 = '$' v:IdentifierProto { return [[ 'parameters','' ],['attribute',v]] }
 / '$' { return [[ 'parameters','' ]]}

Global
 = '~' v:JSIdentifier { return [['global',v]] }

Property
 = '@' v:IdentifierProto { return [['this',''],[ 'attribute',v ]] }
 / '@' { return [['this','']] }

SimpleTerm
 = It/Local/Parameter/Property/Root
 / v:Number { return [['literal',v]] }

// DEFINITIONS

 
 


Define
  = GIVEN _ k:Identifier _ v:Definition EOLs { 
     addToList('freeze',k);
     return 'prototype["'+k+'"]='+v[1]+';\n';
   } 
  / GIVEN _ v:Definition EOLs { 
//    addToList('lock',i);
    var code='';
    code+='var t='+v[1]+';\nfor (var i in t) { prototype.__tobelocked.push(i); prototype[i]=t[i]; };\n'; 
    return code;
  }
  / SET _ v:Definition EOLs { return 'var Constructor=prototype.Constructor || function(){};\nprototype.Constructor=function() {\nConstructor.call(this);\nvar t='+v[1]+'; for (var i in t) this[i]=t[i];\n};\n'; }



SemVer
 = maj:PositiveInteger DOT min:PositiveInteger DOT patch:PositiveInteger {
   return "'"+maj+"."+min+"."+patch+"'";
 }


ParameterList
 = _ COLON _ EOLs INDENT EOLs v:FieldBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields', '{'+w.join(',')+'}',v] }
 / _ COLON _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['array',v.join(','),v] }
 / _ COLON? _ v:Fields ';'? { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields','{'+w.join(',')+'}',v] }
 / _ COLON? _ v:Items ';'? { return ['array',v.join(','),v] }
 / ';' { return null }

Definition
 = _ v:Item { return ['literal',v] }

 
NestedDefinition
 = _ EMPTY _ { return ['literal','[]']; }
 / _ BLANK _ { return ['literal','{}']; }
 / _ LIST _ v:Terms _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ LIST _ EOLs INDENT EOLs v:TermBlock DEDENT { return ['literal','['+v.join(',')+']'] }
 / _ TRAITS _ v:Traits _ SEMI? _ { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ TRAITS _ EOLs INDENT EOLs v:TraitBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/ARRAY) _ v:Items _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ (COLON/ARRAY) _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['literal','['+v.join(',')+']'] }


SimpleList
 = _ (COLON/LIST) _ v:Terms _ SEMI? _ { return v }
 / _ (COLON/LIST) _ EOLs INDENT EOLs v:TermBlock DEDENT { return v }


Term
 = EQUALS _ v:Expression { return v }
 / v:NestedDefinition { return v[1] }
 / MultiString
 / Number
 / TRUE
 / FALSE
 / StringLiteral
 / BareString
  
BareString
 = v:[^\n\},);|]+ &('|' / ',' / ')' / ';' / EOLs) { return quoted(v.join('').trim()) } 


TermSep
 = v:Term _ COMMA _  { return v }
 
Terms
 = v:(TermSep)* t:(Term) { return v.concat(t) }
  
TermLine
 = v:Terms EOLs { return v }

TermBlock
 = v:(TermLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Item
 = Expression

ItemSep
 = v:Expression _ COMMA _  { return v }
 
Items
 = v:(ItemSep)* t:(Item) { return v.concat(t) }
  
ItemLine
 = v:Items EOLs { return v }

ItemBlock
 = v:(ItemLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 

Trait
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword _ v:Term _ { return [[k,v]] }
 
TraitSep
 = v:Trait _ COMMA _ { return v }

Traits
 = v:(TraitSep)* t:(Trait) { var r=[]; for (var i in v) r=r.concat(v[i]); r=r.concat(t);  return r; }
 
TraitLine
 = v:Traits EOLs { return v }
 
TraitBlock
 = v:(TraitLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Field
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword _ v:Expression _ { return [[k,v]] }
 
FieldSep
 = v:Field _ COMMA _ { return v }

Fields
 = v:(FieldSep)* t:(Field) { var r=[]; for (var i in v) r=r.concat(v[i]); r=r.concat(t); return r; }
 
FieldLine
 = v:Fields EOLs { return v }
 
FieldBlock
 = v:(FieldLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 
 
Output
 = AS _ v:Local _ { return v[0][1] }

IterateOutput
 = o:MultiOutput {
   var v=[];
   for (i in o) v.push(o[i][0][1]);
   return v;
 }
 
MultiOutput
 = AS _ k:(k:Local _ COMMA _ {return k})* _ v:Local { k.push(v); return k; }
 
 


Expression
 = v:ListQualify



ListQualify
 = v:Logical _ c:(c:Comprehension _ {return c})* {
   for (var i in c) {
     v=c[i][0]+v+c[i][1];
   }
   return v;
 } 

Comprehension
 = MapComprehension 
 / AuditComprehension
 / ReduceComprehension 
 / FilterComprehension 
 / SortComprehension 
 / KeysComprehension 
 / ValuesComprehension
 / SowComprehension
 / ReapComprehension
 / AlterComprehension
 / ObserveComprehension
 / OtherComprehension


SowComprehension
 = SOW { // test 'sow *'
     return ['_$AI.sow(',')'];
   }

KeysComprehension
 = KEYS { // test 'keys comp*'
     return ['_$AI.keys(',')'];
   }

ValuesComprehension
 = VALUES { // test 'values comp*'
     return ['_$AI.values(',')'];
   }

ReapComprehension
 = REAP { 
     return ['_$AI.reap(',')'];
   }

SortComprehension
 = BY Sep x:SortComprehension2 { return x }
SortComprehension2
 = o:IterateOutput? b:Block {
    if (!o) o=['$a','$b'];
    var block=RV('function('+o[0]+','+o[1]+'){'+b+'}');
    return ['_$AI.sort(' , ','+block+')']; 
  }
 / USING Sep x:Value {
   return ['_$AI.sort(' , ','+x+')' ];
  }

MapComprehension
 = THRU Sep x:MapComprehension2 { return x }
MapComprehension2
 = x:Logical { // test 'thru inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'}',{this:'$_v',key:'$_k'});
     return ['_$AI.map(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'thru block'
     var block=RV('function(^{this},^{key}){'+b+'; return ^{this};}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['_$AI.map(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'thru using'
   return ['_$AI.map(' , ','+x+')' ];
  }

AuditComprehension
 = AUDIT Sep x:AuditComprehension2 { return x }
AuditComprehension2
 = x:Logical { // test 'audit inline *'
     var block=RV('function(^{this},^{key}){ '+x+'; }',{this:'$_v',key:'$_k'});
     return ['_$AI.audit(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'audit block*'
     var block=RV('function(^{this},^{key}){'+b+' }',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['_$AI.audit(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'audit using*'
   return ['_$AI.audit(' , ','+x+')' ];
  }

ReduceComprehension
 = INTO Sep x:ReduceComprehension2 { return x }
ReduceComprehension2
 = into:IntoClause o:IterateOutput? b:Block {
    if (!o) o=[];
    if (!o[0]) o[0]='$accum';
    if (!o[1]) o[1]='$_v';
    if (!o[2]) o[2]='$_k';
    b+='return ^{accum};\n';
    var block=RV('function(^{accum},^{this},^{key}){'+b+'}',{accum:o[0],this:o[1],key:o[2]});
    if (into=='it') {
      return ['_$AI.reduce(' , ','+block+')' ];
    } else {
      return ['_$AI.reduce(' , ','+block+','+into+')' ];
    }
  }
 / into:IntoClause b:Logical {
    var block=RV('function(^{accum},^{this},^{key}){ return '+b+';}',{accum:'$accum',this:'$_v',key:'$_k'});
    if (into=='it') {
      return ['_$AI.reduce(' , ','+block+')' ];
    } else {
      return ['_$AI.reduce(' , ','+block+','+into+')' ];
    }
  }
  / into:IntoClause USING Sep x:Value  {
    if (into=='it') {
      return ['_$AI.reduce(' , ','+x+')' ];
    } else {
      return ['_$AI.reduce(' , ','+x+','+into+')' ];
    }
  }

FilterComprehension
 = HAS Sep x:FilterComprehension2 { return x }
FilterComprehension2
 = o:IterateOutput? b:Block {
     var block=RV('function(^{this},^{key}){'+b+'}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['_$AI.filter(' , ','+block+')']; 
  }
  / USING Sep x:Value {
    return ['_$AI.filter(' , ','+x+')' ];
  }


AlterComprehension
 = ALTER Sep x:AlterComprehension2 { return x }
AlterComprehension2
 = x:Logical { // test 'alter inline*'
     var block=RV('function(^{this}){ return '+x+'; }',{this:'$_v'});
     return [ '_$AI.alter(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'alter block*'
     var block=RV('function(^{this}){'+b+'; return ^{this}; }',{this:o?o[0]:'$_v'});
     return [ '_$AI.alter(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'alter using'
     return [ '_$AI.alter(' , ','+x+')']; 
  }
  
ObserveComprehension
 = OBSERVE Sep x:ObserveComprehension2 { return x }
ObserveComprehension2
 = x:Logical { // test 'observe inline'
     var block=RV('function(^{this}){ '+x+'; }',{this:'$_v'});
     return [ '_$AI.observe(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'observe block'
     var block=RV('function(^{this}){'+b+'; }',{this:o?o[0]:'$_v'});
     return [ '_$AI.observe(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'observe using'
     return [ '_$AI.observe(' , ','+x+')']; 
  }



OtherComprehension
 = _ q:(Quality / Criteria / Sequence / Limit)+ _ 
 {
   var code='({<>})';
   q=[].concat(q);
   var expr={quality:[],having:[],by:[],map:[],limit:[]};
   for (var i in q) { 
     for (var j=0; j<q[i].length; j+=2) {
       expr[q[i][j]].push(q[i][j+1]); 
     }
   }
   var conds=[];
   if (expr.quality.length) {
     for (var i in expr.quality) { 
       conds.push(expr.quality[i]); 
      }
   }
   if (expr.having.length) {
     var conds=conds.concat(expr.having.map(function(c){ return '('+c+')';}));
   }
   if (conds.length) {
     code=RV('_$AI.filter(^{v},function($_v,$_k){ return ^{c}; })',{v:code,c:conds.join(' && '),this:'$_v',key:'$_k'});
   }
   if (expr.limit.length && expr.limit[0].extract && expr.by.length) { // first/last singleton with a sort
     code='_$AI.reduce('+code+',function(a,b) { if (undefined===a) return b; var r; ';
     expr.by[0][1]*=expr.limit[0].sort; // flip sort if looking for "last"
     var conds=expr.by.map(function(c){
       c[0]=c[0]||'^{this}';
       var x1=RV(c[0],{this:'a'});
       var x2=RV(c[0],{this:'b'});
       return RV('r=_$AI.compare(^{x1},^{x2}); if (r<0) return ^{lt}; if (r>0) return ^{gt};\n',{x1:x1,x2:x2,lt:(c[1]>0?'a':'b'),gt:(c[1]>0?'b':'a')});
     });
     code+=conds.join(' ')+'return a; },undefined)';
   } else {
     if (expr.by.length) {
       code='_$AI.sort('+code+',function(a,b) { var aa,bb; ';
       var conds=expr.by.map(function(c){
         c[0]=c[0]||'^{this}';
         var x1=RV('aa='+c[0]+'; ',{this:'a'});
         var x2=RV('bb='+c[0]+'; ',{this:'b'});
         return x1+x2+RV('if (aa<bb) return ^{lt}; if (aa>bb) return ^{gt}; ',{c:c[0],lt:-c[1],gt:c[1]});
       });
       code+=conds.join(' ')+'return 0; })';
     }
     if (expr.limit.length) {
       var l=expr.limit[0];
       if (l.slice) {
         if (l.len) {
           code='_$AI.slice('+code+','+l.start+','+l.len+')';
         } else {
           code='_$AI.slice('+code+','+l.start+')';
         }
       }
       if (l.extract) { 
         code='_$AI.element('+code+',0)';
       }
     }
   } 
   return code.split('{<>}');
 }


 
Limit 
 = FIRST _ { return ['limit',{extract:true,sort:1}]; } 
 / LAST _ { return ['limit',{extract:true,slice:true,start:-1}]; } 
 / LIMIT _ s:Logical _ COMMA _ c:Logical _ { return ['limit',{slice:true,start:s,len:c}]; } 
 / LIMIT _ s:Logical _ { return ['limit',{slice:true,start:0,len:s}]; } 
 
Quality
 = HASH v:Keyword _ { return ['quality', '^{this}["'+v+'"]'] }
 / BANG HASH v:Keyword _ { return ['quality', '(!^{this}["'+v+'"])'] }

Criteria
 = HAS _ v:Logical _ { return ['having',v] }

Sequence
 = BY _ d:SortDirection _ { return ['by',[null,d?d:1]] }
 / BY _ v:Logical d:SortDirection? _ { return ['by',[v,d?d:1]] }
 / HIGHEST _ v:Logical _ { return ['by',[v,-1],'limit',{extract:true,sort:1}]}
 / LOWEST _ v:Logical _ { return ['by',[v,1],'limit',{extract:true,sort:1}]}

SortDirection
 = (ASCENDING/ASC) _ { return 1 }
 / (DESCENDING/DESC) _ { return -1 }



Logical
 = l:Comparison _ o:LogicalOp _ r:Logical { return '('+l+o+r+')' }
 / l:Comparison _ VIA _ f:VerbValue { return '('+f[0]+f[1]+')('+l+')' } // test 'via'
 / c:Comparison _ XOR _ l:Logical  { return '(_$AI.xor('+c+','+l+'))' } // test 'xor' 
 / l:Comparison _ NAND _ f:Logical { return '(!('+l+' && '+f+'))' } // test 'nand'
 / l:Comparison _ NOR _ f:Logical { return '(!('+l+' || '+f+'))' } // test 'nor'
 / c:Comparison _ '??' _ l:Logical _ '::' _ r:Logical { 
     return RV('((^{c})?(^{l}):(^{r}))',{c:c,l:l,r:r}); 
   } 
 / c:Comparison _ DEFAULT _ v:Logical  {  // test 'default*'
     SafetyFetch=true; 
     return RV('((undefined!==($_b=^{c}))?$_b:^{v})',{c:c,v:v}); 
   } 
 / c:Comparison _ INITIALIZED _ v:Logical  { // test 'initialized*'
     SafetyFetch=true; 
     return RV('((undefined!==($_b=^{c}))?$_b:(^{c}=^{v}))',{c:c,v:v}); 
   } 
 / v:Comparison _ { return v }

LogicalOp
 = AND Sep { return '&&' } // test 'and'
 / OR Sep { return '||' } // test 'or'
 
Comparison
 = l:Addition _ o:MathOp _ r:Comparison { return o+'('+l+','+r+')' }
 / l:Addition _ o:ComparisonOp _ r:Comparison { return '('+l+o+r+')' }
 / v:Addition _ { return v }
 
ComparisonOp
  = '>=' { return '>=' } // test '>='
  / '>' !'>' { return '>' } // test '>'
  / '=' { return '==' } // test '='
  / ISNT Sep { return '!==' } // test 'isnt'
  / IS Sep { return '===' } // test 'is *'
  / '<=' { return '<=' } // test '<='
  / '<' !'<' { return '<' } // test '<'
  / '!=' { return '!=' } // test '!='


MathOp
 = '?>' { return 'Math.max' } // test '?>'
 / '?<' { return 'Math.min' } // test '?<'
 / '<=>' { return '_$AI.compare' } // test '<=>'

   
   
Addition
 = l:Multiplication _ o:AdditionOp _ r:Addition { return '('+l+o+r+')' }
 / v:Multiplication _ { return v }

AdditionOp
 = '+' // test '+'
 / '-' // test '-'
 / ORB Sep {return '|' } // test 'binary or'
 / ANDB Sep {return '&'} // test 'binary and'
 / XORB Sep { return '^'}  // test 'binary xor'

Multiplication 
 = l:Value _ o:MultiplicationOp _ r:Multiplication { return '('+l+o+r+')' }
 / l:Value _ '**' _ r:Multiplication { // test '**'
   return 'Math.pow('+l+','+r+')' 
} 
 / l:Value _ OVERLAY Sep r:Multiplication { // test 'overlay *'
   return '_$AI.overlay('+l+','+r+')' 
 }
 / l:Value _ SELECT Sep r:Multiplication { // test 'select *'
   return '_$AI.select('+l+','+r+')' 
 }
 / l:Value _ EXPECTS Sep r:Multiplication { 
   return '_$AI.expects('+l+','+r+')' 
 }
 / v:Value _ { return v }

MultiplicationOp
 = '*' // test '*'
 / '/' // test '/'
 / '%' // test '%'
 / '>>>' // test 'rshz'
 / '>>' // test 'rsh'
 / '<<' // test 'lsh'

 
Value
 = '-' _ v:Value _ { return '(0-('+v+'))' } // test 'unary -'
 / NOTB Sep v:Value _ { return '(~('+v+'))' } // test 'unary binary not' 
 / NOT Sep v:Value _ { return '(!('+v+'))' } // test 'unary not'
 / TYPEOF Sep v:Value _ { return 'typeof ('+v+')'; }
 / NUMBER Sep v:Value { return '(_$AI.number('+v+'))'; } // test 'number *'
 / EXISTS Sep v:Value _ { return '(undefined!=='+v+')' } // test 'exists'
 / COPY Sep v:Value _ { return '_$AI.copy('+v+')'; } // test 'copy'
 / KEYS Sep v:Value _ { return '(_$AI.keys('+v+'))' } // test 'keys unary *'
 / VALUES Sep v:Value _ { return '(_$AI.values('+v+'))' } // test 'values unary*'
 / TASK Sep v:TaskClause _ { return v }
 / PROCESS Sep v:IteratorClause _ { return v }
 / PROMISE Sep v:PromiseClause _ { return v }
 / FROM Sep v:VerbSentence _ { return v }
 / YIELDING Sep v:Value _ { return 'yield *'+v; }
 / YIELD Sep v:Value _ { return 'yield'+v; }
 / '?' v:RValueSafe _ { return v }
 / v:RValue _ { return v }
 / VerbChain 
 / v:NestedDefinition { return v[1] }
 / o:NewObject _ { return o }
 / '(' _ v:Expression _ o:Output? ')' _ { 
   if (o) {
     addLocal(o);
     return RV('(^{out}='+v+')',{out:o}); 
   } else {
     return '('+v+')'; 
   }
  }
 / v:Literal _ { return v }
 / x:Regex _ { return x }

Regex
 = '/' x:(RegexEscape/RegexChar)+ '/' m:[igm]* _ {
   var re= '/'+x.join('')+'/'+m.join('');
   return re;
 }

RegexEscape 
 = '\\/' 
 
RegexChar
 = [^\n\r/]

Keyword
 = v:Identifier ![.(\[|] { return v } 
 / StringLiteral 
 / n:Number { return quoted(n.toString()); }
 
Identifier
 = !ReservedWord v:IdentifierProto { return v; }  

JSIdentifier
 = v1:[a-zA-Z_] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

IdentifierProto
 = v1:[a-zA-Z] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

Literal
 = TRUE 
 / FALSE
 / UNDEFINED 
 / Number 
 / StringLiteral

IntoClause
 = IT Sep { return 'it' }
 / r:Expression 


////////////////////////////////////////////////////////// VERBS


VerbSentence
 = v:VerbClause {
   return AssembleVerb(v);
 }

VerbClause
= v:(VerbValue) _ o:ParameterList?  { 
     composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$'+(o?(','+o[1]):'') }]; 
     return [{ base:v[0], verb:v[1], param:(o?o[1]:'') }]
  }
 / v:(VerbValue) _ { 
     composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$' }]; 
     return [{ base:v[0], verb:v[1], param:'' }]
   }


VerbChain
 = CHAIN _ v:Expression _ c:VerbChainBlock {
   c[0].base=v;
   return AssembleVerb(c);
 }


VerbChainBlock
 = EOLs INDENT EOLs l:(VerbChainLine)+ DEDENT { 
     return l ;
   }
 
VerbChainLine
 = c:Comprehension _ EOLs {
     return {left:c[0], right: c[1]}
  }
 / i:Identifier _ o:ParameterList? _ EOLs {
     return {verb:'.'+i, param:(o?o[1]:''), test:true}; 
  }

NewObject
// = NEW _ v:ClassName _ o:Parameters _ VerbTerminal { 
//   var clause;
//   if (o[0]=='list') clause=o[1].join(','); else clause=o[1];
//   return '_$AI.new("'+v+'",'+clause+')'; 
// }
// /
 = CREATE _ v:Value _ o:ParameterList?  { 
   return '_$AI.new('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / NEW Sep _ v:Value _ o:ParameterList? {
   return 'new '+v+'('+(o?o[1]:'undefined')+')'; 
 }

VerbTerminal
 = &EOLs / &CBRACE / &')' 

ClassName
 = n:[a-zA-Z0-9_/]+ { return n.join('') }


/////////////////////////////////////////////

Number
 = v:NumericLiteral 'o' { return v*(Math.PI/180) } 
 / NumericLiteral

NumericLiteral
 = Scientific
 / Real
 / Integer

Scientific
 = r:(Real/Integer) 'e' x:Integer { return r+'e'+x }
 
Real
 = w:Integer DOT f:Integer { return Number(w+'.'+f) }

Integer 
 = PositiveInteger
 / '-' v:PositiveInteger { return -v }
 / '+' v:PositiveInteger { return v }

PositiveInteger
 = v:[0-9]+ { return parseInt(v.join('')) } 

SimpleStringLiteral
 = '\'' v:(EscapedChar/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringLiteral
 = MultiString
 / '\`' v:Bareline { return v }
 / '\'' v:(EscapedChar/StringTemplate/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringTemplate/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringTickChar
 = v:[^\'\n] { return [true,v] }

StringQuoteChar
 = v:[^\"\n] { return [true,v] }

MultiString
 = "'''" _ EOLs INDENT EOLs v:(v:Bareline EOLs { return v} )* DEDENT &EOLs { return v.join("+'\\n'+") } 


Bareline
 = v:(EscapedChar/StringTemplate/BarelineStringChar)* &EOLs { return assembleLiteral(v) }

BarelineStringChar
 = v:[^\n}] { return [true,v] }  
  
EscapedChar
 = v:"\\'" { return [true,'\''] }
 / v:'\\"' { return [true,'"'] }
 / v:'\\$' { return [true,'$'] }
 / v:'\\&#123;' { return [true,'&#123;'] }
 / v:'\\&#125;' { return [true,'&#125;'] }

StringTemplate
 = '${' v:Expression '}' { return [false,v] }


__
 = Whitespace+

Sep
 = Whitespace
 / &[^a-zA-Z0-9_]
 
_
 = Whitespace*

Whitespace
 = EOL '...'
 / [\ ]
 
 
 
OptionalEOLs
 = EOL*
 
EOLs
 = EOL+

EOL
 = '//' [^\r\n]* CR
 / CR
 

CR
 = [\n\r]

OBRACE
 = '{'
 
CBRACE
 = '}'


ReservedWord
 = ReservedWords ![a-zA-Z_0-9] 

ReservedWords
 = SET
 / ACCUM
 / ALTER
 / ANDB 
 / AND
 / ARRAY
 / AS 
 / ASCENDING / ASC
 / AUDIT
 / BLANK
 / BREAK
 / BY
 / CASE
 / CHAIN
 / CREATE
 / COPY
 / DEC
 / DEFAULT
 / DELETE
 / DESCENDING / DESC
 / DOWN
 / EMPTY
 / ERROR
 / EXISTS
 / EXPECTS
 / FALSE
 / FIELDS
 / FIRST 
 / FROM
 / GET
 / HAS 
 / HIGHEST 
 / INC
 / INITIALIZED
 / INTO
 / ISNT
 / IS
 / KEYS
 / LAST
 / LIMIT
 / LIST
 / LOCAL
 / LOWEST 
 / LSH
 / NAND
 / NEW
 / NOR
 / NOTB
 / NOT
 / NUMBER
 / OBSERVE
 / ORB
 / ORPHAN
 / OR
 / OVERLAY
 / PROMISE
 / PROCESS
 / REAP
 / RSH
 / SELECT
 / SELF
 / SOW
 / TASK
 / TRIAL
 / THROW
 / THRU
 / TO
 / TRAITS
 / TRUE
 / TYPEOF
 / UNDEFINED
 / UPDATE
 / USING
 / VALUES
 / VIA
 / XORB
 / XOR
 / YIELDING
 / YIELD
 
ACCUM = 'accum'i
ALTER = 'alter'i
AND = 'and'i
ANDB = 'andb'i
ARRAY = 'array'i
AS = 'as'i
ASC = 'asc'i
ASCENDING = 'ascending'i
AUDIT = 'audit'i
BLANK = 'blank'i
BREAK = 'break'i
BY = 'by'i
CASE = 'case'i
CATCH = 'catch'i
CHAIN = 'chain'i
COPY = 'copy'i
CONTINUE = 'continue'i
CONTRACT = 'contract'i
COUNT = 'count'i
CREATE = 'create'i
DEC = 'dec'i
DEFAULT = 'default'i
DELETE = 'delete'i
DESC = 'desc'i
DESCENDING = 'descending'i
DOWN = 'down'i
EACH = 'each'i
ELSE = 'else'i 
EMPTY = 'empty'i
ERROR = 'error'i
EXISTS = 'exists'i
EXPECTS = 'expects'i
FINALLY = 'finally'i
FIELDS = 'fields'i
FIRST = 'first'i
FROM = 'from'i
GET = 'get'i
GIVEN = 'given'i
HAS = 'has'i
HIGHEST = 'highest'i
IF = 'if'i
INITIALIZED = 'initialized'i
INTO = 'into'i
INC = 'inc'i
INHERIT = 'inherit'i
ISNT = 'isnt'i
IS = 'is'i
ITERATE = 'iterate'i
IT = 'it'i 
KEYS = 'keys'i
KEY = 'key'i
LAST = 'last'i
LIMIT = 'limit'i
LIST = 'list'i
LSH = 'lsh'i
LOCAL = 'local'i
LOWEST = 'lowest'i
NAND = 'nand'i
NEW = 'new'i
NOR = 'nor'i
NOT = 'not'i
NOTB = 'notb'i
NUMBER = 'number'i
OBJECT = 'object'i
OBSERVE = 'observe'i
ORPHAN = 'orphan'i
OR = 'or'i
ORB = 'orb'i
OVERLAY = 'overlay'i
TRUE = 'true'i
FALSE = 'false'i
PLY = 'ply'i
PROMISE = 'promise'i
PROCESS = 'process'i
REAP = 'reap'i
RESOLVE = 'resolve'i
REJECT = 'reject'i
REFERENCE = 'reference'i
RETURN = 'return'i
RSH = 'rsh'i
SELECT = 'select'i
SELF = 'self'i
SET = 'set'i
SOW = 'sow'i
SUPER = 'super'i
SWITCH = 'switch'i
TASK = 'task'i
THROW = 'throw'i
THRU = 'thru'i
TRAITS = 'traits'i
TRIAL = 'trial'i
TRY = 'try'i
TO = 'to'i
TYPEOF = 'typeof'i
UNLESS = 'unless'i 
UNDEFINED = 'undefined'i
UPDATE = 'update'i
USING = 'using'i
VALUES = 'values'i
VIA = 'via'i
WHILE = 'while'i
WITH = 'with'i
XOR  = 'xor'i
XORB  = 'xorb'i
YIELDING = 'yielding'i
YIELD = 'yield'i

BANG = '!'
DOT = '.'
HASH = '#'
SEMI = ';'
COMMA = ','
COLON  = ':' !':' { return ':' }
INDENT = '{'
DEDENT = '}'
EQUALS = '='
 
 