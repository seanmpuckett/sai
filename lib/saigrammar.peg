
{
  var _bindings={};
  var _locals={};
  var reCache={};
  var Entity=false;
  var FunctionChain=false;
  var SafetyFetch=false;
  var References={};
  var InstanceVars={};
  var UnresolvedLocals={};
  var readOnlyReference=true;
  var usedMemberVar=false;
  var DynamicTaskClauseFormatter=undefined;
  var _db=false;
  var lp='_'; // prefix for bareword variables
  var LeakedMagic=/\^\{([a-z0-9]+)\}/;
  var failures=[];
  var filetools={};
  var ResWords={},ResWordsA=(
    "and,array,as,"+
    "bind,blank,"+
    "call,chain,create,copy,"+
    "default,"+
    "empty,enum,exists,expects,"+
    "false,fields,from,"+
    "get,"+
    ""+
    "initialized,is,isnt,isNaN,"+
    ""+
    "list,"+
    ""+
    "NaN,nand,new,nor,notb,not,number,null,"+
    "or,"+
    "promise,process,"+
    ""+
    "self,set,singleton,swap,"+
    "task,trial,to,traits,true,typeof,"+
    "undefined,using,"+
    "via,"+
    "").split(/,/);



  // preprocessing

  if (undefined===options.constructs) options.constructs={};
  for (var i=0; i<ResWordsA.length; i++) ResWords[ResWordsA[i]]=1;

  // error handling
  
  function fail(msg,loc) { failures.push(msg+" at:"+(loc?loc:location().start.offset)); }
  
  // runtime tools
  
  function AddTool(text) {
    filetools[text]=true;
  }
  function GetTools() {
    var tools='';
    for (var tool in filetools) {
      tools=tools+tool;
    }
    return tools;
  }

  
  function addInstanceVar(v) {
    if (!InstanceVars[v]) {
      //console.log("Added instance var "+v)
      CheckScope(v,"instance");
      InstanceVars[v]=true;
    }
  }

  function addInstanceVars(v) {
    var vt='return '+v[1]+';';
    try {
      var inst=new Function(vt)();
      for (var i in inst) {
        addInstanceVar(i);
      }
    } catch (e) {
      fail(e.message+"\n\nSAI compiler: Instance/Given variables can only be initialized with simple literal values. For more complex initialization, use Instantiate (but still declare them with instance).\n\nYour vars: "+v[1]);
    }
  }
  
  function checkUsedMemberVar(v) {
    if (usedMemberVar) {
      fail("SAI compiler: object task "+v+" is declared as unbound but uses a bareword access to "+usedMemberVar);
    }
    usedMemberVar=false;
  }

  function CheckScope(v,context) {
    //console.log("check scope "+context+": "+v);
    if (References[v]) {
      var message="SAI compiler: variable "+v+" is a Reference variable and cannot be used as a "+context+".";
      //console.log(message);
      fail(message);
    }
    if (InstanceVars[v]) {
      var message="SAI compiler: variable "+v+" is an Instance variable and cannot be used as a "+context+".";
      //console.log(message);
      fail(message);
    }
  }
  
  function addLocal(v,a) { 
    if (_db) console.log("request local "+v+" - "+a);
    if (References[v]) return;
    if (_bindings[v]) return;
    _locals._hasLocals=true;
    if (!_locals[v]) {
      _locals[v]=a?(v+a):v;
    } else if (a) {
      _locals[v]=v+a;
    }
    if (_db) console.log("  added local "+v+" - "+_locals[v]);
  }
  
  function checkLocal(v,name) {
    if (References[v]) return v;
    if (_bindings[v]) return v;
    if (!_locals[v]) {
      UnresolvedLocals[v]=name;
      return '^[U,b,?,'+v+','+name+','+location().start.offset+']';
    }
    return v;
  }
  
  function Linker(code,final) {
    var p=/\^\[U,(.),([^,]+),([^,]+),([^,]+),([^\]]+)\]/g;
    return code.replace(p,function(x,bound,task,v,name,loc) {
      if (References[v]) return v;
      if (_bindings[v]) return v;
      if (_locals[v]) return v;
      if (InstanceVars[name]) {
        usedMemberVar=name;
        if (bound=='u') {
          checkUsedMemberVar(task+"(u)");
        }
        return '$.'+name;
      }
      if (final) {
        fail('SAI Compiler: local variable "'+name+'" used without initialization',loc);
      } 
      return x; // unchanged
    });
  }
  
  function removeLocal(v) {
    if (_db) console.log("removed local "+v);
    delete _locals[v];
  }
  
  function getLocals() { 
    if (!_locals._hasLocals) return ''; 
    var k=[]; 
    for (var i in _locals) if (i!=='_hasLocals') {
      if (i!=_locals[i]) {
        k.push(_locals[i]);
      } else {
        k.unshift(_locals[i]);
      }
    } 
    var finalk=[];
    var klookup={};
    if (_db) {
      console.log("references");
      console.log(References);
      console.log("locals");
      console.log(_locals);
    }
    for (var i in k) {
      //console.log(k[i]);
      if (!References[k[i]]) finalk.push(k[i]);
      klookup[k[i]]=k;
    }
//    for (var i in UnresolvedLocals) {
//      if (!klookup[i] && !References[i]) {
//        error("SAI compiler: local variable used before initialization (beware forward declarations): "+UnresolvedLocals[i]);
//      }
//    }
    //console.log(finalk);
    finalk=finalk.sort(String.compare);
    var r='var '+finalk.join(',')+';\n'; 
    _locals={};
    UnresolvedLocals={};
    return r; 
  }

  function rep(list,val) {
    var j;
    for (var i in list) {
      if (j==val[list[i]]) list[i]=j;
    }
  }
 
  function RV(code,varnames) {
    
    if (!varnames) varnames={};
    var prefix=varnames._prefix || '';
    if (!code) {
      fail("SAI compiler: RV has undefined code; likely a syntax error; perhaps you need to use 'self'");
      return;
    }
    if (!code.replace) {
      code=code.toString();
    }
    var repl=function(key) {
      var val=varnames[key];
      if (undefined===val || null===val || false===val) {
        val=tempvar(prefix+key);
        addLocal(val);
      }
      var re=reCache[key]; if (!re) re=reCache[i]=new RegExp('\\^\\{'+key+'\\}','g');
      code=code.replace(re,val);
    };
    var completed={};
    var precedence=['block','this','key','list','counter'];
    for (var j in precedence) {
      var i=precedence[j];
      if (varnames.hasOwnProperty(i)) {
        repl(i);
        completed[i]=true;
      }
    }
    for (var i in varnames) {
      if (undefined===completed[i]) {
        repl(i);
      }
    }
    return code;
  }
  
  var varnum=0;
  function tempvar(prefix) {
    prefix=prefix ? '_'+prefix : '';
    var v="$"+(varnum++)+prefix;
    return v;
  }
  
  function quoted(v) {
    return "'"+v.replace(/\'/g,"\\\'")+"'";
  }
  
  var accessors = {
    firstfetch: { // [0]+key+[1]
      this: [ '$' , '' ],
      currentthis: [ 'this' , ''],
      local: [ '' , '' ], 
      arguments: [ 'arguments','' ],
      parameters: [ 'p','' ],
      it: [ '^{this}','' ],
      key: [ '^{key}','' ],
      counter: [ '^{counter}','' ],
      trial: [ '^{trial}','' ],
      sum: [ '^{sum}','' ],
      error: [ '^{error}','' ],
      self: [ '^{self}','' ],
      super: [ '^{super}','' ],
      paren: [ '', '' ],
      bound: [ '' , '' ],
      global: [ '' , '' ],
      function: [ '' , '' ],
      literal: ['','']
    },
    nextfetch: { // +[0]+key+[1]
      function: [ '(' , ')' ],
      attribute: [ '.' , '' ], 
      index: [ '[' , ']' ],
    },
    firststore: { //[0]+key+[1]
      function: [ '' , '' ],
      paren: [ '', '' ],
      local: [ '' , ''  ],
      error: [ '^{error}','' ],
      attribute: [ '^{this}.' ,  '' ],
      self: [ '^{self}','' ],
      sum: [ '^{sum}' , '' ],
      property: [ '$["' , '"]' ], 
      parameter: [ 'p["','"]' ],
    },
    laststore: { // +[0]+key+[1]
      attribute: [ '.' , '' ], 
      index: [ '[' , ']'  ],
    }
  };

  function safetyFetch(root,leaf) {
    SafetyFetch=true;
    return '(undefined===($_b=('+root+'))?undefined:($_b'+leaf+'))';
  }

  function ValueCompositor(v,safe) {
    //console.log("Value Compositor...");
    //console.log(v);
    var code='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    if (v[0][0]=='local') {
      code+=VarUse(v[0][1]);
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("SAI Compiler: RV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      var leaf=pattern[0] + v[i][1] + pattern[1];
      if (i>0 && safe) {
        code=safetyFetch(code,leaf);
      } else {
        code=code+leaf;
      }
      i++;
    }
    return code;
  }

  var itselfops = {
    '+': '^{1} += ^{2}' , // test 'self +'
    '-': '^{1} -= ^{2}' , // test 'self -'
    
    '*': '^{1} *= ^{2}' , // test 'self *'
    '/': '^{1} /= ^{2}' , // test 'self /'
    '%': '^{1} %= ^{2}' , // test 'self %'
    '<<': '^{1} <<= ^{2}' , // 
    '>>': '^{1} >>= ^{2}' , // 
    '>>>': '^{1} >>>= ^{2}' , // 
    'lsh': '^{1} <<= ^{2}' , // 
    'rsh': '^{1} >>= ^{2}' , // 
    'ursh': '^{1} >>>= ^{2}' , // 
    '**': '^{1} = Math.pow(^{1},^{2})' , // test 'self **'

    xorb: '^{1} ^= ^{2}' , // test 'self xorb'
    andb: '^{1} &= ^{2}' , // test 'self andb'
    orb: '^{1} |= ^{2}' , // test 'self orb'

    and: '^{1} = ^{1} && ^{2}', // test 'self and'
    or: '^{1} = ^{1} || ^{2}', // test 'self or'
    xor: '^{1} = $AI.xor_op(^{1},^{2})',  // test 'self xor'
    nand: '^{1} = (!((^{1})&&(^{2})))', // test 'self nand'
    nor: '^{1} = (!((^{1})||(^{2})))', // test 'self nor'

    '?>': '^{1} = Math.max(^{1},^{2})', // test 'self ?>'
    '?<': '^{1} = Math.min(^{1},^{2})', // test 'self ?<'
    
    default: 'if (undefined===^{1}) ^{1}=^{2}', // test 'self default*'
    '?': 'if (undefined===^{1}) ^{1}=^{2}', // test 'self default*'
  };

  var unops={
    '-': '^{1}=-(^{1})' , // test 'self negate'
    'not': '^{1}=!(^{1})', // test 'self not'
    'notb': '^{1}=~(^{1})', // test 'self notb'
  };  

  
  function assembleLiteral(v) {
    var build='';
    var result=[];
    for (var i in v) {
      var c=v[i];
      if (c[0]) {
        build+=c[1];
      } else {
        if (build.length) result.push(quoted(build));
        build='';
        if (!result.length) result.push(quoted(''));
        result.push(c[1]);
      }
    }
    if (build.length) result.push(quoted(build));
    if (!result.length) result=[quoted('')];
    return result.join('+');
  }

  var Lists={};
  function addToList(list,e) {
    var list=Lists[list] || (Lists[list]=[]);
    list.push(e);
  }
  function getList(list) {
    var list=Lists[list] || (Lists[list]=[]);
    if (list.length) {
      return '["'+list.join('","')+'"]';
    } 
    return '[]';
  }
  function clearLists() {
    Lists={};
  }
    
  function GetExpectsTester(x,name) {
    var l =[];
    for (var i in x) {
      var t=x[i][1] || 'true';
      var p='"'+x[i][0][1]+'":'+x[i][1];
      l.push(p);
    }
    return '$AI.expectsThrow(p,{'+l.join(',')+'},'+quoted(name)+');\n';
  }
  
  
  // expects
  // as
  // kind
  // body
  // preface
  // appendix
  function TaskClauseFormatter(o) {
    var params=[];
    if (!o.nodefaultparam) {
      params.push('p');
    }
    var expects='',locals=[];//$unused=this';
    if (o.expects && o.as) fail("SAI compile: cannot have both EXPECTS and AS in a function declaration");
    if (o.expects && o.expects.length) {
      expects=GetExpectsTester(o.expects,'in-line');
    } else if (o.as) {
      for (var i in o.as) {
        if (i==0) {
          locals.push(o.as[i][0][1]+'='+params[0]);
        } else {
          params.push(o.as[i][0][1]);
        }
      }
    }
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    var finallocals=[];
    for (var i in locals) if (!References[locals[i]]) finallocals.push(locals[i]);
    locals=locals.length?('var '+finallocals.join(',')+';'):'';
    var code = o.kind+'('+params.join(',')+'){'+o.preface+locals+expects+'{'+o.block+'}'+o.postface+'}';
    if (o.execute) code+='()';
    return code;
  }

  
  // prefix (v0)
  // name (v1)
  // as (v2)
  // expects (v3)
  // kind 
  // body (k)
  function TaskFormatter(o) {
    
    var fn=(o.prefix?o.prefix+'_':'')+o.name;
    var params='p';
    var paramspec=o.as||[];
    
    for (var i in paramspec) {
      var pname=paramspec[i][0][1];
      if (i==0) {
        addLocal(pname,'=p');
      } else {
        removeLocal(pname);
        params+=','+pname;
      }
    }

    if (SafetyFetch) { addLocal('$_b'); SafetyFetch=false; }
    if (FunctionChain) { addLocal('$_c'); addLocal('$_d'); FunctionChain=false; }
    if (!o.nothis) {
      if (o.unbound) {
        addLocal('$','=undefined');
      } else if (o.property) {
        addLocal('$','=this');
      } else {
        addLocal('$','=this['+fn+']?this:$bindfail('+fn+')');
      }
    }
    
    var rawFunctionName=fn.substring(1,fn.length-1);
    var head='', tail='';
    var sup=GlobVar();
    if (o.prefix!='get' && o.prefix!='set') {
      addToList('lock',rawFunctionName);
      head='var '+sup+'=prototype['+fn+'] || function(){};\n';
      if (o.unbound) {
        head+='var _'+rawFunctionName+'=';
      }
      head+='prototype['+fn+']=';
      tail=';\n';
    }
  
    if (o.unbound) {
      o.body=o.body.replace(/\^\[U,b,\?/g, "^[U,u,"+o.name);
    }
    o.body=Linker(o.body,false);
    if (o.unbound) {
      checkUsedMemberVar(fn+'(t)');
    } usedMemberVar=false;
  
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    var fun=o.kind+'('+params+') {\n'+o.preface+getLocals();
    if (o.expects) {
      fun+=GetExpectsTester(o.expects,fn);
    }
    fun+='{'+o.body+'}'+o.postface; // function body
    fun+='}';
  
    if (o.name) {
      if (fun.indexOf('^{this}')>-1) fail("SAI Compiler: Cannot use unrooted attribute (e.g. 'it') without a context, though the context may have been lost by a syntax error somewhere.\n\n"+fun);
    }
    var r=RV(head+fun+tail,{this:false,super:sup});

    return r;

  }

  function VerbCat(v) {
     if (v.left) {
       return v.left+v.base+v.right;
     } else {
       if (v.test) {
         return RV('((undefined===($_c=(($_d=^{base})^{verb}(^{param}))))?$_d:$_c)',v);
       } else {
         return v.base+v.verb+'('+v.param+')';
       }
     }
  }
 
  function AssembleVerb(v) {
     FunctionChain=true;
     if (v.length==1) {
       return VerbCat(v[0]);
     }
     var base=v[0].base;
     for (var i in v) {
       v[i].base=base;
       v[i].test=true;
       base=VerbCat(v[i]);
     }
     return base;
  }
  
  function EnumCheck(v) {
    var start=1;
    for (var i in v) {
      if (v[i][1]==='enum') {
        v[i][1]=start++;
      } else {
        var n=parseInt(v[i][1],10);
        if (!isNaN(n)) {
          start=n+1;
        }
      }
    }
    return v;
  }
  
  function GlobVar() {
    return '$'+(options.persist.globalcount++)+'g';
  }
  function VarUse(v) {
    return '';
    //return [].concat(v).map(function(v) { return ' /*:VAR:'+v+':*/ '});
  }
  function FixVars(code) {
  }

  function MagicCheck(code) {
    var lm=LeakedMagic.exec(code);
    
    if (lm) fail("SAI Compiler: Pronoun '"+lm[1]+"' used in the wrong place (but I can't tell you where yet, please search for your use of this variable and make sure it is contained within a construct that uses it.)\n\n");
  }
  
  function WhereAmI(line) {
    if (line && options.linenos) {
      return '/*@:'+line+'*/';
    }
    return '';
  }
  
}


startFile
  = OptionalEOLs r:Reference? o:Object+ {
    var code='';
    if (r) code+=r;
    code+=o.join('\n')
    MagicCheck(code);
    //console.log(code);
    code=Linker(code,true);
    if (failures.length) options.failures=failures.join('\n');
    code=GetTools()+code;
    return code;
  }
  
startExpression
 = code:Expression EOLs {
   MagicCheck(code); 
   code=Linker(code);
   if (failures.length) options.failures=failures.join('\n');
   return code;
 }
  
Reference 
= REFERENCE _ v:ParameterList EOLs {
  if (v[0]!='fields') fail("SAI Compiler: REFERENCE requires a trait list.");
  var code='';
  for (var i in v[2]) {
    var r=v[2][i];
    References[lp+r[0]]=true; 
    if (r[1].indexOf('function')==0) {
      fail("SAI Compiler: Cannot define functions in a reference block. Sorry, maybe someday.");
    }
    code+='var '+lp+r[0]+'='+r[1]+';\n'; 
  }
  return code;
}

Object
 = OBJECT _ k:Identifier _ typ:(MAIN/SINGLETON)? _ v:SemVer? _ EOLs d:Declarations* s:Processes* {
    if (!v) v=quoted('0.0.0-unspecified');
    var code='',isof=[];
    var isa=quoted(k);
    addToList('lock','isa')
    addToList('freeze','isof')
    code+='var isa=prototype.isa='+isa+';\n';
    isof.push('version:'+v);
    isof.push('isa:isa');
    isof.push('context:__context');
    if (typ) {
      isof.push('type:"'+typ+'"');
    }
    code+='var $bindfail=function(m){ throw new Error("SAI: A call to "+m+" on object "+isa+" has come unbound from any instance of that object. (If this is not in error, mark the declaration of "+m+" as unbound.)"); }\n';
    code+='prototype.isof['+isa+']={'+isof.join(',')+'};\n';
    var l;
    if (l=getList('lock')) code+='prototype.__tobelocked=prototype.__tobelocked.concat('+l+');\n';
    if (l=getList('freeze')) code+='prototype.__tobefrozen=prototype.__tobefrozen.concat('+l+');\n';
    code+=d.join('\n');
    code+=s.join('\n');
    clearLists();
    return code;
  }

Declarations
 = v:(Inherit / Contract / PropertyDef / Define) { return v }
 / EOLs

Processes
 = v:(Task) { return v }
 / EOLs


Inherit
 = INHERIT _ v:SimpleList EOLs {
   var inherit='['+v.join(',')+']';
   var code='prototype.isof[prototype.isa].inherit=prototype.__inherits='+inherit+';\n';
   return code;
  }

Contract
 = CONTRACT _ v:SimpleList EOLs {
   return 'prototype.__contracts=prototype.__contracts.concat(['+v.join(',')+']);\n';
  }

PropertyDef
 = v:Identifier p1:PropertyClause p2:PropertyClause?  {
   addInstanceVar(v);
   var prop={get: undefined, set: undefined};
   prop[p1[0]]=p1[1];
   if (p2) {
     prop[p2[0]]=p2[1]; 
   }
   var ret='Object.defineProperty(prototype,"'+v+
     '",{configurable:true,enumerable:true,get:'+prop.get+
     ',set:'+prop.set+
     '});\n';
   addToList('lock',v);
   return ret;
}

PropertyClause
 = _ g:(GET/SET) _ w:MultiOutput? _ b:Block EOLs { 
   if (!g) g='get'; 
   if (g=='get') w=null; 
   return [g,TaskFormatter({prefix:g,as:w,property:true,body:b,kind:'function'})]; 
  }

Task
 = v:TaskEvent k:Block EOLs {
   v.body=k;
   return TaskFormatter(v);    
  } 

TaskEvent
 = v:Identifier _ TO? _ unbound:UNBOUND? _ TASK _ x:Expects? _ w:MultiOutput? _ { 
   if (unbound) {
     if (References[lp+v]) fail("SAI Compiler: "+v+" redefinition");
     References[lp+v]=v;
   } else {
     addInstanceVar(v);
   }
   return  {name:"'"+v+"'",unbound:unbound,expects:x,as:w,kind:'function'};
 } 
 / v:ProcessName _ TO? _ unbound:UNBOUND? _ PROCESS _ x:Expects? _ w:MultiOutput? _ { 
   if (unbound) {
     if (References[lp+v]) fail("SAI Compiler: "+v+" redefinition");
     References[lp+v]=v;
   } else {
     addInstanceVar(v);
   }
   return  {name:v,expects:x,unbound:unbound,as:w,kind:'function*'};
 } 
 / v:Identifier _ TO? _ unbound:UNBOUND? _ PROMISE _ x:Expects? _ o:MultiOutput? _ { 
   if (unbound) {
     if (References[lp+v]) fail("SAI Compiler: "+v+" redefinition");
     References[lp+v]=v;
   } else {
     addInstanceVar(v);
   }
   var vn="'"+v+"'";
   var isthis='this['+vn+']?this:$bindfail('+vn+')';
   if (unbound) {
     isthis='this';
   }
   return {
    name:vn
    ,expects:x
    ,unbound:unbound
    ,as:o
    ,nothis:true
    ,kind:'function'
    ,preface:'var $='+isthis+'; return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
    };
  } 

ProcessName
 = v:ITERATOR { return "Symbol.iterator" }
 / v:Identifier { return "'"+v+"'" }

TaskClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:'return '+b+';',kind:'function'});
}

IteratorClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}


PromiseClause
 = x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({
    expects:x
    ,as:o
    ,block:b
    ,kind:'function'
    ,preface:'return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
  });
}



ExpectsParameter
 = i:Parameter _ t:Term? _ { return [i[1],t?t:true] }

Expects 
 = EXPECTS _ is:(i:ExpectsParameter COMMA _ {return i})* i:ExpectsParameter { is.push(i); return is; }
 / EXPECTS _ t:Term _ { return [[['','_root'],t]] }
 
Block
 = _ EOLs INDENT EOLs v:Lines DEDENT &EOLs { return v }
 / _ '..' _ v:Line &EOLs { return v+';' }

Lines
 = v:(LineTerm)+ { return v.join('') }

LineTerm
 = v:Line w:EOLs { var l=WhereAmI(w); return v + l; }

Line
 = ConstructStatement
 / SetStatement
 / SwapStatement
 / NopStatement
 / VerbStatement
 
 
Pipers
 = p:(Piper)+ {
   var left='',right='';
   for (var i=0; i<p.length; i++) {
     left=p[i][0]+left;
     right=right+p[i][1];
   }
   return [left,right];
 }

Piper 
 = '|' _ i:BaseIdentifier &{ return options.pipers[i];} _ a:(
 
     &{ return options.pipers[i].clauses[i].expr        }  o:PiperExpr       { return o }
   / &{ return options.pipers[i].clauses[i].exprs       }  o:PiperExprs       { return o }
   / &{ return options.pipers[i].clauses[i].outblock    }  o:PiperOutblock       { return o }
   / &{ return options.pipers[i].clauses[i].valexpr     }  o:PiperValexpr       { return o }
   / &{ return options.pipers[i].clauses[i].valoutblock }  o:PiperValoutblock       { return o }
   / &{ return options.pipers[i].clauses[i].valuse      }  o:PiperValuse       { return o }
   / &{ return options.pipers[i].clauses[i].use         }  o:PiperUse       { return o }
   / &{ return options.pipers[i].clauses[i].none        }  o:PiperNone  { return o }
   
 ) _ cl:(cli:BaseIdentifier &{ return options.pipers[i].clauses[cli]; } _ cla:
      ( 
     &{ return options.pipers[i].clauses[cli].expr        }  o:PiperExpr       { return o }
   / &{ return options.pipers[i].clauses[cli].exprs       }  o:PiperExprs       { return o }
   / &{ return options.pipers[i].clauses[cli].outblock    }  o:PiperOutblock       { return o }
   / &{ return options.pipers[i].clauses[cli].valexpr     }  o:PiperValexpr       { return o }
   / &{ return options.pipers[i].clauses[cli].valoutblock }  o:PiperValoutblock       { return o }
   / &{ return options.pipers[i].clauses[cli].valuse      }  o:PiperValuse       { return o }
   / &{ return options.pipers[i].clauses[cli].use         }  o:PiperUse       { return o }
   / &{ return options.pipers[i].clauses[cli].none        }  o:PiperNone       { return o }
      )

   {return [cli,cla];})* {

   var opi=options.pipers[i];
   var clauses=[[i,a]].concat(cl);
   var work=[];
   for (var i=0; i<clauses.length; i++) {
      var cl=clauses[i];
      var w={
        clause: cl[0],
        syntax: cl[1].syntax,
        type: cl[0]+"."+cl[1].syntax,
        args: cl[1]
      };
      work[i]=w;
    }
    var tools={
        addlocal:function(v){ if (!v) v=tempvar(); addLocal(v); return v; },
        replacer:RV,
        tasker:TaskClauseFormatter
    };
    var result=opi.handler({work:work[0],clauses:work,tools:tools});
    if (result.error) fail(result.error);

    if (result.tools && result.tools.length) for (var tc=0; tc<result.tools.length; tc++) AddTool(result.tools[tc]);

    return result.leftright || ['',''];
 }

PiperValoutblock
 = v:Value _ o:MultiOutput? _ b:Block {
   return {
     syntax: 'valoutblock',
     val: v,
     out: o,
     block: b
   };
 }

PiperOutblock
 = o:MultiOutput? b:Block {
   return {
     syntax: 'outblock',
     out: o,
     block: b
   };
 }

PiperValuse
 = v:Value _ USING Sep u:Value {
   return {
     syntax: 'valuse',
     val: v,
     use: u
   };
 }

PiperUse
 = USING Sep u:Value {
   return {
     syntax: 'use',
     use: u
   };
 }

PiperValexpr
 = v:Value _ x:Logical {
   return {
     syntax: 'valexpr',
     val: v,
     expr: x
   };
 }

PiperExprs
 = x:LogicalList {
   return {
     syntax: 'exprs',
     exprs: x
   };
 }

PiperExpr
 = x:Logical {
   return {
     syntax: 'expr',
     expr: x
   };
 }

PiperNone
 = _ {
   return {
     syntax: 'none'
   };
 }



ConstructStatement
  = i:BaseIdentifier &{ return options.constructs[i]; } _ 
    a:(
         &{return options.constructs[i].clauses[i].exproutblock}   ca:CAExproutblock  {return ca}
       / &{return options.constructs[i].clauses[i].exprout}        ca:CAExprout     {return ca}
       / &{return options.constructs[i].clauses[i].exprsblock}     ca:CAExprsblock     {return ca}
       / &{return options.constructs[i].clauses[i].exprsoutblock}  ca:CAExprsoutblock     {return ca}
       / &{return options.constructs[i].clauses[i].exprusing}      ca:CAExprusing     {return ca}
       / &{return options.constructs[i].clauses[i].exprsusing}     ca:CAExprsusing     {return ca}
       / &{return options.constructs[i].clauses[i].outblock}       ca:CAOutblock      {return ca}
       / &{return options.constructs[i].clauses[i].block}          ca:CABlock      {return ca}
       / &{return options.constructs[i].clauses[i].exprs}          ca:CAExprs      {return ca}
       / &{return options.constructs[i].clauses[i].rvalue}         ca:CARvalue       {return ca}
       / &{return options.constructs[i].clauses[i].verb}           ca:CAVerb       {return ca}
       / &{return options.constructs[i].clauses[i].none}           ca:CANone       {return ca}

      )
    cl:(EOLs cli:Identifier &{
      if (cli===i && !options.constructs[i].repeats) return false;
      return options.constructs[i].clauses[cli];
    } _ cla:
      (
         &{return options.constructs[i].clauses[cli].exproutblock}  claa:CAExproutblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprout}       claa:CAExprout {return claa}
       / &{return options.constructs[i].clauses[cli].exprsblock}    claa:CAExprsblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprsoutblock} claa:CAExprsoutblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprusing}     claa:CAExprusing {return claa}
       / &{return options.constructs[i].clauses[cli].exprsusing}    claa:CAExprsusing {return claa}
       / &{return options.constructs[i].clauses[cli].outblock}      claa:CAOutblock {return claa}
       / &{return options.constructs[i].clauses[cli].block}         claa:CABlock {return claa}
       / &{return options.constructs[i].clauses[cli].exprs}         claa:CAExprs {return claa}
       / &{return options.constructs[i].clauses[cli].rvalue}        claa:CARvalue {return claa}
       / &{return options.constructs[i].clauses[cli].verb}          claa:CAVerb {return claa}
       / &{return options.constructs[i].clauses[cli].none}          claa:CANone{return claa}

      )
 {return [cli,cla];})* {
   
     var opi=options.constructs[i];
     var work=[[i,a]].concat(cl);
     var work2=[];
     for (var i1=0; i1<work.length; i1++) {
       var j=work[i1];
       if (j[1].syntax === 'error') {
         fail("SAI Compiler: Error in "+j[0]+" / "+i+" (this is a propogated error, look within the clause for syntax faults).",j[1].location);
       }
       work2.push({
         clause: j[0],
         syntax: j[1].syntax,
         type: j[0]+'.'+j[1].syntax,
         args: j[1]
       });
     }
    var result=opi.handler({
      clauses:work2,
      tools:{
        addlocal:function(v){ if (!v) v=tempvar(); addLocal(v); return v; },
        replacer:RV,
        tasker:TaskClauseFormatter
      }
    });
    if (result.error) fail(result.error);

    if (result.tools && result.tools.length) for (var tc=0; tc<result.tools.length; tc++) AddTool(result.tools[tc]);
    return result.body;
 }
 
CAError = .* { return { syntax: 'error', location: location().start.offset }; }
 
CAExprsoutblock = pl:LogicalList _ mo:MultiOutput? _ b:Block { return {
  syntax: 'exprsoutblock',
  exprs: pl,
  out: mo,
  block: b
}; }

CAExproutblock = x:Expression _ mo:MultiOutput? _ b:Block { return {
  syntax: 'exproutblock',
  expr: x,
  out: mo,
  block: b
}; }

CAExprout = x:Expression _ mo:MultiOutput? _ { return {
  syntax: 'exprout',
  expr: x,
  out: mo,
}; }

CAExprusing = x:Expression _ USING Sep task:Value { return {
  syntax: 'exprusing',
  expr: x,
  using: task
}; }

CAExprsusing = pl:LogicalList _ USING Sep task:Value { return {
  syntax: 'exprsusing',
  exprs: pl,
  using: task
}; }

CAOutblock = mo:MultiOutput? _ b:Block { return {
  syntax: 'outblock',
  out: mo,
  block: b
}; }

CABlock = _ b:Block { return {
  syntax: 'block',
  block: b
}; }

CAExprs = pl:ParameterList { return {
  syntax: 'exprs',
  exprs: pl
}; }

CAExprsblock = _ pl:ParameterList _ b:Block { return {
  syntax: 'exprsblock',
  exprs: pl,
  block: b
}; }

CAVerb = v:VerbSentence { return {
  syntax: 'verb',
  verb: v
}; }

CARvalue = v:RValue { return {
  syntax: 'rvalue',
  rvalue: v
}; }

CANone = _ &EOLs { return { 
  syntax: 'none' 
}; }
 
 

NopStatement
 = NOP _ { return ';' }
 
SwapStatement
 = SWAP Sep a:LValue Sep b:LValue {
   return RV('var ^{t1}=^{v1}; var ^{t2}=^{v2}; ^{v2}=^{t1}; ^{v1}=^{t2};',{t1:tempvar(),t2:tempvar(),v1:a,v2:b});
 }


SetStatement
 = SET _ t:SetTerm { return t }
 / SET Sep EOLs INDENT EOLs t:SetBlock DEDENT { return t.join(''); } 
 / LOCAL _ t:LocalTerm { return t }
 / LOCAL Sep EOLs INDENT EOLs t:LocalBlock DEDENT { return t.join(''); } 


SetLine
 = v:SetTerm EOLs { return [v] }

SetBlock
 = v:(SetLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

SetTerm
 = l:RValues _ op:('-') _ e:Expression {
     fail('SAI Compiler: the "set val '+op+' expr" construct is unclear. Please use "set val to '+op+' expr" or "set val self '+op+' expr" as appropriate.');
   }
 / l:RValues _ o:Itselfop _ e:Expression {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(itselfops[o], {'1':l[i], '2':RV(e,{self:l[i]}) } )+';\n';
   }
   return code;
 }
 / l:LValues _ ((TO &[^a-zA-Z0-9_])?/&FROM/&CALL/&BANG/&CHAIN) _ e:Expression {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   if (l.length==1) return l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+=l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(unops[o],{'1':l[i]})+';\n';
   }
   return code;
 }
 / l:RValues _ o:Pipers {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   var a=tempvar();
   addLocal(a);
   for (var i in l) {
     code+=a+'='+l[i]+'; '+l[i]+'='+o[0]+a+o[1]+';\n';
   }
   return code;
 }

LocalLine
 = v:LocalTerm EOLs { return [v] }

LocalBlock
 = v:(LocalLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

LocalTerm
 = l:RValues _ o:Itselfop _ e:Expression {
   fail("SAI compiler: 'local' should only be used when declaring variables, not when modifying them.");
 }
 / l:LValues _ (TO?/&FROM/&CALL/&BANG/&CHAIN) _ e:Expression {
   for (var i in l) {
     //console.log("local scope check "+l[i]);
     if ('$.'==l[i].substring(0,2)) CheckScope(l[i].substring(2),"local-1");
     if (lp==l[i].substring(0,lp.length)) CheckScope(l[i],"local-2");
   }
   if (l.length==1) return 'let '+l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+='let '+l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   fail("SAI compiler: 'local' should only be used when declaring variables, not when modifying them.");
 }



LocalAdj
 = LOCAL Sep { return 'local '; }


UnOp // test 'self*'
 = '-' / NOTB / NOT  

Itselfop // test 'self*'
 = '+' / '-' 
 / '**' / '*' / '/' / '%' / '<<' / '>>' / '>>>' / RSH / LSH / URSH
 / ANDB / ORB / XORB
 / AND / OR / XOR / NAND / NOR
 / '?>' / '?<'
 / DEFAULT / '?' 



VerbStatement
 = v:Verbd { return v+';\n'; }
 / v:VerbSentence  { return v+";\n"; }
 / v:VerbChain { return '$AI.drain_op('+v+');\n'; }
 
LValues
 = v:LValue a:LValueSep* _ { return [v].concat(a) }
 
LValueSep
 = ',' _ v:LValue { return v }

LValue 
 = v:LStem
  {
    var j=v.length;
    if (!j) fail("SAI Compiler: Expected something to assign into");
    if (j==1) {
      var pattern=accessors.firststore[v[0][0]];
      if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
      return pattern[0] + v[0][1] + pattern[1];
    }
    j--;
    var code='';
    var patternbase=accessors.firstfetch;
    var i=0; while (i<j) {
      var pattern=patternbase[v[i][0]]; patternbase=accessors.nextfetch;
      if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
      code+=pattern[0] + v[i][1] + pattern[1];
      i++;
    }
    var pattern=accessors.laststore[v[j][0]];
    if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
    code= code+pattern[0]+v[j][1]+pattern[1];
    return code;
  }


RValues
 = v:RValue a:RValueSep* { return [v].concat(a) }
 
RValueSep
 = ',' _ v:RValue { return v }

SimpleValue
 = v:SimpleTerm
  { return ValueCompositor(v,false) }

RValue 
 = v:RStem
  { return ValueCompositor(v,false) }

RValueSafe
 = v:RStem
  { return ValueCompositor(v,true) }

VerbValue  
 = v:RStemVerb
  {
    var verb='',stem='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) fail("SAI Compiler: VV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      stem+=verb;
      verb=pattern[0] + v[i][1] + pattern[1];
//      console.log("VV"+i+": stem:"+stem+" verb:"+verb);
      i++;
    }
    return [stem,verb];
  }
 


LStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / LLocalStem / GlobalStem / ParenStem 

RStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / RLocalStem / GlobalStem / ParenStem 

RStemVerb
 = RStem 
 / TASK Sep v:TaskClause _ { return [['literal',v]] }
 / PROCESS Sep v:IteratorClause _ { return [['literal',v]] }
 / PROMISE Sep v:PromiseClause _ { return [['literal',v]] }


SuperStem
 = SUPER _ { return [['super','']]; }

PropertyStem 
 = x:Property y:(Attribute/Index/Call)*  { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RootedStem
 = x:Root y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

GlobalStem
 = x:Global y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

LLocalStem
 = x:LLocal y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RLocalStem
 = x:RLocal y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

ParameterStem
 = x:Parameter y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }

ItStem
 = x:(It) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }
 
ParenStem
 = x:(Parenthetic/LiteralElm) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }


It
 = IT Sep { return [['it','']] }
 / KEY Sep { return [['key','']]}
 / COUNTER Sep { return [['counter','']]}
 / TRIAL Sep { return [['trial','']]}
 / SUM Sep { return [['sum','']]}
 / SELF Sep { return [['self','']]}
 / ERROR Sep { return [['error','']]}

Attribute
 = DOT v:BaseIdentifier { return [[ 'attribute', v ]] }
 / '\'s' Sep v:BaseIdentifier { return [[ 'attribute', v ]] }
 
Call
 = LPAREN _ p:ParameterList? _ RPAREN _ { 
   return [[ 'function', p?p[1]:'' ]] 
}
 
Root
 = DOT !DOT v:BaseIdentifier { return [[ 'it', ''],[ 'attribute', v ]] }
 / DOT v:PositiveInteger { return [[ 'it', ''],[ 'index', v ]] }
 / DOT !DOT { return [[ 'it', '']] }

Index
 = '[' _ v:Expression _ ']' { return [[ 'index', v ]] }
 / '\\' v:SimpleValue { return [['index',v]] }
 / '.' v:PositiveInteger { return [[ 'index', v ]] }

Parenthetic
 = LPAREN _ v:Expression _ RPAREN { return [[ 'paren', v ]] }

LLocal
 = v:Identifier { 
   //console.log("LLocal "+v);
   if (InstanceVars[v]) {
     usedMemberVar=v;
     return [['this',''],[ 'attribute',v ]]; 
   }
   if (!options.globals[v]) addLocal(lp+v); 
   return [[ 'local',lp+v ]];
}

RLocal
 = v:Identifier { 
   //console.log("RLocal "+v);
   if (InstanceVars[v]) {
     usedMemberVar=v;
     return [['this',''],[ 'attribute',v ]]; 
   }
   if (!options.globals[v]) {
     v=checkLocal(lp+v,v);
   } else {
     v=lp+v;
   }
   return [[ 'local',v ]];
}

Parameter
 = '$$' { return [['arguments','']]}
 / '$' v:BaseIdentifier { return [[ 'parameters','' ],['attribute',v]] }
 / '$' v:Number { return [[ 'parameters','' ],['index',v]] }
 / '$' { return [[ 'parameters','' ]]}

LiteralElm
 = v:Literal { return [['literal',v]]}

Global
 = '~' v:BaseIdentifier { return [['global',v]] }

Property
 = '@' v:BaseIdentifier { return [['this',''],[ 'attribute',v ]] }
 / '@@' v:BaseIdentifier { return [['currentthis',''],[ 'attribute',v ]] }
 / '@@' { return [['currentthis','']] }
 / '@' { return [['this','']] }

SimpleTerm
 = It/RLocal/Parameter/Property/Root
 / v:Number { return [['literal',v]] }
 / v:StringLiteral { return [['literal',v]] }

// DEFINITIONS

 
 


Define
  = GIVEN _ k:Identifier _ v:Definition EOLs { 
     addToList('freeze',k);
     addInstanceVar(k);
     return 'prototype["'+k+'"]='+v[1]+';\n';
   } 
  / GIVEN _ v:FieldDefinition EOLs { 
//    addToList('lock',i);
    addInstanceVars(v);
    var code='';
    code+='var t='+v[1]+';\nfor (var i in t) { prototype.__tobelocked.push(i); prototype[i]=t[i]; };\n'; 
    return code;
  }
  / INSTANCE _ v:FieldDefinition EOLs {
    var ivar=GlobVar();
    addInstanceVars(v);
    var proof='var '+ivar+'=function(){ var $=this; return '+v[1]+'; }\nfor (var i in '+ivar+'()) { prototype[i]=undefined; };\n'; 
    var sup=GlobVar();
    var setup= 'var '+sup+'=prototype.Constructor || function(){};\nprototype.Constructor=function() {\n'+sup+'.call(this);\n  var t='+ivar+'();\n  for (var i in t) if (t[i] !== undefined) this[i]=t[i];\n};\n'; 
    return proof+setup;
  }



SemVer
 = maj:PositiveInteger DOT min:PositiveInteger DOT patch:PositiveInteger {
   return "'"+maj+"."+min+"."+patch+"'";
 }


ItemList
 = COLON _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['array',v.join(','),v] }
 / COLON? _ v:Items SEMI? { return ['array',v.join(','),v] }


ParameterList
 = COLON _ EOLs INDENT EOLs v:FieldBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields', '{'+w.join(',')+'}',v] }
 / COLON _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['array',v.join(','),v] }
 / v:Items SEMI? { return ['array',v.join(','),v] }
 / v:Fields SEMI? { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields','{'+w.join(',')+'}',v] }
 / SEMI { return null }

Definition
 = _ v:Item { return ['literal',v] }

 
NestedDefinition
 = _ EMPTY _ { return ['literal','[]']; }
 / _ BLANK _ { return ['literal','{}']; }
 / _ LIST _ v:Terms _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ LIST _ EOLs INDENT EOLs v:TermBlock DEDENT { return ['literal','['+v.join(',')+']'] }
 / _ TRAITS _ v:Traits _ SEMI? _ { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ TRAITS _ EOLs INDENT EOLs v:TraitBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/ARRAY) _ v:Items _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ (COLON/ARRAY) _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['literal','['+v.join(',')+']'] }



FieldDefinition
 = _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }


SimpleList
 = _ (COLON/LIST) _ v:Terms _ SEMI? _ { return v }
 / _ (COLON/LIST) _ EOLs INDENT EOLs v:TermBlock DEDENT { return v }


Term
 = EQUALS _ v:Expression { return v }
 / v:NestedDefinition { return v[1] }
 / MultiString
 / Number
 / TRUE
 / FALSE
 / UNDEFINED
 / NULL
 / StringLiteral
 / BareString
  
BareString
 = v:[^\n\},);|]+ &('|' / ',' / ')' / ';' / EOLs) { return quoted(v.join('').trim()) } 


TermSep
 = v:Term _ COMMA _  { return v }
 
Terms
 = v:(TermSep)* t:(Term) { return v.concat(t) }
  
TermLine
 = !DEDENT v:Terms EOLs { return v }

TermBlock
 = v:(TermLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Item
 = Expression

ItemSep
 = v:Expression _ COMMA _  { return v }
 
Items
 = v:(ItemSep)* t:(Item) { return v.concat(t) }
  
ItemLine
 = v:Items EOLs { return v }

ItemBlock
 = v:(ItemLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



 

 

Trait
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:Term _ { return [[k,v]] }
 
TraitSep
 = v:Trait _ COMMA _ { return v }

Traits
 = v:(TraitSep)* t:(Trait) { 
   var r=[]; 
   for (var i in v) r=r.concat(v[i]); 
   r=r.concat(t);  
   return r; 
}
 
TraitLine
 = v:Traits EOLs { return v }
 
TraitBlock
 = v:(TraitLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Field
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:(Expression/ENUM) _ { return [[k,v]] }
 
FieldSep
 = v:Field _ COMMA _ { return v }

Fields
 = v:(FieldSep)* t:(Field) { var r=[]; for (var i in v) r=r.concat(v[i]); r=r.concat(t); return r; }
 
FieldLine
 = v:Fields EOLs { return v }
 
FieldBlock
 = v:(FieldLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 
 
Output
 = AS _ v:ParameterCandidate _ { return v[0][1] }

IterateOutput
 = o:MultiOutput {
   var v=[];
   for (var i in o) v.push(o[i][0][1]);
   return v;
 }
 
MultiOutput
 = (AS/GIVEN) _ k:(k:ParameterCandidate _ COMMA _ {return k})* _ v:RLocal { k.push(v); return k; }
 
ParameterCandidate
= v:Identifier {
   
   CheckScope(v,"parameter/as/given");
   if (!options.globals[v]) addLocal(lp+v); 
   return [[ 'local',lp+v ]];
}



Expression
 = v:Logical _ c:Pipers? {
   if (c) {  
     v=c[0]+v+c[1];
   }
   return v;
 } 


LogicalItem
 = Logical

LogicalItemSep
 = v:Logical _ COMMA _  { return v }
 
LogicalList
 = v:(LogicalItemSep)* t:(LogicalItem) _ ';'? _ { return v.concat(t) }


Logical
 = l:Comparison _ result:(
     o:LogicalOp _ r:Logical { return '('+l+o+r+')' }
   / XOR _ r:Logical  { return '($AI.xor_op('+l+','+r+'))' } // test 'xor' 
   / NAND _ r:Logical { return '(!('+l+' && '+r+'))' } // test 'nand'
   / NOR _ r:Logical { return '(!('+l+' || '+r+'))' } // test 'nor'
   / '??' _ a:Logical _ '::' _ b:Logical { 
     return RV('((^{l})?(^{a}):(^{b}))',{l:l,a:a,b:b}); 
   } 
   / _ { return l }
  ) { return result; }

LogicalOp
 = AND Sep { return '&&' } // test 'and'
 / OR Sep { return '||' } // test 'or'
 
Comparison
 = l:Addition _ result:(
       o:MathOp _ r:Comparison { return o+'('+l+','+r+')' }
     / o:ComparisonOp _ r:Comparison { return '('+l+o+r+')' }
     / _ { return l }
  ) { return result; }

 
ComparisonOp
  = '>=' { return '>=' } // test '>='
  / '>' !'>' { return '>' } // test '>'
  / '=' { return '==' } // test '='
  / ISNT Sep { return '!==' } // test 'isnt'
  / IS Sep { return '===' } // test 'is *'
  / '<=' { return '<=' } // test '<='
  / '<>' { return '!=' } // test '!='
  / '<' !'<' { return '<' } // test '<'

MathOp
 = '?>' { return '$AI.max_op' } // test '?>'
 / '?<' { return '$AI.min_op' } // test '?<'
 / '<=>' { return '$AI.compare_op' } // test '<=>'

   
Addition
 = l:Multiplication _ result:(
     o:AdditionOp _ r:Addition { return '('+l+o+r+')' }
   / _ { return l }
   ) { return result; }

AdditionOp
 = '+' // test '+'
 / '-' // test '-'
 / ORB Sep {return '|' } // test 'binary or'
 / ANDB Sep {return '&'} // test 'binary and'
 / XORB Sep { return '^'}  // test 'binary xor'


Multiplication 
 = l:Value _ result:(
     (DEFAULT/('?'!'?')) _ v:Multiplication  {  // test 'default*'
         SafetyFetch=true; 
         return RV('((undefined!==($_b=^{l}))?$_b:^{v})',{l:l,v:v}); 
       } 
     / INITIALIZED _ v:Multiplication  { // test 'initialized*'
         SafetyFetch=true; 
         return RV('((undefined!==($_b=^{l}))?$_b:(^{l}=^{v}))',{l:l,v:v}); 
       } 
     / o:MultiplicationOp _ r:Multiplication { return '('+l+o+r+')' }
     / '**' _ r:Multiplication { // test '**'
       return 'Math.pow('+l+','+r+')' 
     } 
//     / VIA _ op:Value _ x:ParameterList? {
//       var p=undefined;
//       if (x) {
//         p=x[1];
//       }
//       return '('+op+').call($,('+l+'),'+p+')';
//     }
     / ISOF Sep r:Multiplication { 
       return '('+l+').isof['+r+']'; 
     }
     /  '...' c:VerbChainBlock {
       c[0].base=l;
       return AssembleVerb(c);
     }
     / _ { return l }
  ) { return result; }
  

MultiplicationOp
 = '*' // test '*'
 / '/' // test '/'
 / '%' // test '%'
 / '>>>' // test 'rshz'
 / '>>' // test 'rsh'
 / '<<' // test 'lsh'
 / RSH { return '>>' } 
 / LSH { return '<<' } 
 / URSH { return '>>>' } 


Value
 = '-' _ v:Value _ { return '(0-('+v+'))' } // test 'unary -'
 / NOTB Sep v:Value _ { return '(~('+v+'))' } // test 'unary binary not' 
 / NOT Sep v:Value _ { return '(!('+v+'))' } // test 'unary not'
 / TYPEOF Sep v:Value _ { return 'typeof ('+v+')'; }
 / ISNAN Sep v:Value _ { return 'isNaN('+v+')'; }
 / NUMBER Sep v:Value { return '($AI.number_op('+v+'))'; } // test 'number *'
 / EXISTS Sep v:Value _ { return '(undefined!=='+v+')' } // test 'exists'
 / COPY Sep v:Value _ { return '$AI.clone_op('+v+')'; } // test 'copy'
 / TASK Sep v:TaskClause _ { return v }
 / PROCESS Sep v:IteratorClause _ { return v }
 / PROMISE Sep v:PromiseClause _ { return v }
 / (BANG Sep? / FROM Sep / CALL Sep) v:VerbSentence _ { return v }
 / BIND Sep v:Value _ { return  'function(){return ('+v+').apply($,arguments);}'; }
 / Verbd
 / '?' v:RValueSafe _ { return v }
 / v:RValue _ { return v }
 / VerbChain 
 / v:NestedDefinition { return v[1] }
 / o:NewObject _ { return o }
 / '<-' _ v:Expression { return v; }
 / LPAREN _ v:Expression _ o:Output? RPAREN _ { 
     if (o) {
       addLocal(o);
       return RV('(^{out}='+v+')',{out:o}); 
     } else {
       return '('+v+')'; 
     }
    }
 / x:Regex _ { return x }
 / op:(AND/OR/NAND/NOR) _ v:ItemList { 
     var code='';
     if (v[2].length == 1) {
       fail("SAI Compiler: the unary (left-side) variation of the "+op.toUpperCase()+" operator needs to be followed by a list with two or more values.")
       code='false';
     } else {
       var oper='||';
       if (op==='and' || op==='nand') oper='&&';
       code='('+v[2].join(')'+oper+'(')+')';
       if (op==='nand' || op==='nor') code='!('+code+')';
       code='('+code+')';
     }
     return code;
 }

Regex
 = '/' x:(RegexEscape/RegexChar)+ '/' m:[igm]* _ {
   var re= '/'+x.join('')+'/'+m.join('');
   return re;
 }

RegexEscape 
 = '\\/' 
 
RegexChar
 = [^\n\r/]

Keyword
 = v:Identifier ![.(\[|] { return v } 
 / StringLiteral 

 
Identifier
 = v:BaseIdentifier !{var hop=ResWords.hasOwnProperty(v); return hop;} { return v; }  

BaseIdentifier
 = v1:[a-zA-Z_] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }


Literal
 = Number 
 / StringLiteral
 / TRUE 
 / FALSE
 / UNDEFINED 
 / NULL
 / NaN { return 'NaN' }
 / INFINITY { return 'Infinity' }
 
IntoClause
 = IT Sep { return 'it' }
 / r:Expression 


////////////////////////////////////////////////////////// VERBS




VerbSentence
 = v:VerbClause {
   return AssembleVerb(v);
 }

Verbd
= v:Identifier ('\'d' / '!') _ b:Value _ o:ParameterList? {
  return AssembleVerb([{ base:b, verb:'.'+v, param:(o?o[1]:'')}]);
}

VerbClause
= v:(VerbValue) _ o:ParameterList?  { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$'+(o?(','+o[1]):'') }]; 
     return [{ base:v[0], verb:v[1], param:(o?o[1]:'') }]
  }
  
 / v:(VerbValue) _ { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$' }]; 
     return [{ base:v[0], verb:v[1], param:'' }]
   }


VerbChain
 = CHAIN _ v:Expression _ c:VerbChainBlock {
   c[0].base=v;
   return AssembleVerb(c);
 }

VerbChainBlock
 = EOLs INDENT EOLs l:(VerbChainLine)+ DEDENT { 
     return l ;
   }
 
VerbChainLine
 = c:Pipers _ EOLs {
     return {left:c[0], right: c[1]}
  }
 / i:Identifier _ o:ParameterList? _ EOLs {
     return {verb:'.'+i, param:(o?o[1]:''), test:true}; 
  }

NewObject
 = CREATE _ v:Value _ o:ParameterList?  { 
   return '$AI.create_op('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / SINGLETON _ v:Value _ o:ParameterList?  { 
   return '$AI.singleton_op('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / NEW _ v:Value _ o:ParameterList? {
   return 'new '+v+'('+(o?o[1]:'')+')'; 
 }

VerbTerminal
 = &EOLs / &CBRACE / &')' 


/////////////////////////////////////////////

Number
 = Octal
 / Hexadecimal
 / Binary
 / v:NumericLiteral 'o' { return v*(Math.PI/180) } 
 / NumericLiteral

NumericLiteral
 = Scientific
 / Real
 / Integer
 / NaN

Binary
 = '0b' v:[0-1]+ {
   var r=0;
   for (var i=0; i<v.length; r=r*2+Number(v[i++]));
   return r.toString();
 }

Octal
 = '0o' v:[0-7]+ {
   var r=0;
   for (var i=0; i<v.length; r=r*8+Number(v[i++]));
   return r.toString();
 }

Hexadecimal
 = '0x' v:[0-9a-fA-F]+ { return '0x'+v.join('');}


Scientific
 = r:(Real/Integer) 'e' x:Integer { return r+'e'+x }
 
Real
 = w:Integer DOT f:Fraction { return Number(w+'.'+f) }

Integer 
 = PositiveInteger
 / '-' v:PositiveInteger { return -v }

PositiveInteger
 = v:[0-9]+ { return parseInt(v.join('')) } 

Fraction
 = v:[0-9]+ { return v.join('') } 

SimpleStringLiteral
 = '&#39' v:(EscapedChar/StringTickChar)* '&#39' { return assembleLiteral(v) }
 / '&#34' v:(EscapedChar/StringQuoteChar)* '&#34' { return assembleLiteral(v) }
 
StringLiteral
 = MultiString
 // '\x60' v:Bareline { return v }
 / '\x27' v:(EscapedChar/StringTemplate/StringTickChar)* '\x27' { return assembleLiteral(v) }
 / '\x22' v:(EscapedChar/StringTemplate/StringQuoteChar)* '\x22' { return assembleLiteral(v) }
 
StringTickChar
 = v:[^\'\n] { return [true,v] }

StringQuoteChar
 = v:[^\"\n] { return [true,v] }

MultiString
 = "'''" _ EOLs INDENT EOLs v:(v:Bareline EOL { return v} )* DEDENT &EOLs { return v.join("+'\\n'+"); } 


Bareline
 = !DEDENT v:(EscapedChar/StringTemplate/BarelineStringChar)* &EOLs { return assembleLiteral(v) }

BarelineStringChar
 = '^' { return [true, "\\"+"x5e"] }
 / v:[^\n] { return [true,v] }  
  
EscapedChar
 = '\x5c\x27'  { return [ true, "\x27" ] }
 / '\x5c' c:. { return [ true, '\x5c'+c ] }
 / '\x5e' { return [ true, '\\x5e' ]}

StringTemplate
 = '${' _ v:Expression  '}' { return [false,v] }


__
 = Whitespace+

Sep
 = Whitespace+
 / &[^a-zA-Z0-9_]
 
_
 = Whitespace*

Whitespace
 = EOL '...'
 / [\ ]
 
 
 
OptionalEOLs
 = EOL*
 
EOLs
 = ln:EOL+ { return ln[0]; }

EOL
 = [\ ]* '//' [^\r\n]* ln:CR { return ln; }
 / ln:CR { return ln; } 
 

CR
 = [\n\r] ln:LineNo? { return ln; }

LineNo
 = '@' d:[0-9]+ ':' { var ln=d.join(''); return ln; }

OBRACE
 = '{'
 
CBRACE
 = '}'


 
__SOURCE = '__source'
__OFFSET = '__offset'
__COLUMN = '__column'
__LINE = '__line'

AND = 'and'
ANDB = 'andb'
ARRAY = 'array'
AS = 'as'
BIND = 'bind'
BLANK = 'blank'
CALL = 'call'
CHAIN = 'chain'
COPY = 'copy'
CONTRACT = 'contract'
COUNTER = 'counter'
CREATE = 'create'
DEFAULT = 'default'
EMPTY = 'empty'
ENUM = 'enum'
ERROR = 'error'
EXISTS = 'exists'
EXPECTS = 'expects'
FIELDS = 'fields'
FROM = 'from'
GET = 'get'
GIVEN = 'given'
INFINITY = 'Infinity'
INSTANCE = 'instance'
INHERIT = 'inherit'
INITIALIZED = 'initialized'
ISNT = 'isnt'
ISNAN = 'isNaN'
IS = 'is'
ISOF = 'isof'
ITERATOR = 'Iterator'
IT = 'it'
KEY = 'key'
LIST = 'list'
LOCAL = 'local'
LSH = 'lsh'
MAIN = 'main'
NaN = 'NaN'
NAND = 'nand'
NEW = 'new'
NOP = 'nop'
NOR = 'nor'
NOT = 'not'
NOTB = 'notb'
NUMBER = 'number'
NULL = 'null'
OBJECT = 'object'
OR = 'or'
ORB = 'orb'
TRUE = 'true'
FALSE = 'false'
PROMISE = 'promise'
PROCESS = 'process'
REFERENCE = 'reference'
RSH = 'rsh'
SELF = 'self'
SET = 'set'
SINGLETON = 'singleton'
SUM = 'sum'
SWAP = 'swap'
SUPER = 'super'
TASK = 'task'
TRAITS = 'traits'
TRIAL = 'trial'
TO = 'to'
TYPEOF = 'typeof'
UNBOUND = 'unbound'
UNDEFINED = 'undefined'
URSH = 'ursh'
USING = 'using'
//VIA = 'via'
XOR  = 'xor'
XORB  = 'xorb'

BANG = '!'
DOT = '.'
HASH = '#'
SEMI = ';'
COMMA = ','
COLON  = ':' !':' { return ':' }
INDENT = '%%INDENT%%'
DEDENT = '%%DEDENT%%'
EQUALS = '='
LPAREN = '('
RPAREN = ')'

 