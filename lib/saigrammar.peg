
{
  var _bindings={};
  var _locals={};
  var reCache={};
  var Entity=false;
  var FunctionChain=false;
  var SafetyFetch=false;
  var References={};
  var InstanceVars={};
  var UnresolvedLocals={};
  var readOnlyReference=true;
  var usedMemberVar=false;
  var DynamicTaskClauseFormatter=undefined;

  var failures=[];
  function fail(msg,loc) { failures.push(msg+" at:"+(loc?loc:location().start.offset)); }

  var filetools={};
  function AddTool(text) {
    filetools[text]=true;
  }
  function GetTools() {
    var tools='';
    for (var tool in filetools) {
      tools=tools+tool;
    }
    return tools;
  }

  var ResWords={},ResWordsA=(
    "andb,and,array,as,asc,audit,"+
    "bind,blank,by,"+
    "chain,create,collect,concat,copy,count,"+
    "default,delete,desc,"+
    "empty,enlist,entrait,enum,exists,expects,"+
    "false,fields,first,from,"+
    "get,"+
    "has,highest,"+
    "into,is,isnt,isNaN,iterate,"+
    "keys,"+
    "last,limit,list,lowest,"+
    "me,my,"+
    "NaN,nand,new,nor,notb,not,number,null,"+
    "observe,orb,or,"+
    "promise,process,"+
    "self,set,singleton,swap,"+
    "task,trial,throw,thru,to,traits,true,typeof,"+
    "undefined,update,using,"+
    "values,via,"+
    "xorb,xor").split(/,/);
  for (var i=0; i<ResWordsA.length; i++) ResWords[ResWordsA[i]]=1;
  
  var _db=false;
  var lp='_'; // prefix for bareword variables
  var LeakedMagic=/\^\{([a-z0-9]+)\}/;
  
  if (undefined===options.constructs) options.constructs={};
  
  function addInstanceVar(v) {
    if (!InstanceVars[v]) {
      //console.log("Added instance var "+v)
      CheckScope(v,"instance");
      InstanceVars[v]=true;
    }
  }

  function addInstanceVars(v) {
    var vt='return '+v[1]+';';
    try {
      var inst=new Function(vt)();
      for (var i in inst) {
        addInstanceVar(i);
      }
    } catch (e) {
      fail(e.message+"\n\nSAI compiler: Instance/Given variables can only be initialized with simple literal values. For more complex initialization, use Instantiate (but still declare them with instance).\n\nYour vars: "+v[1]);
    }
  }
  
  function checkUsedMemberVar(v) {
    if (usedMemberVar) {
      fail("SAI compiler: object task "+v+" is declared as unbound but uses a bareword access to "+usedMemberVar);
    }
    usedMemberVar=false;
  }

  function CheckScope(v,context) {
    //console.log("check scope "+context+": "+v);
    if (References[v]) {
      var message="SAI compiler: variable "+v+" is a Reference variable and cannot be used as a "+context+".";
      //console.log(message);
      fail(message);
    }
    if (InstanceVars[v]) {
      var message="SAI compiler: variable "+v+" is an Instance variable and cannot be used as a "+context+".";
      //console.log(message);
      fail(message);
    }
  }
  
  function addLocal(v,a) { 
    if (_db) console.log("request local "+v+" - "+a);
    if (References[v]) return;
    if (_bindings[v]) return;
    _locals._hasLocals=true;
    if (!_locals[v]) {
      _locals[v]=a?(v+a):v;
    } else if (a) {
      _locals[v]=v+a;
    }
    if (_db) console.log("  added local "+v+" - "+_locals[v]);
  }
  
  function checkLocal(v,name) {
    if (References[v]) return v;
    if (_bindings[v]) return v;
    if (!_locals[v]) {
      UnresolvedLocals[v]=name;
      return '^[U,b,?,'+v+','+name+','+location().start.offset+']';
    }
    return v;
  }
  
  function Linker(code,final) {
    var p=/\^\[U,(.),([^,]+),([^,]+),([^,]+),([^\]]+)\]/g;
    return code.replace(p,function(x,bound,task,v,name,loc) {
      if (References[v]) return v;
      if (_bindings[v]) return v;
      if (_locals[v]) return v;
      if (InstanceVars[name]) {
        usedMemberVar=name;
        if (bound=='u') {
          checkUsedMemberVar(task+"(u)");
        }
        return '$.'+name;
      }
      if (final) {
        //console.log(JSON.stringify(InstanceVars));
        //console.log('SAI Compiler: local variable "'+name+'" used without initialization at:'+loc);
        fail('SAI Compiler: local variable "'+name+'" used without initialization',loc);
      } 
      return x; // unchanged
    });
  }
  
  function removeLocal(v) {
    if (_db) console.log("removed local "+v);
    delete _locals[v];
  }
  
  function getLocals() { 
    if (!_locals._hasLocals) return ''; 
    var k=[]; 
    for (var i in _locals) if (i!=='_hasLocals') {
      if (i!=_locals[i]) {
        k.push(_locals[i]);
      } else {
        k.unshift(_locals[i]);
      }
    } 
    var finalk=[];
    var klookup={};
    if (_db) {
      console.log("references");
      console.log(References);
      console.log("locals");
      console.log(_locals);
    }
    for (var i in k) {
      //console.log(k[i]);
      if (!References[k[i]]) finalk.push(k[i]);
      klookup[k[i]]=k;
    }
//    for (var i in UnresolvedLocals) {
//      if (!klookup[i] && !References[i]) {
//        error("SAI compiler: local variable used before initialization (beware forward declarations): "+UnresolvedLocals[i]);
//      }
//    }
    //console.log(finalk);
    var r='var '+finalk.join(',')+';\n'; 
    _locals={};
    UnresolvedLocals={};
    return r; 
  }

  function rep(list,val) {
    var j;
    for (var i in list) {
      if (j==val[list[i]]) list[i]=j;
    }
  }
 
  function RV(code,varnames) {
    if (!varnames) varnames={};
    if (!code) fail("SAI compiler: RV has undefined code; likely a syntax error; perhaps you need to use 'self'");
    if (!code.replace) {
      code=code.toString();
    }
    var repl=function(key) {
      var val=varnames[key];
      if (undefined===val || null===val || false===val) {
        val=tempvar();
        addLocal(val);
      }
      var re=reCache[key]; if (!re) re=reCache[i]=new RegExp('\\^\\{'+key+'\\}','g');
      //console.log(" -- replace "+key+" with "+val)
      code=code.replace(re,val);
    };
    //console.log("###############################")
    //console.log(code);
    //console.log("........................");
    //console.log(varnames);
    var completed={};
    var precedence=['block','this','key','list','counter'];
    for (var j in precedence) {
      var i=precedence[j];
      if (varnames.hasOwnProperty(i)) {
        //console.log("intercept "+i+" with "+varnames[i]);
        repl(i);
        completed[i]=true;
      }
    }
    for (var i in varnames) {
      if (undefined===completed[i]) {
        repl(i);
      }
    }
    //console.log(code)
    //console.log("---------------------------------")
    return code;
  }
  
  var varnum=0;
  function tempvar() {
    var v="$"+(varnum++);
    return v;
  }
  
  function quoted(v) {
    return "'"+v.replace(/\'/g,"\\\'")+"'";
  }
  
  var accessors = {
    firstfetch: { // [0]+key+[1]
      this: [ '$' , '' ],
      currentthis: [ 'this' , ''],
      local: [ '' , '' ], 
      arguments: [ 'arguments','' ],
      parameters: [ 'p','' ],
      it: [ '^{this}','' ],
      key: [ '^{key}','' ],
      counter: [ '^{counter}','' ],
      trial: [ '^{trial}','' ],
      sum: [ '^{sum}','' ],
      error: [ '^{error}','' ],
      self: [ '^{self}','' ],
      super: [ '^{super}','' ],
      paren: [ '', '' ],
      bound: [ '' , '' ],
      global: [ '' , '' ],
      function: [ '' , '' ],
      literal: ['','']
    },
    nextfetch: { // +[0]+key+[1]
      function: [ '(' , ')' ],
      attribute: [ '.' , '' ], 
      index: [ '[' , ']' ],
    },
    firststore: { //[0]+key+[1]
      function: [ '' , '' ],
      paren: [ '', '' ],
      local: [ '' , ''  ],
      error: [ '^{error}','' ],
      attribute: [ '^{this}.' ,  '' ],
      self: [ '^{self}','' ],
      sum: [ '^{sum}' , '' ],
      property: [ '$["' , '"]' ], 
      parameter: [ 'p["','"]' ],
    },
    laststore: { // +[0]+key+[1]
      attribute: [ '.' , '' ], 
      index: [ '[' , ']'  ],
    }
  };

  function safetyFetch(root,leaf) {
    SafetyFetch=true;
    return '(undefined===($_b=('+root+'))?undefined:($_b'+leaf+'))';
  }

  function ValueCompositor(v,safe) {
    //console.log("Value Compositor...");
    //console.log(v);
    var code='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    if (v[0][0]=='local') {
      code+=VarUse(v[0][1]);
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) error("SAI Compiler: RV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      var leaf=pattern[0] + v[i][1] + pattern[1];
      if (i>0 && safe) {
        code=safetyFetch(code,leaf);
      } else {
        code=code+leaf;
      }
      i++;
    }
    return code;
  }

  var itselfops = {
    '+': '^{1} += ^{2}' , // test 'self +'
    '-': '^{1} -= ^{2}' , // test 'self -'
    
    '*': '^{1} *= ^{2}' , // test 'self *'
    '/': '^{1} /= ^{2}' , // test 'self /'
    '%': '^{1} %= ^{2}' , // test 'self %'
    '<<': '^{1} <<= ^{2}' , // 
    '>>': '^{1} >>= ^{2}' , // 
    '>>>': '^{1} >>>= ^{2}' , // 
    '**': '^{1} = Math.pow(^{1},^{2})' , // test 'self **'

    xorb: '^{1} ^= ^{2}' , // test 'self xorb'
    andb: '^{1} &= ^{2}' , // test 'self andb'
    orb: '^{1} |= ^{2}' , // test 'self orb'

    and: '^{1} = ^{1} && ^{2}', // test 'self and'
    or: '^{1} = ^{1} || ^{2}', // test 'self or'
    xor: '^{1} = $AI.xor_op(^{1},^{2})',  // test 'self xor'
    nand: '^{1} = (!((^{1})&&(^{2})))', // test 'self nand'
    nor: '^{1} = (!((^{1})||(^{2})))', // test 'self nor'

    '?>': '^{1} = Math.max(^{1},^{2})', // test 'self ?>'
    '?<': '^{1} = Math.min(^{1},^{2})', // test 'self ?<'
    
    update: '^{1} = $AI.update_op(^{1},^{2})', // test 'self update'
    delete: '$AI.delete_op(^{1},^{2})', // test 'self delete*'
    default: 'if (undefined===^{1}) ^{1}=^{2}', // test 'self default*'
    '?': 'if (undefined===^{1}) ^{1}=^{2}', // test 'self default*'
    concat: '^{1} = $AI.concat_op(^{1},^{2}, true)', // test 'self concat inplace*'
  };

  var unops={
    '-': '^{1}=-(^{1})' , // test 'self negate'
    'not': '^{1}=!(^{1})', // test 'self not'
    'notb': '^{1}=~(^{1})', // test 'self notb'
    'inc': '^{1}=(^{1} || 0)+1;', // test 'self inc'
    'dec': '^{1}--', // test 'self dec'
    'delete': 'delete ^{1}', // test 'self delete'
    'collect': '^{1} = $AI.collect_op(^{1})' // test 'self collect*'
  };  

  
  function assembleLiteral(v) {
    var build='';
    var result=[];
    for (var i in v) {
      var c=v[i];
      if (c[0]) {
        build+=c[1];
      } else {
        if (build.length) result.push(quoted(build));
        build='';
        if (!result.length) result.push(quoted(''));
        result.push(c[1]);
      }
    }
    if (build.length) result.push(quoted(build));
    if (!result.length) result=[quoted('')];
    return result.join('+');
  }

  var Lists={};
  function addToList(list,e) {
    var list=Lists[list] || (Lists[list]=[]);
    list.push(e);
  }
  function getList(list) {
    var list=Lists[list] || (Lists[list]=[]);
    if (list.length) {
      return '["'+list.join('","')+'"]';
    } 
    return '[]';
  }
  function clearLists() {
    Lists={};
  }
    
  function GetExpectsTester(x,name) {
    var l =[];
    for (var i in x) {
      var t=x[i][1] || 'true';
      var p='"'+x[i][0][1]+'":'+x[i][1];
      l.push(p);
    }
    return '$AI.expectsThrow(p,{'+l.join(',')+'},'+quoted(name)+');\n';
  }
  
  
  // expects
  // as
  // kind
  // body
  // preface
  // appendix
  function TaskClauseFormatter(o) {
    var params=[];
    if (!o.nodefaultparam) {
      params.push('p');
    }
    var expects='',locals=[];//$unused=this';
    if (o.expects && o.as) fail("SAI compile: cannot have both EXPECTS and AS in a function declaration");
    if (o.expects && o.expects.length) {
      expects=GetExpectsTester(o.expects,'in-line');
    } else if (o.as) {
      for (var i in o.as) {
        if (i==0) {
          locals.push(o.as[i][0][1]+'='+params[0]);
        } else {
          params.push(o.as[i][0][1]);
        }
      }
    }
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    var finallocals=[];
    for (var i in locals) if (!References[locals[i]]) finallocals.push(locals[i]);
    locals=locals.length?('var '+finallocals.join(',')+';'):'';
    var code = o.kind+'('+params.join(',')+'){'+o.preface+locals+expects+'{'+o.block+'}'+o.postface+'}';
    if (o.execute) code+='()';
    return code;
  }

  
  // prefix (v0)
  // name (v1)
  // as (v2)
  // expects (v3)
  // kind 
  // body (k)
  function TaskFormatter(o) {
    
    var fn=(o.prefix?o.prefix+'_':'')+o.name;
    var params='p';
    var paramspec=o.as||[];
    
    for (var i in paramspec) {
      var pname=paramspec[i][0][1];
      if (i==0) {
        addLocal(pname,'=p');
      } else {
        removeLocal(pname);
        params+=','+pname;
      }
    }

    if (SafetyFetch) { addLocal('$_b'); SafetyFetch=false; }
    if (FunctionChain) { addLocal('$_c'); addLocal('$_d'); FunctionChain=false; }
    if (!o.nothis) {
      if (o.unbound || o.property) {
        addLocal('$','=this');
      } else {
        addLocal('$','=this['+fn+']?this:$bindfail('+fn+')');
      }
    }
    var head='', tail='';
    var sup=GlobVar();
    if (o.prefix!='get' && o.prefix!='set') {
      addToList('lock',fn.substring(1,fn.length-1));
      head='var '+sup+'=prototype['+fn+'] || function(){};\n';
      head+='prototype['+fn+']=';
      tail=';\n';
    }
  
    if (o.unbound) {
      o.body=o.body.replace(/\^\[U,b,\?/g, "^[U,u,"+o.name);
    }
    o.body=Linker(o.body,false);
    if (o.unbound) {
      checkUsedMemberVar(fn+'(t)');
    } usedMemberVar=false;
    if (!o.preface) o.preface='';
    if (!o.postface) o.postface='';
    var fun=o.kind+'('+params+') {\n'+o.preface+getLocals();
    if (o.expects) {
      fun+=GetExpectsTester(o.expects,fn);
    }
    fun+='{'+o.body+'}'+o.postface; // function body
    fun+='}';
  
    if (o.name) {
      if (fun.indexOf('^{this}')>-1) fail("SAI Compiler: Cannot use unrooted . accessor without a context\n\n"+fun);
    }
    var r=RV(head+fun+tail,{this:false,super:sup});

    return r;

  }

  function VerbCat(v) {
//       console.log("VerbCat");
//       console.log(v);
     if (v.left) {
       return v.left+v.base+v.right;
//     } else if (v.call) {
//       if (test) {
//         return RV('((undefined===($_c=^{verb}(($_d=^{base}),^{param})))?$_d:$_c)',v);
//       } else {
//         return v.verb+'('+v.base+(v.param?(','+v.param):'')+')';
//       }
     } else {
       if (v.test) {
         return RV('((undefined===($_c=(($_d=^{base})^{verb}(^{param}))))?$_d:$_c)',v);
       } else {
         return v.base+v.verb+'('+v.param+')';
       }
     }
  }
 
  function AssembleVerb(v) {
     FunctionChain=true;
     if (v.length==1) {
//       console.log("AV 1");
//       console.log(v[0]);
       return VerbCat(v[0]);
     }
     var base=v[0].base;
     for (var i in v) {
       v[i].base=base;
       v[i].test=true;
       base=VerbCat(v[i]);
     }
     return base;
  }
  
  function EnumCheck(v) {
    var start=1;
    for (var i in v) {
      if (v[i][1]==='enum') {
        v[i][1]=start++;
      } else {
        var n=parseInt(v[i][1],10);
        if (!isNaN(n)) {
          start=n+1;
        }
      }
    }
    return v;
  }
  
  function GlobVar() {
    return '$'+(options.persist.globalcount++)+'g';
  }
  function VarUse(v) {
    return '';
    //return [].concat(v).map(function(v) { return ' /*:VAR:'+v+':*/ '});
  }
  function FixVars(code) {
  }

  function MagicCheck(code) {
    var lm=LeakedMagic.exec(code);
    if (lm) fail("SAI Compiler: Pronoun '"+lm[1]+"' used in the wrong place (but I can't tell you where yet, please search for your use of this variable and make sure it is contained within a construct that uses it.)");
  }
}


startFile
  = OptionalEOLs r:Reference? o:Object+ {
    var code='';
    if (r) code+=r;
    code+=o.join('\n')
    MagicCheck(code);
    //console.log(code);
    code=Linker(code,true);
    if (failures.length) options.failures=failures.join('\n');
    code=GetTools()+code;
    return code;
  }
  
startExpression
 = code:Expression EOLs {
   MagicCheck(code); 
   code=Linker(code);
   if (failures.length) options.failures=failures.join('\n');
   return code;
 }
  
Reference 
= REFERENCE _ v:ParameterList EOLs {
  if (v[0]!='fields') fail("SAI Compiler: REFERENCE requires a trait list.");
  var code='';
  for (var i in v[2]) {
    var r=v[2][i];
    References[lp+r[0]]=true; 
    if (r[1].indexOf('function')==0) {
      fail("SAI Compiler: Cannot define functions in a reference block. Sorry, maybe someday.");
    }
    code+='var '+lp+r[0]+'='+r[1]+';\n'; 
  }
  return code;
}

Object
 = OBJECT _ k:Identifier _ typ:(MAIN/SINGLETON)? _ v:SemVer? _ EOLs d:Declarations* s:Processes* {
    if (!v) v=quoted('0.0.0-unspecified');
    var code='',isof=[];
    var isa=quoted(k);
    addToList('lock','isa')
    addToList('freeze','isof')
    code+='var isa=prototype.isa='+isa+';\n';
    isof.push('version:'+v);
    isof.push('isa:isa');
    isof.push('context:__context');
    if (typ) {
      isof.push('type:"'+typ+'"');
    }
    code+='var $bindfail=function(m){ throw new Error("SAI: A call to "+m+" on object "+isa+" has come unbound from any instance of that object. (If this is not in error, mark the declaration of "+m+" as unbound.)"); }\n';
    code+='prototype.isof['+isa+']={'+isof.join(',')+'};\n';
    var l;
    if (l=getList('lock')) code+='prototype.__tobelocked=prototype.__tobelocked.concat('+l+');\n';
    if (l=getList('freeze')) code+='prototype.__tobefrozen=prototype.__tobefrozen.concat('+l+');\n';
    code+=d.join('\n');
    code+=s.join('\n');
    clearLists();
    return code;
  }

Declarations
 = v:(Inherit / Contract / PropertyDef / Define) { return v }
 / EOLs

Processes
 = v:(Task) { return v }
 / EOLs


Inherit
 = INHERIT _ v:SimpleList EOLs {
   var inherit='['+v.join(',')+']';
   var code='prototype.isof[prototype.isa].inherit=prototype.__inherits='+inherit+';\n';
   return code;
  }

Contract
 = CONTRACT _ v:SimpleList EOLs {
   return 'prototype.__contracts=prototype.__contracts.concat(['+v.join(',')+']);\n';
  }

PropertyDef
 = v:Identifier p1:PropertyClause p2:PropertyClause?  {
   addInstanceVar(v);
   var prop={get: undefined, set: undefined};
   prop[p1[0]]=p1[1];
   if (p2) {
     prop[p2[0]]=p2[1]; 
   }
   var ret='Object.defineProperty(prototype,"'+v+
     '",{configurable:true,enumerable:true,get:'+prop.get+
     ',set:'+prop.set+
     '});\n';
   addToList('lock',v);
   return ret;
}

PropertyClause
 = _ g:(GET/SET) _ w:MultiOutput? _ b:Block EOLs { 
   if (!g) g='get'; 
   if (g=='get') w=null; 
   return [g,TaskFormatter({prefix:g,as:w,property:true,body:b,kind:'function'})]; 
  }

Task
 = v:TaskEvent k:Block EOLs {
   v.body=k;
   return TaskFormatter(v);    
  } 

TaskEvent
 = v:Identifier _ TO? _ unbound:UNBOUND? _ TASK _ x:Expects? _ w:MultiOutput? _ { 
   addInstanceVar(v);
   return  {name:"'"+v+"'",unbound:unbound,expects:x,as:w,kind:'function'};
 } 
 / v:ProcessName _ TO? _ unbound:UNBOUND? _ PROCESS _ x:Expects? _ w:MultiOutput? _ { 
   addInstanceVar(v);
   return  {name:v,expects:x,unbound:unbound,as:w,kind:'function*'};
 } 
 / v:Identifier _ TO? _ unbound:UNBOUND? _ PROMISE _ x:Expects? _ o:MultiOutput? _ { 
   addInstanceVar(v);
   var vn="'"+v+"'";
   var isthis='this['+vn+']?this:$bindfail('+vn+')';
   if (unbound) {
     isthis='this';
   }
   return {
    name:vn
    ,expects:x
    ,unbound:unbound
    ,as:o
    ,nothis:true
    ,kind:'function'
    ,preface:'var $='+isthis+'; return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
    };
  } 

ProcessName
 = v:ITERATOR { return "Symbol.iterator" }
 / v:Identifier { return "'"+v+"'" }

TaskClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:'return '+b+';',kind:'function'});
}

IteratorClause
= x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}
/ x:Expects? _ o:MultiOutput? _ ';'? _ b:Expression {
  return TaskClauseFormatter({expects:x,as:o,block:b,kind:'function*'});
}


PromiseClause
= o:MultiOutput? _ option:(ANY/ALL/ADOPT) _ x:Expression {
  var f='';
  if (option=='any') {
    f="Promise.race("+x+")";
  } else if (option=='all') {
    f="Promise.all("+x+")";
  } else {
    f=x;
  }
  
  var b=RV('^{f}.then( function(){ return $_resolve.apply($,arguments); } ).catch( function(){ $_reject.apply($,arguments); });',{f:f});

  return TaskClauseFormatter({
    as:o
    ,block:b
    ,nodefaultparam:true
    ,kind:'function'
    ,preface:'return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
  });
}
 / x:Expects? _ o:MultiOutput? _ b:Block {
  return TaskClauseFormatter({
    expects:x
    ,as:o
    ,block:b
    ,kind:'function'
    ,preface:'return new Promise(function($_resolve,$_reject) {'
    ,postface:'});'
  });
}



ExpectsParameter
 = i:Parameter _ t:Term? _ { return [i[1],t?t:true] }

Expects 
 = EXPECTS _ is:(i:ExpectsParameter COMMA _ {return i})* i:ExpectsParameter { is.push(i); return is; }
 / EXPECTS _ t:Term _ { return [[['','_root'],t]] }
 
Block
 = _ EOLs INDENT EOLs v:Lines DEDENT &EOLs { return v }
 / _ '..' _ v:Line &EOLs { return v+';' }

Lines
 = v:(LineTerm)+ { return v.join('') }

LineTerm
 = v:Line EOLs { return v }

Line
 = ConstructStatement
 / SetStatement
 / WithStatement
 / SwapStatement
 / MiscStatement
 / VerbStatement
 

Piper 
 = '|' _ i:JSIdentifier &{ return options.pipers[i];} _ a:(
     &{ return options.pipers[i].clauses[i].expr        }  o:PiperExpr       { return o }
   / &{ return options.pipers[i].clauses[i].exprs       }  o:PiperExprs       { return o }
   / &{ return options.pipers[i].clauses[i].outblock    }  o:PiperOutblock       { return o }
   / &{ return options.pipers[i].clauses[i].valexpr     }  o:PiperValexpr       { return o }
   / &{ return options.pipers[i].clauses[i].valoutblock }  o:PiperValoutblock       { return o }
   / &{ return options.pipers[i].clauses[i].valuse      }  o:PiperValuse       { return o }
   / &{ return options.pipers[i].clauses[i].use         }  o:PiperUse       { return o }
   / &{ return options.pipers[i].clauses[i].none        }  o:PiperNone       { return o }
 )
 
 {
   var opi=options.pipers[i];
    var work={
      clause: i,
      syntax: a.syntax,
      type: i+"."+a.syntax,
      args: a
    };
    var tools={
        addlocal:function(v){ if (!v) v=tempvar(); addLocal(v); return v; },
        replacer:RV,
        tasker:TaskClauseFormatter
    };
    var result=opi.handler({work:work,tools:tools});
    if (result.error) fail(result.error);

    if (opi.tools.length) for (var tc=0; tc<opi.tools.length; tc++) AddTool(opi.tools[tc]);
    if (result.tools && result.tools.length) for (var tc=0; tc<result.tools.length; tc++) AddTool(result.tools[tc]);

    return result.leftright || ['',''];
 }

PiperValoutblock
 = v:Value _ o:MultiOutput? _ b:Block {
   return {
     syntax: 'valoutblock',
     val: v,
     out: o,
     block: b
   };
 }

PiperOutblock
 = o:MultiOutput? b:Block {
   return {
     syntax: 'outblock',
     out: o,
     block: b
   };
 }

PiperValuse
 = v:Value _ USING Sep u:Value {
   return {
     syntax: 'valuse',
     val: v,
     use: u
   };
 }

PiperUse
 = USING Sep u:Value {
   return {
     syntax: 'use',
     use: u
   };
 }

PiperValexpr
 = v:Value _ x:ExprParen {
   return {
     syntax: 'valexpr',
     val: v,
     expr: x
   };
 }

PiperExprs
 = x:ParameterList {
   return {
     syntax: 'exprs',
     exprs: x
   };
 }

PiperExpr
 = x:ExprParen {
   return {
     syntax: 'expr',
     expr: x
   };
 }

PiperNone
 = _ {
   return {
     syntax: 'none'
   };
 }

ExprParen
 = x:Expression { return x; }
 / LPAREN _ x:Expression _ RPAREN _ { return x; }



ConstructStatement
  = i:JSIdentifier &{ return options.constructs[i]; } _ 
    a:(
         &{return options.constructs[i].clauses[i].exproutblock}   ca:CAExproutblock  {return ca}
       / &{return options.constructs[i].clauses[i].exprout}        ca:CAExprout     {return ca}
       / &{return options.constructs[i].clauses[i].exprsblock}     ca:CAExprsblock     {return ca}
       / &{return options.constructs[i].clauses[i].exprsoutblock}  ca:CAExprsoutblock     {return ca}
       / &{return options.constructs[i].clauses[i].exprusing}      ca:CAExprusing     {return ca}
       / &{return options.constructs[i].clauses[i].outblock}       ca:CAOutblock      {return ca}
       / &{return options.constructs[i].clauses[i].block}          ca:CABlock      {return ca}
       / &{return options.constructs[i].clauses[i].exprs}          ca:CAExprs      {return ca}
       / &{return options.constructs[i].clauses[i].verb}           ca:CAVerb       {return ca}
       / &{return options.constructs[i].clauses[i].none}           ca:CANone       {return ca}
       // CAError
      )
    cl:(EOLs cli:Identifier &{
      if (cli===i && !options.constructs[i].repeats) return false;
      return options.constructs[i].clauses[cli];
    } _ cla:
      (
         &{return options.constructs[i].clauses[cli].exproutblock}  claa:CAExproutblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprout}       claa:CAExprout {return claa}
       / &{return options.constructs[i].clauses[cli].exprsblock}    claa:CAExprsblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprsoutblock} claa:CAExprsoutblock {return claa}
       / &{return options.constructs[i].clauses[cli].exprusing}     claa:CAExprusing {return claa}
       / &{return options.constructs[i].clauses[cli].outblock}      claa:CAOutblock {return claa}
       / &{return options.constructs[i].clauses[cli].block}         claa:CABlock {return claa}
       / &{return options.constructs[i].clauses[cli].exprs}         claa:CAExprs {return claa}
       / &{return options.constructs[i].clauses[cli].verb}          claa:CAVerb {return claa}
       / &{return options.constructs[i].clauses[cli].none}          claa:CANone{return claa}
       // CAError
      )
 {return [cli,cla];})* {
   
     var work=[[i,a]].concat(cl);
     var work2=[];
     for (var i1=0; i1<work.length; i1++) {
       var j=work[i1];
       if (j[1].syntax === 'error') {
         fail("SAI Compiler: Error in "+j[0]+" / "+i+" (this is a propogated error, look within the clause for syntax faults).",j[1].location);
       }
       work2.push({
         clause: j[0],
         syntax: j[1].syntax,
         type: j[0]+'.'+j[1].syntax,
         args: j[1]
       });
     }
    var result=options.constructs[i].handler({
      clauses:work2,
      tools:{
        addlocal:function(v){ if (!v) v=tempvar(); addLocal(v); return v; },
        replacer:RV,
        tasker:TaskClauseFormatter
      }
    });
    if (result.error) fail(result.error);
    return result.body;
 }
 
CAError = .* { return { syntax: 'error', location: location().start.offset }; }
 
CAExprsoutblock = pl:ParameterList _ mo:MultiOutput? _ b:Block { return {
  syntax: 'exprsoutblock',
  exprs: pl,
  out: mo,
  block: b
}; }

CAExproutblock = x:Expression _ mo:MultiOutput? _ b:Block { return {
  syntax: 'exproutblock',
  expr: x,
  out: mo,
  block: b
}; }

CAExprout = x:Expression _ mo:MultiOutput? _ { return {
  syntax: 'exprout',
  expr: x,
  out: mo,
}; }

CAExprusing = x:Expression _ USING Sep task:Value { return {
  syntax: 'exprusing',
  expr: x,
  using: task
}; }

CAOutblock = mo:MultiOutput? _ b:Block { return {
  syntax: 'outblock',
  out: mo,
  block: b
}; }

CABlock = _ b:Block { return {
  syntax: 'block',
  block: b
}; }

CAExprs = pl:ParameterList { return {
  syntax: 'exprs',
  exprs: pl
}; }

CAExprsblock = _ pl:ParameterList _ b:Block { return {
  syntax: 'exprsblock',
  exprs: pl,
  block: b
}; }

CAVerb = v:VerbSentence { return {
  syntax: 'verb',
  verb: v
}; }

CANone = _ &EOLs { return { 
  syntax: 'none' 
}; }
 
 

MiscStatement
 = ORPHAN _ { return 'var $=this;\n' }
 / NOP _ { return ';' }


WithStatement
  = WITH Sep value:Expression out:Output? block:Block {
      var r={this:(out?out:tempvar())};
      var code=RV('var ^{this}=',r)+value+RV(';\n'+block+'\n',r);
      return code; 
  }
 
SwapStatement
 = SWAP Sep a:LValue Sep b:LValue {
   return RV('var ^{t1}=^{v1}; var ^{t2}=^{v2}; ^{v2}=^{t1}; ^{v1}=^{t2};',{t1:tempvar(),t2:tempvar(),v1:a,v2:b});
 }


SetStatement
 = SET _ t:SetTerms { return t }
 / SET Sep EOLs INDENT EOLs t:SetBlock DEDENT { return t.join(''); } 
 / LOCAL _ t:LocalTerms { return t }
 / LOCAL Sep EOLs INDENT EOLs t:LocalBlock DEDENT { return t.join(''); } 
 / INC _ v:RValue _ { return v+'=('+v+' || 0)+1;\n'; } // test 'inc a'
 / DEC _ v:RValue _ { return v+'--;\n'; } // test 'dec a'
 / DELETE _ v:RValue _ { return 'delete '+v+';\n'; }

SetTerms
 = t:SetTerm _ v:(',' _ v:SetTerm _ { return v })*  { return v.concat(t) }
  
SetLine
 = v:SetTerms EOLs { return v }

SetBlock
 = v:(SetLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

SetTerm
 = l:RValues _ '-' _ e:Expression {
     fail('SAI Compiler: the "set val - expr" construct is unclear. Please use "set val to -expr" or "set val self - expr" as appropriate.');
   }
 / l:RValues _ o:Itselfop _ e:Expression {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(itselfops[o], {'1':l[i], '2':RV(e,{self:l[i]}) } )+';\n';
   }
   return code;
 }
 / l:LValues _ (TO?/&FROM/&BANG/&CHAIN) _ e:Expression {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   if (l.length==1) return l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+=l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+=RV(unops[o],{'1':l[i]})+';\n';
   }
   return code;
 }
 / l:RValues _ o:Piper {
   if (readOnlyReference) for (var i in l) if (References[l[i]]) fail("SAI Compiler: Cannot assign to reference variable "+l[i].substr(1)+"."); 
   var code='';
   for (var i in l) {
     code+= l[i]+'='+o[0]+l[i]+o[1]+';\n';
   }
   return code;
 }


LocalTerms
 = t:LocalTerm _ v:(',' _ v:LocalTerm _ { return v })*  { return v.concat(t) }
  
LocalLine
 = v:LocalTerms EOLs { return v }

LocalBlock
 = v:(LocalLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

LocalTerm
 = l:RValues _ o:Itselfop _ e:Expression {
   fail("SAI compiler: 'local' should only be used when declaring variables, not when modifying them.");
 }
 / l:LValues _ (TO?/&FROM/&BANG/&CHAIN) _ e:Expression {
   for (var i in l) {
     //console.log("local scope check "+l[i]);
     if ('$.'==l[i].substring(0,2)) CheckScope(l[i].substring(2),"local-1");
     if (lp==l[i].substring(0,lp.length)) CheckScope(l[i],"local-2");
   }
   if (l.length==1) return 'let '+l[0]+'='+RV(e,{self:l[0]})+';\n';
   var code='var $_='+e+';\n';
   for (var i in l) {
     code+='let '+l[i]+'=$_['+i+'];\n';
   }
   return code;
 }
 / l:RValues _ o:UnOp {
   fail("SAI compiler: 'local' should only be used when declaring variables, not when modifying them.");
 }



LocalAdj
 = LOCAL Sep { return 'local '; }


UnOp // test 'self*'
 = '-' / DELETE / NOTB / NOT 

Itselfop // test 'self*'
 = '+' / '-' 
 / '**' / '*' / '/' / '%' / '<<' / '>>' / '>>>'
 / ANDB / ORB / XORB
 / AND / OR / XOR / NAND / NOR
 / '?>' / '?<'
 / UPDATE / DELETE 
 / DEFAULT / '?' 
 / CONCAT 



VerbStatement
 = v:Verbd { return v+';\n'; }
 / v:VerbSentence  { return v+";\n"; }
 / v:VerbChain { return '$AI.drain_op('+v+');\n'; }
 
LValues
 = v:LValue a:LValueSep* _ { return [v].concat(a) }
 
LValueSep
 = ',' _ v:LValue { return v }

LValue 
 = v:LStem
  {
    var j=v.length;
    if (!j) fail("SAI Compiler: Expected something to assign into");
    if (j==1) {
      var pattern=accessors.firststore[v[0][0]];
      if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
      return pattern[0] + v[0][1] + pattern[1];
    }
    j--;
    var code='';
    var patternbase=accessors.firstfetch;
    var i=0; while (i<j) {
      var pattern=patternbase[v[i][0]]; patternbase=accessors.nextfetch;
      if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
      code+=pattern[0] + v[i][1] + pattern[1];
      i++;
    }
    var pattern=accessors.laststore[v[j][0]];
    if (!pattern) fail("SAI Compiler: Couldn't construct recipient from "+v);
    code= code+pattern[0]+v[j][1]+pattern[1];
    return code;
  }


RValues
 = v:RValue a:RValueSep* { return [v].concat(a) }
 
RValueSep
 = ',' _ v:RValue { return v }

SimpleValue
 = v:SimpleTerm
  { return ValueCompositor(v,false) }

RValue 
 = v:RStem
  { return ValueCompositor(v,false) }

RValueSafe
 = v:RStem
  { return ValueCompositor(v,true) }

VerbValue  
 = v:RStemVerb
  {
    var verb='',stem='';
    if (v[0][0]=='local') {
      var test=v[0][1].substr(lp.length,v[0][1].length-lp.length);
      var binding=options.globals[test];
      if (binding) {
        v[0][0]='bound';
        v[0][1]=binding;
      }
    }
    var patternbase=accessors.firstfetch;
    var i=0; while (i<v.length) {
      var pattern=patternbase[v[i][0]]; 
      patternbase=accessors.nextfetch;
      if (!pattern) fail("SAI Compiler: VV Couldn't construct dereference from "+v[i]+' because '+pattern+' is false');
      stem+=verb;
      verb=pattern[0] + v[i][1] + pattern[1];
//      console.log("VV"+i+": stem:"+stem+" verb:"+verb);
      i++;
    }
    return [stem,verb];
  }
 


LStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / LLocalStem / GlobalStem / ParenStem 

RStem
 = ItStem / SuperStem / RootedStem / PropertyStem / ParameterStem / RLocalStem / GlobalStem / ParenStem 

RStemVerb
 = RStem 
 / TASK Sep v:TaskClause _ { return [['literal',v]] }
 / PROCESS Sep v:IteratorClause _ { return [['literal',v]] }
 / PROMISE Sep v:PromiseClause _ { return [['literal',v]] }


SuperStem
 = SUPER _ { return [['super','']]; }

PropertyStem 
 = x:Property y:(Attribute/Index/Call)*  { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RootedStem
 = x:Root y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

GlobalStem
 = x:Global y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

LLocalStem
 = x:LLocal y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

RLocalStem
 = x:RLocal y:(Attribute/Index/Call)* { 
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
  }

ParameterStem
 = x:Parameter y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }

ItStem
 = x:(It) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }
 
ParenStem
 = x:(Parenthetic/LiteralElm) y:(Attribute/Index/Call)* {
    var stem=x;
    for (var i in y) stem=stem.concat(y[i]);
    return stem 
 }


It
 = IT Sep { return [['it','']] }
 / KEY Sep { return [['key','']]}
 / COUNTER Sep { return [['counter','']]}
 / TRIAL Sep { return [['trial','']]}
 / SUM Sep { return [['sum','']]}
 / SELF Sep { return [['self','']]}
 / ERROR Sep { return [['error','']]}

Attribute
 = DOT v:IdentifierProto { return [[ 'attribute', v ]] }
 / '\'s' Sep v:IdentifierProto { return [[ 'attribute', v ]] }
 
Call
 = LPAREN _ p:ParameterList? _ RPAREN _ { 
   return [[ 'function', p?p[1]:'' ]] 
}
 
Root
 = DOT !DOT v:IdentifierProto { return [[ 'it', ''],[ 'attribute', v ]] }
 / DOT v:PositiveInteger { return [[ 'it', ''],[ 'index', v ]] }
 / DOT !DOT { return [[ 'it', '']] }

Index
 = '[' _ v:Expression _ ']' { return [[ 'index', v ]] }
 / '\\' v:SimpleValue { return [['index',v]] }
 / '.' v:PositiveInteger { return [[ 'index', v ]] }

Parenthetic
 = LPAREN _ v:Expression _ RPAREN { return [[ 'paren', v ]] }

LLocal
 = v:Identifier { 
   //console.log("LLocal "+v);
   if (InstanceVars[v]) {
     usedMemberVar=v;
     return [['this',''],[ 'attribute',v ]]; 
   }
   if (!options.globals[v]) addLocal(lp+v); 
   return [[ 'local',lp+v ]];
}

RLocal
 = v:Identifier { 
   //console.log("RLocal "+v);
   if (InstanceVars[v]) {
     usedMemberVar=v;
     return [['this',''],[ 'attribute',v ]]; 
   }
   if (!options.globals[v]) {
     v=checkLocal(lp+v,v);
   } else {
     v=lp+v;
   }
   return [[ 'local',v ]];
}

Parameter
 = '$$' { return [['arguments','']]}
 / ARGUMENTS _ { return [['arguments','']]}
 / '$' v:IdentifierProto { return [[ 'parameters','' ],['attribute',v]] }
 / '$' { return [[ 'parameters','' ]]}

LiteralElm
 = v:Literal { return [['literal',v]]}

Global
 = '~' v:JSIdentifier { return [['global',v]] }

Property
 = '@' v:IdentifierProto { return [['this',''],[ 'attribute',v ]] }
 / MY Sep v:IdentifierProto { return [['this',''],[ 'attribute',v ]] }
 / '@@' v:IdentifierProto { return [['currentthis',''],[ 'attribute',v ]] }
 / '@@' { return [['currentthis','']] }
 / '@' { return [['this','']] }
 / ME ![a-zA-Z_0-9] { return [['this','']] }

SimpleTerm
 = It/RLocal/Parameter/Property/Root
 / v:Number { return [['literal',v]] }
 / v:StringLiteral { return [['literal',v]] }

// DEFINITIONS

 
 


Define
  = GIVEN _ k:Identifier _ v:Definition EOLs { 
     addToList('freeze',k);
     addInstanceVar(k);
     return 'prototype["'+k+'"]='+v[1]+';\n';
   } 
  / GIVEN _ v:FieldDefinition EOLs { 
//    addToList('lock',i);
    addInstanceVars(v);
    var code='';
    code+='var t='+v[1]+';\nfor (var i in t) { prototype.__tobelocked.push(i); prototype[i]=t[i]; };\n'; 
    return code;
  }
  / INSTANCE _ v:FieldDefinition EOLs {
    var ivar=GlobVar();
    addInstanceVars(v);
    var proof='var '+ivar+'=function(){ var $=this; return '+v[1]+'; }\nfor (var i in '+ivar+'()) { prototype[i]=undefined; };\n'; 
    var sup=GlobVar();
    var setup= 'var '+sup+'=prototype.Constructor || function(){};\nprototype.Constructor=function() {\n'+sup+'.call(this);\n  var t='+ivar+'();\n  for (var i in t) if (t[i] !== undefined) this[i]=t[i];\n};\n'; 
    return proof+setup;
  }



SemVer
 = maj:PositiveInteger DOT min:PositiveInteger DOT patch:PositiveInteger {
   return "'"+maj+"."+min+"."+patch+"'";
 }


ParameterList
 = COLON _ EOLs INDENT EOLs v:FieldBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields', '{'+w.join(',')+'}',v] }
 / COLON _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['array',v.join(','),v] }
 / v:Items ';'? { return ['array',v.join(','),v] }
 / v:Fields ';'? { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['fields','{'+w.join(',')+'}',v] }
 / ';' { return null }

Definition
 = _ v:Item { return ['literal',v] }

 
NestedDefinition
 = _ EMPTY _ { return ['literal','[]']; }
 / _ BLANK _ { return ['literal','{}']; }
 / _ LIST _ v:Terms _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ LIST _ EOLs INDENT EOLs v:TermBlock DEDENT { return ['literal','['+v.join(',')+']'] }
 / _ TRAITS _ v:Traits _ SEMI? _ { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ TRAITS _ EOLs INDENT EOLs v:TraitBlock DEDENT { var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }
 / _ (COLON/ARRAY) _ v:Items _ SEMI? _ { return ['literal','['+v.join(',')+']'] }
 / _ (COLON/ARRAY) _ EOLs INDENT EOLs v:ItemBlock DEDENT { return ['literal','['+v.join(',')+']'] }



FieldDefinition
 = _ (COLON/FIELDS) _ v:Fields _ SEMI? _ { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal','{'+w.join(',')+'}'] }
 / _ (COLON/FIELDS) _ EOLs INDENT EOLs v:FieldBlock DEDENT { v=EnumCheck(v); var w=[]; for (var i in v) { w[i]=v[i][0]+':'+v[i][1]; } return ['literal', '{'+w.join(',')+'}'] }


SimpleList
 = _ (COLON/LIST) _ v:Terms _ SEMI? _ { return v }
 / _ (COLON/LIST) _ EOLs INDENT EOLs v:TermBlock DEDENT { return v }


Term
 = EQUALS _ v:Expression { return v }
 / v:NestedDefinition { return v[1] }
 / MultiString
 / Number
 / TRUE
 / FALSE
 / UNDEFINED
 / NULL
 / StringLiteral
 / BareString
  
BareString
 = v:[^\n\},);|]+ &('|' / ',' / ')' / ';' / EOLs) { return quoted(v.join('').trim()) } 


TermSep
 = v:Term _ COMMA _  { return v }
 
Terms
 = v:(TermSep)* t:(Term) { return v.concat(t) }
  
TermLine
 = !DEDENT v:Terms EOLs { return v }

TermBlock
 = v:(TermLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Item
 = Expression

ItemSep
 = v:Expression _ COMMA _  { return v }
 
Items
 = v:(ItemSep)* t:(Item) { return v.concat(t) }
  
ItemLine
 = v:Items EOLs { return v }

ItemBlock
 = v:(ItemLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 

Trait
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:Term _ { return [[k,v]] }
 
TraitSep
 = v:Trait _ COMMA _ { return v }

Traits
 = v:(TraitSep)* t:(Trait) { 
   var r=[]; 
   for (var i in v) r=r.concat(v[i]); 
   r=r.concat(t);  
   return r; 
}
 
TraitLine
 = v:Traits EOLs { return v }
 
TraitBlock
 = v:(TraitLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }



Field
 = HASH k:Keyword _ { return [[k,true]] }
 / k:Keyword Sep v:(Expression/ENUM) _ { return [[k,v]] }
 
FieldSep
 = v:Field _ COMMA _ { return v }

Fields
 = v:(FieldSep)* t:(Field) { var r=[]; for (var i in v) r=r.concat(v[i]); r=r.concat(t); return r; }
 
FieldLine
 = v:Fields EOLs { return v }
 
FieldBlock
 = v:(FieldLine)+ { return v.reduce(function(a,b){return a.concat(b)}) }

 
 
Output
 = AS _ v:ParameterCandidate _ { return v[0][1] }

IterateOutput
 = o:MultiOutput {
   var v=[];
   for (var i in o) v.push(o[i][0][1]);
   return v;
 }
 
MultiOutput
 = (AS/GIVEN) _ k:(k:ParameterCandidate _ COMMA _ {return k})* _ v:RLocal { k.push(v); return k; }
 
ParameterCandidate
= v:Identifier {
   
   CheckScope(v,"parameter/as/given");
   if (!options.globals[v]) addLocal(lp+v); 
   return [[ 'local',lp+v ]];
}




Expression
 = v:ListQualify
 

ListQualify
 = v:Logical _ c:(c:Comprehension _ {return c})* {
   for (var i in c) {
     v=c[i][0]+v+c[i][1];
   }
   return v;
 } 


Comprehension
 = Piper
 // MapComprehension 
 // AuditComprehension
 // ReduceComprehension 
 // KeysComprehension 
 // ValuesComprehension
 // IterateComprehension
 // CollectComprehension
 // SetComprehension
 // ObserveComprehension
 / OtherComprehension
 / FilterComprehension 
 / SortComprehension 
 // ConcatComprehension


IterateComprehension
 = ITERATE { // test 'sow *'
     return ['$AI.iterate_op(',')'];
   }

KeysComprehension
 = KEYS { // test 'keys comp*'
     return ['$AI.keys_op(',')'];
   }

ValuesComprehension
 = VALUES { // test 'values comp*'
     return ['$AI.values_op(',')'];
   }

ConcatComprehension
 = CONCAT Sep x:Expression {
   return ['$AI.concat_op(' , ','+x+')' ];
 }

CollectComprehension
 = COLLECT { return ['$AI.collect_op(',')']; }
 / ENLIST { return ['$AI.enlist_op(',')']; }
 / ENTRAIT { return ['$AI.entrait_op(',')']; }

SortComprehension
 = BY Sep x:SortComprehension2 { return x }
SortComprehension2
 = o:IterateOutput? b:Block {
    if (!o) o=[lp+'a',lp+'b'];
    var block=RV('function('+o[0]+','+o[1]+'){'+b+'}');
    return ['$AI.sort_op(' , ','+block+')']; 
  }
 / USING Sep x:Value {
   return ['$AI.sort_op(' , ','+x+')' ];
  }

MapComprehension
 = THRU Sep x:MapComprehension2 { return x }
MapComprehension2
 = x:Expression  { // test 'thru inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'}',{this:'$_v',key:'$_k'});
     return ['$AI.map_op(' , ','+block+' )']; 
  }
 / LPAREN _ x:Expression _ RPAREN _ { // test 'thru inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'}',{this:'$_v',key:'$_k'});
     return ['$AI.map_op(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'thru block'
     var block=RV('function(^{this},^{key}){'+b+'; return ^{this};}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.map_op(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'thru using'
   return ['$AI.map_op(' , ','+x+')' ];
  }

AuditComprehension
 = AUDIT Sep x:AuditComprehension2 { return x }
AuditComprehension2
 = LPAREN _ x:Expression _ RPAREN _ { // test 'audit inline *'
     var block=RV('function(^{this},^{key}){ '+x+'; }',{this:'$_v',key:'$_k'});
     return ['$AI.audit_op(' , ','+block+' )']; 
  }
 / x:Expression { // test 'audit inline *'
     var block=RV('function(^{this},^{key}){ '+x+'; }',{this:'$_v',key:'$_k'});
     return ['$AI.audit_op(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block { // test 'audit block*'
     var block=RV('function(^{this},^{key}){'+b+' }',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.audit_op(' , ','+block+' )']; 
  }
 / USING Sep x:Value { // test 'audit using*'
   return ['$AI.audit_op(' , ','+x+')' ];
  }

ReduceComprehension
 = INTO Sep x:ReduceComprehension2 { return x }
ReduceComprehension2
 = into:IntoClause o:IterateOutput? b:Block {
    if (!o) o=[];
    if (!o[0]) o[0]=lp+'sum'; 
    if (!o[1]) o[1]='$_v';
    if (!o[2]) o[2]='$_k';
    b+='return ^{sum};\n';
    var block=RV('function(^{sum},^{this},^{key}){'+b+'}',{sum:o[0],this:o[1],key:o[2]});
    if (into=='it') {
      return ['$AI.reduce_op(' , ','+block+')' ];
    } else {
      return ['$AI.reduce_op(' , ','+block+','+into+')' ];
    }
  }
 / into:IntoClause b:Expression {
    var block=RV('function(^{sum},^{this},^{key}){ return '+b+';}',{sum:lp+'sum',this:'$_v',key:'$_k'});
    if (into=='it') {
      return ['$AI.reduce_op(' , ','+block+')' ];
    } else {
      return ['$AI.reduce_op(' , ','+block+','+into+')' ];
    }
  }
  / into:IntoClause USING Sep x:Value  {
    if (into=='it') {
      return ['$AI.reduce_op(' , ','+x+')' ];
    } else {
      return ['$AI.reduce_op(' , ','+x+','+into+')' ];
    }
  }

FilterComprehension
 = HAS Sep x:FilterComprehension2 { return x }
FilterComprehension2
 = x:Expression { // test 'filter inline *'
     var block=RV('function(^{this},^{key}){ return '+x+'; }',{this:'$_v',key:'$_k'});
     //console.log("filter comp exp");
     return ['$AI.filter_op(' , ','+block+' )']; 
  }
 / o:IterateOutput? b:Block {
     var block=RV('function(^{this},^{key}){'+b+'}',{this:o?o[0]:'$_v',key:o?o[1]:'$_k'});
     return ['$AI.filter_op(' , ','+block+')']; 
  }
  / USING Sep x:Value {
    return ['$AI.filter_op(' , ','+x+')' ];
  }


SetComprehension
 = SET Sep x:AlterComprehension2 { return x }
AlterComprehension2
 = x:Expression { // test 'alter inline*'
     var block=RV('function(^{this}){ return '+x+'; }',{this:'$_v'});
     return [ '$AI.alter_op(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'alter block*'
     var block=RV('function(^{this}){'+b+'; return ^{this}; }',{this:o?o[0]:'$_v'});
     return [ '$AI.alter_op(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'alter using'
     return [ '$AI.alter_op(' , ','+x+')']; 
  }
  
ObserveComprehension
 = OBSERVE Sep x:ObserveComprehension2 { return x }
ObserveComprehension2
 = x:Expression { // test 'observe inline'
     var block=RV('function(^{this}){ '+x+'; }',{this:'$_v'});
     return [ '$AI.observe_op(' , ','+block+')']; 
  }
 / o:IterateOutput? b:Block { // test 'observe block'
     var block=RV('function(^{this}){'+b+'; }',{this:o?o[0]:'$_v'});
     return [ '$AI.observe_op(' , ','+block+')']; 
  }
 / USING Sep x:Value { // test 'observe using'
     return [ '$AI.observe_op(' , ','+x+')']; 
  }



OtherComprehension
 = _ q:(Quality / Criteria / Sequence / Limit)+ _ 
 {
   var code='({<>})';
   q=[].concat(q);
   var expr={quality:[],having:[],by:[],map:[],limit:[]};
   for (var i in q) { 
     for (var j=0; j<q[i].length; j+=2) {
       expr[q[i][j]].push(q[i][j+1]); 
     }
   }
   var conds=[];
   if (expr.quality.length) {
     for (var i in expr.quality) { 
       conds.push(expr.quality[i]); 
      }
   }
   if (expr.having.length) {
     var conds=conds.concat(expr.having.map(function(c){ return '('+c+')';}));
   }
   if (conds.length) {
     code=RV('$AI.filter_op(^{source},function($_v,$_k){ return ^{block}; })',{source:code,block:conds.join(' && '),this:'$_v',key:'$_k'});
   }
   if (expr.limit.length && expr.limit[0].extract && expr.by.length) { // first/last singleton with a sort
     code='$AI.reduce_op('+code+',function(a,b) { if (undefined===a) return b; var r; ';
     expr.by[0][1]*=expr.limit[0].sort; // flip sort if looking for "last"
     var conds=expr.by.map(function(c){
       c[0]=c[0]||'^{this}';
       var x1=RV(c[0],{this:'a'});
       var x2=RV(c[0],{this:'b'});
       return RV('r=$AI.compare_op(^{x1},^{x2}); if (r<0) return ^{lt}; if (r>0) return ^{gt};\n',{x1:x1,x2:x2,lt:(c[1]>0?'a':'b'),gt:(c[1]>0?'b':'a')});
     });
     code+=conds.join(' ')+'return a; },undefined)';     
   } else {
     if (expr.by.length) {
       code='$AI.sort_op('+code+',function(a,b) { var aa,bb; ';
       var conds=expr.by.map(function(c){
         c[0]=c[0]||'^{this}';
         var x1=RV('aa='+c[0]+'; ',{this:'a'});
         var x2=RV('bb='+c[0]+'; ',{this:'b'});
         return x1+x2+RV('if (aa<bb) return ^{lt}; if (aa>bb) return ^{gt}; ',{c:c[0],lt:-c[1],gt:c[1]});
       });
       code+=conds.join(' ')+'return 0; })';
     }
     if (expr.limit.length) {
       var l=expr.limit[0];
       if (l.slice) {
         code='$AI.slice_op('+code+','+l.start+','+l.len+')';
       }
       if (l.extract) { 
         code='$AI.element_op('+code+',0)';
       }
       if (l.count) {
         code='$AI.count_op('+code+')';
       }
     }
   } 
   return code.split('{<>}');
 }


 
Limit 
 = FIRST _ { return ['limit',{extract:true,sort:1}]; } 
 / LAST _ { return ['limit',{extract:true,slice:true,start:-1}]; } 
 / LIMIT _ s:Logical _ COMMA _ c:Logical _ { return ['limit',{slice:true,start:s,len:c}]; } 
 / LIMIT _ s:Logical _ { return ['limit',{slice:true,start:undefined,len:s}]; } 
 / COUNT _ { return ['limit',{count:true}]; }
 
Quality
 = HASH v:Keyword _ { return ['quality', '^{this}["'+v+'"]'] }
 / BANG HASH v:Keyword _ { return ['quality', '(!^{this}["'+v+'"])'] }

Criteria
 = HAS _ v:Logical _ { return ['having',v] }

Sequence
 = BY _ d:SortDirection _ { return ['by',[null,d?d:1]] }
 / BY _ v:Logical d:SortDirection? _ { return ['by',[v,d?d:1]] }
 / HIGHEST _ v:Logical _ { return ['by',[v,-1],'limit',{extract:true,sort:1}]}
 / LOWEST _ v:Logical _ { return ['by',[v,1],'limit',{extract:true,sort:1}]}

SortDirection
 = (ASC) _ { return 1 }
 / (DESC) _ { return -1 }



Logical
 = l:Comparison _ o:LogicalOp _ r:Logical { return '('+l+o+r+')' }
 / c:Comparison _ XOR _ l:Logical  { return '($AI.xor_op('+c+','+l+'))' } // test 'xor' 
 / l:Comparison _ NAND _ f:Logical { return '(!('+l+' && '+f+'))' } // test 'nand'
 / l:Comparison _ NOR _ f:Logical { return '(!('+l+' || '+f+'))' } // test 'nor'
 / c:Comparison _ '??' _ l:Logical _ '::' _ r:Logical { 
     return RV('((^{c})?(^{l}):(^{r}))',{c:c,l:l,r:r}); 
   } 
 / v:Comparison _ { return v }

LogicalOp
 = AND Sep { return '&&' } // test 'and'
 / OR Sep { return '||' } // test 'or'
 
Comparison
 = l:Addition _ o:MathOp _ r:Comparison { return o+'('+l+','+r+')' }
 / l:Addition _ o:ComparisonOp _ r:Comparison { return '('+l+o+r+')' }
 / v:Addition _ { return v }
 
ComparisonOp
  = '>=' { return '>=' } // test '>='
  / '>' !'>' { return '>' } // test '>'
  / '=' { return '==' } // test '='
  / ISNT Sep { return '!==' } // test 'isnt'
  / IS Sep { return '===' } // test 'is *'
  / '<=' { return '<=' } // test '<='
  / '<' !'<' { return '<' } // test '<'
  / '!=' { return '!=' } // test '!='


MathOp
 = '?>' { return '$AI.max_op' } // test '?>'
 / '?<' { return '$AI.min_op' } // test '?<'
 / '<=>' { return '$AI.compare_op' } // test '<=>'

   
   
Addition
 = l:Multiplication _ o:AdditionOp _ r:Addition { return '('+l+o+r+')' }
 / v:Multiplication _ { return v }

AdditionOp
 = '+' // test '+'
 / '-' // test '-'
 / ORB Sep {return '|' } // test 'binary or'
 / ANDB Sep {return '&'} // test 'binary and'
 / XORB Sep { return '^'}  // test 'binary xor'

Multiplication 
 = DefaultOp
 / l:Value _ o:MultiplicationOp _ r:Multiplication { return '('+l+o+r+')' }
 / l:Value _ '**' _ r:Multiplication { // test '**'
   return 'Math.pow('+l+','+r+')' 
 } 
 / l:Value _ VIA _ op:Value _ x:ParameterList? {
   var p=undefined;
   if (x) {
     p=x[1];
   }
   return '('+op+').call($,('+l+'),'+p+')';
 }
 / l:Value _ UPDATE Sep r:Multiplication { // test 'overlay *'
   return '$AI.overlay_op('+l+','+r+')' 
 }
 / l:Value _ SELECT Sep r:Multiplication { // test 'select *'
   return '$AI.select_op('+l+','+r+')' 
 }
 / l:Value _ DELETE Sep r:Multiplication { // test 'delete *'
   return '$AI.delete_op($AI.clone_op('+l+'),'+r+')' 
 }
 / l:Value _ EXPECTS Sep r:Multiplication { 
   return '$AI.expects_op('+l+','+r+')' 
 }
 / l:Value _ ISOF Sep r:Multiplication { 
   return '('+l+').isof['+r+']'; 
 }
 / v:Value _ { return v }

DefaultOp
 = l:Value _ DEFAULT _ v:Multiplication  {  // test 'default*'
     SafetyFetch=true; 
     return RV('((undefined!==($_b=^{l}))?$_b:^{v})',{l:l,v:v}); 
   } 
 / l:Value _ '?' !'?' _ v:Multiplication  {  // test 'default*'
     SafetyFetch=true; 
     return RV('((undefined!==($_b=^{l}))?$_b:^{v})',{l:l,v:v}); 
   } 


MultiplicationOp
 = '*' // test '*'
 / '/' // test '/'
 / '%' // test '%'
 / '>>>' // test 'rshz'
 / '>>' // test 'rsh'
 / '<<' // test 'lsh'

 
Value
 = '-' _ v:Value _ { return '(0-('+v+'))' } // test 'unary -'
 / NOTB Sep v:Value _ { return '(~('+v+'))' } // test 'unary binary not' 
 / NOT Sep v:Value _ { return '(!('+v+'))' } // test 'unary not'
 / TYPEOF Sep v:Value _ { return 'typeof ('+v+')'; }
 / ISNAN Sep v:Value _ { return 'isNaN('+v+')'; }
 / NUMBER Sep v:Value { return '($AI.number_op('+v+'))'; } // test 'number *'
 / EXISTS Sep v:Value _ { return '(undefined!=='+v+')' } // test 'exists'
 / COPY Sep v:Value _ { return '$AI.clone_op('+v+')'; } // test 'copy'
 / TASK Sep v:TaskClause _ { return v }
 / PROCESS Sep v:IteratorClause _ { return v }
 / PROMISE Sep v:PromiseClause _ { return v }
 / BANG Sep? v:VerbSentence _ { return v }
 / FROM Sep v:VerbSentence _ { return v }
 / BIND Sep v:Value _ { return  'function(){return ('+v+').apply($,arguments);}'; }
 / Verbd
 / '?' v:RValueSafe _ { return v }
 / v:RValue _ { return v }
 / VerbChain 
 / v:NestedDefinition { return v[1] }
 / o:NewObject _ { return o }
 / '(' _ v:Expression _ o:Output? ')' _ { 
   if (o) {
     addLocal(o);
     return RV('(^{out}='+v+')',{out:o}); 
   } else {
     return '('+v+')'; 
   }
  }
 / x:Regex _ { return x }

Regex
 = '/' x:(RegexEscape/RegexChar)+ '/' m:[igm]* _ {
   var re= '/'+x.join('')+'/'+m.join('');
   return re;
 }

RegexEscape 
 = '\\/' 
 
RegexChar
 = [^\n\r/]

Keyword
 = v:Identifier ![.(\[|] { return v } 
 / StringLiteral 
 // n:Number { return quoted(n.toString()); }
 
Identifier
 = v:IdentifierProto !{var hop=ResWords.hasOwnProperty(v);return hop;} { return v; }  

JSIdentifier
 = v1:[a-zA-Z_] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

IdentifierProto
 = JSIdentifier
// = v1:[a-zA-Z] v2:[a-zA-Z_0-9]* { return v1+v2.join('') }

Literal
 = Number 
 / StringLiteral
 / TRUE 
 / FALSE
 / UNDEFINED 
 / NULL
 / NaN { return 'NaN' }
 / INFINITY { return 'Infinity' }
 
IntoClause
 = IT Sep { return 'it' }
 / r:Expression 


////////////////////////////////////////////////////////// VERBS




VerbSentence
 = v:VerbClause {
   return AssembleVerb(v);
 }

Verbd
= v:Identifier '\'d' _ b:Value _ o:ParameterList? {
  return AssembleVerb([{ base:b, verb:'.'+v, param:(o?o[1]:'')}]);
}

VerbClause
= v:(VerbValue) _ o:ParameterList?  { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$'+(o?(','+o[1]):'') }]; 
     return [{ base:v[0], verb:v[1], param:(o?o[1]:'') }]
  }
  
 / v:(VerbValue) _ { 
     var composite=v[0]+v[1];
     if (composite=='^{super}') return [{ base:'^{super}', verb:'.call', param:'$' }]; 
     return [{ base:v[0], verb:v[1], param:'' }]
   }


VerbChain
 = CHAIN _ v:Expression _ c:VerbChainBlock {
   c[0].base=v;
   return AssembleVerb(c);
 }

VerbChainBlock
 = EOLs INDENT EOLs l:(VerbChainLine)+ DEDENT { 
     return l ;
   }
 
VerbChainLine
 = c:Comprehension _ EOLs {
     return {left:c[0], right: c[1]}
  }
 / i:Identifier _ o:ParameterList? _ EOLs {
     return {verb:'.'+i, param:(o?o[1]:''), test:true}; 
  }

NewObject
 = CREATE _ v:Value _ o:ParameterList?  { 
   return '$AI.create_op('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / SINGLETON _ v:Value _ o:ParameterList?  { 
   return '$AI.singleton_op('+v+',['+(o?o[1]:'undefined')+'])'; 
 }
 / NEW _ v:Value _ o:ParameterList? {
   return 'new '+v+'('+(o?o[1]:'')+')'; 
 }

VerbTerminal
 = &EOLs / &CBRACE / &')' 

ClassName
 = n:[a-zA-Z0-9_/]+ { return n.join('') }


/////////////////////////////////////////////

Number
 = Octal
 / Hexadecimal
 / Binary
 / v:NumericLiteral 'o' { return v*(Math.PI/180) } 
 / NumericLiteral

NumericLiteral
 = Scientific
 / Real
 / Integer
 / NaN

Binary
 = '0b' v:[0-1]+ {
   var r=0;
   for (var i=0; i<v.length; r=r*2+Number(v[i++]));
   return r.toString();
 }

Octal
 = '0o' v:[0-7]+ {
   var r=0;
   for (var i=0; i<v.length; r=r*8+Number(v[i++]));
   return r.toString();
 }

Hexadecimal
 = '0x' v:HexString { return v; }
 
HexString
 = v:(HexDigit)+ {
   var r=0;
   for (var i=0; i<v.length; r=r*16+v[i++]);
   return r;
 }

HexDigit
 = '0' { return 0; }
 / '1' { return 1; }
 / '2' { return 2; }
 / '3' { return 3; }
 / '4' { return 4; }
 / '5' { return 5; }
 / '6' { return 6; }
 / '7' { return 7; }
 / '8' { return 8; }
 / '9' { return 9; }
 / ('a'/'A') { return 10; }
 / ('b'/'B') { return 11; }
 / ('c'/'C') { return 12; }
 / ('d'/'D') { return 13; }
 / ('e'/'E') { return 14; }
 / ('f'/'F') { return 15; }

Scientific
 = r:(Real/Integer) 'e' x:Integer { return r+'e'+x }
 
Real
 = w:Integer DOT f:Fraction { return Number(w+'.'+f) }

Integer 
 = PositiveInteger
 / '-' v:PositiveInteger { return -v }

PositiveInteger
 = v:[0-9]+ { return parseInt(v.join('')) } 

Fraction
 = v:[0-9]+ { return v.join('') } 

SimpleStringLiteral
 = '\'' v:(EscapedChar/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringLiteral
 = MultiString
 / '\`' v:Bareline { return v }
 / '\'' v:(EscapedChar/StringTemplate/StringTickChar)* '\'' { return assembleLiteral(v) }
 / '\"' v:(EscapedChar/StringTemplate/StringQuoteChar)* '\"' { return assembleLiteral(v) }
 
StringTickChar
 = v:[^\'\n] { return [true,v] }

StringQuoteChar
 = v:[^\"\n] { return [true,v] }

MultiString
 = "'''" _ EOLs INDENT EOLs v:(v:Bareline EOL { return v} )* DEDENT &EOLs { return v.join("+'\\n'+"); } 


Bareline
 = !DEDENT v:(EscapedChar/StringTemplate/BarelineStringChar)* &EOLs { return assembleLiteral(v) }

BarelineStringChar
 = '^' { return [true, "\\"+"x5e"] }
 / v:[^\n] { return [true,v] }  
  
EscapedChar
 = '\\' "'" { return [true,'\\'+"'"] }
 / '\\' '"' { return [true,'\\'+'"'] }
 / '\\' '$' { return [true,'\\'+'$'] }
 / '\\' '&#123;' { return [true,'\\'+'&#123;'] }
 / '\\' '&#125;' { return [true,'\\'+'&#125;'] }
 / '\\' 'n' { return [true,'\\'+'n'] }
 / '\\' 'r' { return [true,'\\'+'r'] }
 / '\\' 't' { return [true,'\\'+'t'] }
 / '\\' 'b' { return [true,'\\'+'b'] }
 / '\\' 'f' { return [true,'\\'+'f'] }
 / '\\' 'x' a:[0-9a-fA-F] b:[0-9a-fA-F] { return [true,'\\'+'x'+a+b ] }
 / '\\' 'u' a:[0-9a-fA-F] b:[0-9a-fA-F] c:[0-9a-fA-F] d:[0-9a-fA-F] { return [true,'\\'+'u'+a+b+c+d] }
 / '\\' 'u' '{' a:[0-9a-fA-F]+ '}' { return [true,'\\'+'u{'+a.join('')+'}' ] }

StringTemplate
 = '${' _ v:Expression  '}' { return [false,v] }


__
 = Whitespace+

Sep
 = Whitespace
 / &[^a-zA-Z0-9_]
 
_
 = Whitespace*

Whitespace
 = EOL '...'
 / [\ ]
 
 
 
OptionalEOLs
 = EOL*
 
EOLs
 = EOL+

EOL
 = '//' [^\r\n]* CR
 / CR
 

CR
 = [\n\r]

OBRACE
 = '{'
 
CBRACE
 = '}'


 
__SOURCE = '__source'
__OFFSET = '__offset'
__COLUMN = '__column'
__LINE = '__line'

ADOPT = 'adopt'
ALL = 'all'
AND = 'and'
ANDB = 'andb'
ANY = 'any'
ARGUMENTS = 'arguments'
ARRAY = 'array'
AS = 'as'
ASC = 'asc'
AUDIT = 'audit'
BIND = 'bind'
BLANK = 'blank'
BY = 'by'
CATCH = 'catch'
CHAIN = 'chain'
COLLECT = 'collect'
COPY = 'copy'
CONCAT = 'concat'
CONTRACT = 'contract'
COUNT = 'count'
COUNTER = 'counter'
CREATE = 'create'
DEC = 'dec'
DEFAULT = 'default'
DELETE = 'delete'
DESC = 'desc'
DO = 'do'
ELSE = 'else'
EMPTY = 'empty'
ENUM = 'enum'
ENLIST = 'enlist'
ENTRAIT = 'entrait'
ERROR = 'error'
EXISTS = 'exists'
EXPECTS = 'expects'
FIELDS = 'fields'
FIRST = 'first'
FROM = 'from'
GET = 'get'
GIVEN = 'given'
HAS = 'has'
HIGHEST = 'highest'
INFINITY = 'Infinity'
INSTANCE = 'instance'
INTO = 'into'
INC = 'inc'
INHERIT = 'inherit'
ISNT = 'isnt'
ISNAN = 'isNaN'
IS = 'is'
ISOF = 'isof'
ITERATE = 'iterate'
ITERATOR = 'Iterator'
IT = 'it'
KEYS = 'keys'
KEY = 'key'
LAST = 'last'
LIMIT = 'limit'
LIST = 'list'
LOCAL = 'local'
LOWEST = 'lowest'
ME = 'me'
MY = 'my'
MAIN = 'main'
NaN = 'NaN'
NAND = 'nand'
NEW = 'new'
NOP = 'nop'
NOR = 'nor'
NOT = 'not'
NOTB = 'notb'
NUMBER = 'number'
NULL = 'null'
OBJECT = 'object'
OBSERVE = 'observe'
ORPHAN = 'orphan'
OR = 'or'
ORB = 'orb'
TRUE = 'true'
FALSE = 'false'
PROMISE = 'promise'
PROCESS = 'process'
REFERENCE = 'reference'
SELECT = 'select'
SELF = 'self'
SET = 'set'
SINGLETON = 'singleton'
SUM = 'sum'
SWAP = 'swap'
SUPER = 'super'
TASK = 'task'
THEN = 'then'
THRU = 'thru'
TRAITS = 'traits'
TRIAL = 'trial'
TRY = 'try'
TO = 'to'
TYPEOF = 'typeof'
UNBOUND = 'unbound'
UNDEFINED = 'undefined'
UPDATE = 'update'
USING = 'using'
VALUES = 'values'
VIA = 'via'
WITH = 'with'
XOR  = 'xor'
XORB  = 'xorb'

BANG = '!'
DOT = '.'
HASH = '#'
SEMI = ';'
COMMA = ','
COLON  = ':' !':' { return ':' }
INDENT = '%%INDENT%%'
DEDENT = '%%DEDENT%%'
EQUALS = '='
LPAREN = '('
RPAREN = ')'

 