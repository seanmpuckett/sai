////////////////////////////////////////////////////////////////////////////////////
//
// SAI.JS
//
// Framework for SAI language.
//
// Designed by Sean M Puckett
//

reference:
  FS from require 'fs'
  PATH from require 'path'
  SAILIB from require 'sai-library'
  DIRNAME ~__dirname
  INDENT '%%INDENT%%'
  DEDENT '%%DEDENT%%'
  
  ////////////////////////////////////////////////////////////////////////////////////
  //
  //  default configuration
  //
  //  VERBS
  //  You can add your own case-sensitive verbs by adding them to the _verbs_ array.
  //  Verbs should be text that compiles to an executable function.
  //
  //  PATHS
  //  The list of paths is searched when calling SAI.Require when using the default loader.
  //
  //  OPTIONS
  //  as shown
  //
  //  CONSTRUCTS
  //  Second-class language constructions for domain-specific extensions.
  //
  //  LOADER
  //  The Loader is a function that, when passed the name of an object, returns the SAI
  //  source code for that object. Change the loader if you want to load code from somewhere
  //  other than the disk.
  //

  DEFAULT_config:
    verbs:
      'debug' '$AI.debug_op'
      'require' 'require'
      'assert' '$AI.assert'
      'Error' 'Error'
      'Math' 'Math'
    constructs: blank // initialized later
    paths:
      DIRNAME + '/'
    options:
      speedometer false
      beautify true
    Loader:
      'default source loader linked later in file'


object SAI singleton


instance:
  prototypes blank
  sources blank
  protogens blank
  isas blank
  config undefined
  persist: globalcount 1

  protoConstructor undefined
  
  Parse undefined
  Beautify undefined
  

// Instantiate
//
// object wake-up
//

Instantiate task
  
  Clean
  
  
// Clean
//
// Initialize all caches
//

Clean task
  set 
    prototypes blank
    sources blank
    protogens blank
    isas blank
    config copy DEFAULT_config
    persist: globalcount 1

    protoConstructor task
      set
        @@Constructor task
          nop
        @@__tobelocked empty
        @@__tobefrozen empty
        @@__contracts empty
        @@__unverified true
        @@isof blank
      return @@
      
    Parse from GetParser

    config.Loader from GetSourceFromPaths.bind me
    SAILIB.import from Require.bind me
    SAILIB.create_op from Create.bind me

    config.constructs:

      promising:
        repeats false
        clauses: 
          promising: #verb, #block
          then: #verb, #block
          catch: #verb, #block
          finally: #verb, #block
          all: #exprs, #none
          any: #exprs, #none
          resolving: #exprs, #none
          rejecting: #exprs, #none
          finalizing: #none
        handler bind PromisingConstruct

      state:
        repeats true
        clauses:
          state: #exprblock
        handler bind StateConstruct


///////////////////////////////
//
//  CONSTRUCT HANDLERS
//

//  STATE
//
StateConstruct task as work

  set
    tools to work's tools
    header to '''
      var ^{temp}=function (){
      var _goto,_then;
      var $states={

    header from tools.replacer header, fields temp undefined

    trailer '''
      }
        var $getstatefn=function(state) {
          return $AI.assert($states[state],"SAI runtime: STATE "+state+" does not exist; available states are "+$AI.keys_op($states).join(','));
        }
        _goto=function(state){
          var statefn=$getstatefn(state);
          var fn=undefined;
          var l=arguments.length, args=new Array(l-1);
          for (var li=1; li<l; li++) args[li-1]=arguments[li];
          fn=function(){statefn.apply(undefined,args)};
          setImmediate(fn);
        };
        _then=function(state){
          var statefn=$getstatefn(state);
          return function(){statefn.apply(undefined,arguments);};
        };
        _goto(${work's clauses.0's args.1});
      }();    

    names blank
    states empty

  each work's clauses
    switch .type
      case 'state.exprblock'
        set name .args.1
        
        if names\name
          return: error 'SAI compile: duplicate state ${name} in STATE construct'
        inc names\name
        
        set block from tools.tasker:
          'as' .args.2
          block .args.3
          kind 'function'
        push'd states "${name}:${block}"

  tools.addlocal '_goto'
  tools.addlocal '_then'
  
  set body to "${header}${join'd states ','}${trailer}"
  return: body body




//  PROMISING
//
PromisingConstruct task as work

  with (work's clauses last).clause
    unless it is 'finally' or it is 'catch' or it is 'rejecting' or it is 'finalizing'
      return: error "SAI compiler: final clause in PROMISING must be CATCH, FINALLY, REJECTING or FINALIZING, not ${toUpperCase'd it}"

  set tasker to task  
    set options:
      'as' $args.1
      block $args.2
      kind 'function'
      execute $execute
    if $ispromise
      set options update:
        preface 'return new Promise(function($_resolve,$_reject) {'
        postface 'if ($_resolve) return $_resolve();})'
    return from work's tools.tasker options

  set body 'var $tthen=function(t){if (!t || !t.then) throw new Error("SAI Runtime: THEN should be followed by a verb returning a promise (or an indented block of code)."); return t;};\n'
  
  each work's clauses
    switch .type

      case 'promising.verb'
        set body + "$tthen(${.args.1})"

      case 'promising.block'
        set block from tasker: args .args, #ispromise, #execute
        set body + "(${block})"

      case 'then.verb'
        set body + ".then(function(p){return $tthen(${.args.1});})"

      case 'then.block'
        set block from tasker: args .args, #ispromise
        set body + ".then(${block})"

      case 'catch.verb'
        set body + ".catch(function(p){return $tthen(${.args.1});})"

      case 'catch.block'
        set block from tasker: args .args
        set body + ".catch(${block})"

      case 'finally.verb'
        set body + ".finally(function(p){return $tthen(${.args.1});})"

      case 'finally.block'
        set block from tasker: args .args
        set body + ".finally(${block})"

      case 'resolving.exprs'
        set body + ".then(function(p){return $_resolve(${.args.1.1});})"
        
      case 'resolving.none'
        set body + ".then(function(){return $_resolve.apply(null,arguments);})"
        
      case 'rejecting.exprs'
        set body + ".catch(function(p){return $_reject(${.args.1.1});})"

      case 'rejecting.none'
        set body + ".catch(function(){return $_reject.apply(null,arguments);})"
        
      case 'finalizing.none'
        set body + ".then(function(){return $_resolve.apply(null,arguments);})"
        set body + ".catch(function(){return $_reject.apply(null,arguments);})"

      case 'all.exprs'
        set body + ".then(function(p){return Promise.all(${.args.1.1});})"

      case 'any.exprs'
        set body + ".then(function(p){return Promise.any(${.args.1.1});})"

      default
        return: error "SAI compiler: PROMISING construct unhandled type ${.type}"


  set body + ';\n'
  return: body body

    
//
//
////////////////////////////////////

  
// Dedenter
//
// Converts semantic whitespace into braces for easier parsing.
//

Dedenter task given src

  set 
    rawlines from src.split /\r\n|[\r\n\u0085\u2028\u2029]/
    heredocstate 0
    heredepth 0
    indent: 0
    lines empty

    Context task given lineno
      set result 'near line ${lineno}:\n'
      count lineno-3 to lineno+4
        exists rawlines\counter
          set result + '${counter}:${counter is lineno ?? '->' :: '  '} ${it}\n'
      return result
    

  if '#!' is (rawlines.0 limit 0, 2)
    shift'd rawlines
    
  ply rawlines as line, lineno
  
    set trail line.length
    while ' ' is line[trail-1] .. dec trail
    set line (self limit 0, trail)
    
    set depth 0
    while ' ' is line\depth .. inc depth
    set trimmed (line limit depth, undefined)
    
    set isComment '//' is (trimmed limit 0, 2)
    set isBlank 0 is trimmed's length
    
    unless isComment or isBlank
      set heredoc "'''" is (line limit -3)

      switch heredocstate
        case 0
          if heredoc
            set heredocstate 1
            set heredepth depth
          if depth > indent.0
            unshift'd indent depth
            push'd lines INDENT
        case 1
          if depth <= heredepth
            throw new Error "SAI: multi-line quotes must be indented ${from Context lineno}"
          push'd lines INDENT
          unshift'd indent depth
          set heredepth depth
          set heredocstate 2
        case 2
          if depth < heredepth
            set heredocstate 0
          else if depth > heredepth
            set trimmed (line limit heredepth, undefined)
      if depth < indent.0
        while depth < indent.0
          push'd lines DEDENT
          shift'd indent 
        if depth isnt indent.0
          throw new Error "SAI: incorrect indentation ${from Context lineno}"

    push'd lines trimmed
    
  while shift'd indent
    push'd lines DEDENT

  push'd lines ''
  set lines join'd self '\n'

  return lines
  
  
// WrapExtract
//
// Extracts context from a string
//

WrapExtract task given source, location
  return source.substring(location-100,location)+"<HERE>"+source.substring(location,location+100)
  
  
// Contextualize
//
// transforms a segment of parse-ready code back into indented for inspection
//

Contextualize task given source, offset
  set
    context from WrapExtract source, offset
    lines from context.split '\n'

    ind 0
    minind 0
    newcontext ''
    
  ply lines as line
    if line is INDENT .. inc ind
    else if line is DEDENT .. dec ind
    set minind ?< ind
  set ind to - minind

  ply lines as line
    if line is INDENT .. inc ind
    else if line is DEDENT .. dec ind
    else 
      set newcontext + (repeat'd '  ' ind) + line + '\n'
      
  return newcontext



// GetParser
//
// Returns a function that will parse SAI code into Javascript
//
// If the grammar file (saigrammar.peg) is newer than the current parser
// (saigrammar.js), uses PEGjs to recompile the grammar and save the parser.
//

GetParser task

  try
  
    set grammarFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.peg'
    set parserFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.js'

    if (not FS.existsSync(parserFile))
    ... or (FS.statSync(grammarFile).mtime > FS.statSync(parserFile).mtime) 

      set 
        PEG require('pegjs')
        grammar FS.readFileSync(grammarFile).toString()
        
        mainParser from PEG.generate grammar, fields
          allowedStartRules list startFile, startExpression
          output 'source'
          optimize 'size'
          trace 0
          cache true
          
      FS.writeFileSync parserFile, mainParser

    else
      set mainParser FS.readFileSync(parserFile).toString()

  catch
      
    set msg '''
      SAI: Could not compile saigrammar.peg.
      Is pegjs available? Is there a syntax error in the grammar?

      ${error}
    
    if grammar
      set msg from WrapExtract grammar, error.location.start.offset
        
    throw new Error msg
    
  set mainParser from ~eval mainParser
  
  return task given rawsource, bound, fn
  
    set
      rawsource + '\n\n'
      source from Dedenter rawsource
  
    try
      set js from mainParser.parse source, fields
        startrule fn ?? 'startFile' :: 'startExpression'
        bound bound
        globals config.verbs
        constructs config.constructs
        persist persist
        filename fn
    
    catch
      set location to undefined
      if error.location
        set location to trial.start.offset
      if  match'd error.message /at:([0-9]+)/ 
        set location to number trial.1 

      if location
        throw new Error '''
          SAI: Syntax error <HERE> in ${~JSON.stringify(fn)}
          
          ${Contextualize(source, location)}
          
          ${error.message}
          
      else
        throw new Error '''
          SAI: Error creating prototype:
          
          ${error.toString()}
          
    if config.options.beautify
      set js from Beautify js, fields
        indent_size 2
        preserve_newlines false
        brace_style 'collapse'
    
    return js

  
// Parse
//
// Build and bind parser
//
// (see Clean)


// GetSourceFromPaths -> config.Loader
//
// The basic loader which fetches SAI source by name from the provided list of 
// directories.
//

GetSourceFromPaths task given name

  ply config's paths as path
    ply array '.sai', ''; as extension
      set filename from PATH.join path, name+extension
      try
        return:
          success true
          source toString'd FS.readFileSync(filename)
          context:
            name name
            loader 'SAI.GetSourceFromPaths'
            path filename
            mtime FS.statSync(filename).mtime
            fetched new ~Date
      catch
        nop
          
  return:
    success false
    context '''
      SAI.GetSourceFromPaths: cannot load ${name}
      Check paths: ${config.paths.join(';')}

      
// Compile
//
// Create a function that compiles parsed SAI source, binding the variables
// needed to integrate necessary scope and the SAI runtime library.
//

Compile task given source
  return new ~Function 'prototype','options','require','$AI','__dirname', source


// ProtoGen
//
// Create a fully scoped Javascript prototype for a single object (ignoring inheritance)
//

GetProtogen task given name
  
  set protogens\name default from task
    set s1 new ~Date
    set load from config's Loader name
    unless load.success
      throw new Error `SAI.GetProtogen: Could not load object ${name}, reason given: ${load.context}'
    set source from Parse load's source, undefined, load's context
    set source 'var __context=${~JSON.stringify(load.context)};\n${source}'
    set protogen from Compile source
    //debug source
    unless protogen
      throw new Error 'SAI.GetProtogen: Error in generated code ${name}'
    set s2 new ~Date
    if config's options's speedometer
      debug 'SAI: Compiled ${name} in ${s2-s1}ms.'
    set sources\name source
    return protogen

  return protogens\name
  
  
// Expression
//
// Compile a single SAI expression, out of context except for the runtime library.
//

Expression task given source
  set js 'return ${Parse(source, undefined, undefined)}'
  return Compile(js)(@@, blank, ~require, SAILIB, DIRNAME)


// GetAncestors
//
// Build a list of objects that the given object depends on
//

GetAncestors task given name
  set
    heritage array name
    ancestors blank
    nodupes blank
    
  while shift'd heritage as leaf
    unless nodupes\leaf
      set nodupes\leaf to true
      set obj to new protoConstructor name
      set protogen from GetProtogen leaf
      set opts: name leaf
      protogen obj, opts, ~require, SAILIB, DIRNAME
      obj.Constructor
      unless obj.isa
        throw new Error 'SAI GetPrototype: object loaded as ${leaf} does not have an isa type identifier.'
      with obj.__inherits
        set ancestors\leaf it
        ply it
          heritage.push it

  return ancestors
  

// GetPrototype
// 
// Given a name, locate all ancestors, create all prototypes,
// initialize primary prototype object, describe properties,
// save the result in a cache (SAI.prototypes) and return it.
//

GetPrototype task given name, bindings
  set prototypes\name default from task
    set ancestors from GetAncestors name
    set prototype to new protoConstructor name
    set adopt to task given name
      ply ancestors\name
        adopt it
      set protogen from GetProtogen name
      protogen prototype, fields name name;, require, SAILIB, DIRNAME
    
    adopt name
    
    ~Object.defineProperty prototype, 'isa', :enumerable false, value prototype.isa;
    if isas[prototype.isa]
      throw new Error 'SAI: object defined by ${name} has a duplicate.isa type ${prototype.isa} identical to ${isas[prototype.isa]}'
    set isas[prototype.isa] name

    SAILIB.finalizePrototype prototype
    return prototype
    
  return prototypes\name


// GetSource
//
// Get full native JS source code for an object, by name.
//

GetSource task as name
  set ancestors from GetAncestors name
  set islib to 0 <= name.indexOf('sailib')

  if islib
    debug 'Building SAILIB specifically to refer to iteself; not requiring sai-library.'

  set source '''
    #!/usr/bin/env node
    
    \/\/ Javascript source for ${name} transipled by SAI
    \/\/
    
    "use strict";
    
    var prototype=new function() ${'{'}
    this.Constructor=function()${'{}'};
    this.__tobelocked=[];
    this.__tobefrozen=[];
    this.__contracts=[];
    this.__unverified=true;
    this.isof=${'{}'};
    return this;
    ${'}'}();
    var $AI=${islib ?? 'prototype' :: 'require("sai-library")'};
    // Generated code follows
    
  set adopt task given name
    ply ancestors\name
      adopt it
    set source + sources\name + '\n'
  
  adopt name

  set source + '''
    // End of generated code
    
    $AI.finalizePrototype(prototype);
    if (prototype.isof[prototype.isa].type === "singleton") { prototype.Constructor(); prototype.Instantiate(); ${'}'}
    var result=prototype.isof[prototype.isa].type === "main" ? prototype.constructor() : prototype;
    exports=result; try { module.exports=result; ${'}'} catch(e) ${'{}'};
    return result;
    
  return source


// Require
//
// Return a prototype object by name
//

Require task given name
  exists from GetPrototype name
    exists .constructor
      return it
  throw new Error 'SAI.Require: do not know how to create object ${name}'
  


// Create
//
// Create an object by name (an alternative to using new on what Require gives you)
//

Create task given name, parameters
  exists from GetPrototype name
    set obj from ~Object.create it
    if obj.Constructor .. obj.Constructor
    if obj.Instantiate .. obj.Instantiate.apply obj, parameters
    return obj
  throw new Error 'SAI.Create: do not know how to create object ${name}'


// Configure
//
// Update configuration settings individually or as a group
//

Configure task given c
  exists c.paths
    set config.paths it
  exists c.verbs
    set config.verbs update it
  exists c.options
    set config.options update it
  exists c.constructs
    set config.constructs update it
  exists c.Loader
    set config.Loader it
  
  if config.options.beautify
    set Beautify require('js-beautify').js_beautify
