////////////////////////////////////////////////////////////////////////////////////
//
// SAI.JS
//
// Framework for SAI language.
//
// Designed by Sean M Puckett
//

reference:
  FS from require 'fs'
  PATH from require 'path'
  SAILIB from require 'sai-library'
  DIRNAME ~__dirname
  INDENT '%%INDENT%%'
  DEDENT '%%DEDENT%%'
  
  ////////////////////////////////////////////////////////////////////////////////////
  //
  //  default configuration
  //
  //  VERBS
  //  You can add your own case-sensitive verbs by adding them to the _verbs_ array.
  //  Verbs should be text that compiles to an executable function.
  //
  //  PATHS
  //  The list of paths is searched when calling SAI.Require when using the default loader.
  //
  //  OPTIONS
  //  as shown
  //
  //  CONSTRUCTS
  //  Second-class language constructions for domain-specific extensions.
  //
  //  LOADER
  //  The Loader is a function that, when passed the name of an object, returns the SAI
  //  source code for that object. Change the loader if you want to load code from somewhere
  //  other than the disk.
  //

  DEFAULT_config:
    verbs:
      'debug' '$AI.debug_op'
      'require' 'require'
      'assert' '$AI.assert'
      'Error' 'Error'
      'Math' 'Math'

    constructs blank // initialized later
    pipers blank // initialized later
    paths:
      DIRNAME + '/'
    options:
      speedometer false
      beautify true
    Loader:
      'default source loader linked later in file'

  //// Built-in constructs

  CONSTRUCTS list 
    StateC
    PromisingC
    ReturnC
    IterateC
    TryCatchC
    IfElseC
    SwitchC
    MiscC
    ListsP
    QueryP
    CrudP
    Keywords




object SAI singleton


instance:
  prototypes blank
  sources blank
  protogens blank
  isas blank
  config undefined
  persist: globalcount 1

  mainParser undefined

  protoConstructor undefined
  
  Parse undefined
  Beautify undefined


given:
  validSyntax: 
    
    constructs:
      'block'         '[indent code block]'
      'exprout'       '[expr] (AS var1, var2...)'
      'exproutblock'  '[expr] (AS var1, var2...) [indent code block]'
      'exprs'         '[expr1 (, expr2, ...)]'
      'exprsblock'    '[expr1 (, expr2, ...)] [indent code block]'
      'exprsoutblock' '[expr1 (, expr2, ...)] (AS var1, var2, ...) [indent code block]'
      'exprsusing'    '[expr1 (, expr2, ...)] USING [function reference]'
      'exprusing'     '[expr] USING [function reference]'
      'none'          ' '
      'outblock'      '(AS var1, var2...) [indent code block]'
      'rvalue'        '[variable]'
      'verb'          '[verb sentence]'
      
    pipers:
      'expr'          '[expr]'
      'exprs'         '[expr1 (, expr2, ...)]'
      'none'          ' '
      'outblock'      '(AS var1, var2...) [indent code block]'
      'use'           'USING [function reference]'
      'valexpr'       '[value] [expr]'
      'valuse'        '[value] USING [function reference]'
      'valoutblock'   '[value] (AS var1, var2...) [indent code block]'

    globals: blank
    keywords: blank
    operators: blank
    pronouns: blank
    syntax: blank


// Instantiate
//
// object wake-up
//

Instantiate task
  
  Clean
  
  
// Clean
//
// Initialize all caches
//

Clean task
  set 
    prototypes blank
    sources blank
    protogens blank
    isas blank
    config copy DEFAULT_config
    persist: globalcount 1

    protoConstructor task
      set
        @@Constructor task
          nop
        @@__tobelocked empty
        @@__tobefrozen empty
        @@__contracts empty
        @@__unverified true
        @@isof blank
      return @@
      
    Parse from GetParser

    config.Loader bind GetSourceFromPaths
    SAILIB.import bind Require
    SAILIB.create_op bind Create


  IntegrateConstructs

  
IntegrateConstructs task

  set requiredElements to:
    constructs:
      'clauses' 'clauses list'
      'repeats' 'repeats flag'
      'handler' 'handler function'
    pipers:
      'clauses' 'clauses list'
      'handler' 'handler function'
    
  
  set fail to task given msg
    throw new Error 'SAI Construct Manager: manifest for ${file}/${category}/${constructName}${msg}'
    
  ply CONSTRUCTS as file
    try
      set fn to "./"+file
      set implementation from require fn
      set implementation.SAI @ // this is for introspection in Keywords.sai
      set manifest to implementation's manifest
      
      // a little validation
      each manifest as library, category
        unless validSyntax\category
          fail ' unsupported category type'
        
        each library as construct, constructName
          each requiredElements\category as description, element
            unless exists construct\element
              fail ' is missing ${description}.'
          if exists construct.clauses and not exists construct.clauses\constructName
            fail ' is missing a clause definition for itself'
          if ?requiredElements\category.clauses
            each construct.clauses as requestedSyntax, clauseName
              each requestedSyntax as val, type
                unless validSyntax\category\type
                  fail '/${clauseName} asks for illegal syntax "${type}"'
            else
              fail ' has no clauses defined'
        set config\category | update library
          
    catch
      debug error
      

Document task
  return from DocumentConstructs


DocumentConstructs task 

  set documents blank
  set prefix:
    'pipers':
       main '... | '
       aux '(optional) '

  set seealso blank

  ply CONSTRUCTS as file
    set 
      fn to "./"+file
      implementation from require fn 
      implementation.SAI @ // this is for introspection in Keywords.sai
      manifest to implementation's manifest
      docs to implementation's docs 
    
    each manifest as library, category
      set documents\category default blank
        
      each library as construct, constructName

        set doc to ?docs\category\constructName or blank
        set synref empty
        
        each construct.clauses as requestedSyntax, clauseName
          set seealso\clauseName default empty
          push'd seealso\clauseName array (doc.category ? category), constructName, doc.title ? clauseName
          each requestedSyntax as val, type
            set sub to clauseName is constructName ?? 'main' :: 'aux'
            push'd synref '${?prefix\category\sub ? ''}${clauseName} ${validSyntax\category\type}'
          push'd synref ''
          
        set page:
          name constructName
          subtitle 'subtitle'
          summary 'summary'
          synref join'd synref '\n'
          detail 'detail'

        set documents\category\constructName page | update doc
            
  return:
    documents documents
    references seealso
  
  
  
// Dedenter
//
// Converts semantic whitespace into braces for easier parsing.
//

Dedenter task given src

  set 
    rawlines from src.split /\r\n|[\r\n\u0085\u2028\u2029]/
    heredocstate 0
    heredepth 0
    indent: 0
    offset 1
    lines empty

    Context task given lineno
      set result 'near line ${lineno}:\n'
      count lineno-3, lineno+4
        exists rawlines\counter
          set result + '${counter}:${counter is lineno ?? '->' :: '  '} ${it}\n'
      return result
    

  if '#!' is (rawlines.0 | limit 0, 2)
    shift'd rawlines
    inc offset
      
  ply rawlines as line, lineno
  
    if line.indexOf('\t') >= 0
      throw new Error "SAI Compiler: tab characters are not supported in source files ${from Context lineno}"

    set trail line.length
    while ' ' is line[trail-1] .. dec trail
    set line (self | limit 0, trail)
    
    set depth 0
    while ' ' is line\depth .. inc depth
    set trimmed (line | limit depth, undefined)
    
    set isComment '//' is (trimmed | limit 0, 2)
    set isBlank 0 is trimmed's length
    
    unless isComment or isBlank
      set heredoc "'''" is (line | limit -3)

      if heredocstate is 2
        if depth < heredepth
          set heredocstate 0

      if heredocstate is 1
        if depth <= heredepth
          throw new Error "SAI: multi-line quotes must be indented ${from Context lineno}"
        push'd lines INDENT
        unshift'd indent depth
        set heredepth depth
        set heredocstate 2
        
      if heredocstate is 0
        if heredoc
          set heredocstate 1
          set heredepth depth
        if depth > indent.0
          unshift'd indent depth
          push'd lines INDENT

      if depth < indent.0
        while depth < indent.0
          push'd lines DEDENT
          shift'd indent 
        if depth isnt indent.0
          throw new Error "SAI: incorrect indentation ${from Context lineno}"

    unless isComment and heredocstate and depth<heredepth
      if heredocstate and depth > heredepth
        set trimmed (line | limit heredepth, undefined)
      push'd lines '@${lineno+offset}:${trimmed}'
    
  while shift'd indent
    push'd lines DEDENT

  unshift'd lines ''
  push'd lines ''
  set lines join'd self '\n'

  return lines
  
  
// WrapExtract
//
// Extracts context from a string
//

WrapExtract task given source, location
  return source.substring(location-100,location)+"<HERE>"+source.substring(location,location+100)
  
  
// Contextualize
//
// transforms a segment of parse-ready code back into indented for inspection
//

Contextualize task given source, offset
  set linenorex /^\@([0-9]+):(.*)/

  set
    context from WrapExtract source, offset
    lines from context.split '\n'
    ind 0
    minind 0
    newcontext ''
    
  ply lines as line
    if line is INDENT .. inc ind
    elsif line is DEDENT .. dec ind
    set minind ?< ind
    
  set ind to - minind

  ply lines as line
    if line is INDENT .. inc ind
    elsif line is DEDENT .. dec ind
    else 
      set ln from linenorex.exec line
      if ln
        set newcontext + ln.1 + ': ' + (repeat'd '  ' ind) + ln.2 + '\n'
      else
        set newcontext + (repeat'd '  ' ind) + line + '\n'
      
  return newcontext



// GetParser
//
// Returns a function that will parse SAI code into Javascript
//
// If the grammar file (saigrammar.peg) is newer than the current parser
// (saigrammar.js), uses PEGjs to recompile the grammar and save the parser.
//

GetParser task

  try
  
    set grammarFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.peg'
    set parserFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.js'

    if (not FS.existsSync(parserFile))
    ... or (FS.statSync(grammarFile).mtime > FS.statSync(parserFile).mtime) 

      set 
        PEG require('pegjs')
        grammar FS.readFileSync(grammarFile).toString()
        
        mainParser from PEG.generate grammar, fields
          allowedStartRules list startFile, startExpression
          output 'source'
          optimize 'size'
          trace 0
          cache true
          
      FS.writeFileSync parserFile, mainParser

    else
      set mainParser FS.readFileSync(parserFile).toString()

  catch
      
    set msg '''
      SAI: Could not compile saigrammar.peg.
      Is pegjs available? Is there a syntax error in the grammar?

      ${error}
    
    if grammar
      set msg from WrapExtract grammar, error.location.start.offset
        
    throw new Error msg
    
  set mainParser from ~eval mainParser
  
  return task given rawsource, bound, fn
  
    set
      rawsource + '\n\n'
      source from Dedenter rawsource
  
    try
      set opts fields
        startrule fn ?? 'startFile' :: 'startExpression'
        bound bound
        globals config.verbs
        constructs config.constructs
        pipers config.pipers
        persist persist
        filename fn
        failures undefined
        
      set js from mainParser.parse source, opts

      if opts.failures
        throw new Error opts.failures
    
    catch
      set meta to fn | total '  ${toUpperCase'd key}: ${it}\n'
      
      set location to undefined
      if error.location
        set location to trial.start.offset
      if  match'd error.message /at:([0-9]+)/ 
        set location to number trial.1 

      exists location
        set error.message to '''
          SAI: Syntax error <HERE> in\n${meta}
          
          ${Contextualize(source, location)}
          
          ${error.message}
          
      else
        set error.message to '''
          SAI: Error creating prototype in\n${meta}
          
          ${error.message}
          
      throw error
      
    if config.options.beautify
      set js from Beautify js, fields
        indent_size 2
        preserve_newlines false
        brace_style 'collapse'
    
    return js

  
// Parse
//
// Build and bind parser
//
// (see Clean)


// GetSourceFromPaths -> config.Loader
//
// The basic loader which fetches SAI source by name from the provided list of 
// directories.
//

GetSourceFromPaths task given name

  ply config's paths as path
    ply array '.sai', ''; as extension
      set filename from PATH.join path, name+extension
      try
        return:
          success true
          source toString'd FS.readFileSync(filename)
          context:
            name name
            loader 'SAI.GetSourceFromPaths'
            path filename
            mtime FS.statSync(filename).mtime
            fetched new ~Date
      catch
        nop
          
  return:
    success false
    context '''
      SAI.GetSourceFromPaths: cannot load ${name}
      Check paths: ${config.paths.join(';')}

      
// Compile
//
// Create a function that compiles parsed SAI source, binding the variables
// needed to integrate necessary scope and the SAI runtime library.
//

Compile task given source
  try
    return new ~Function 'prototype','options','require','$AI','__dirname', source
  catch
    debug "ERROR IN HERE"
    debug source
    debug error

// ProtoGen
//
// Create a fully scoped Javascript prototype for a single object (ignoring inheritance)
//

GetProtogen task given name
  
  set protogens\name default from task
    set s1 new ~Date
    set load from config's Loader name
    unless load.success
      throw new Error 'SAI.GetProtogen: Could not load object ${name}, reason given: ${load.context}'
    set source from Parse load's source, undefined, load's context
    set source 'var __context=${~JSON.stringify(load.context)};\n${source}'
    set protogen from Compile source
    //debug source 
    unless protogen
      throw new Error 'SAI.GetProtogen: Error in generated code ${name}'
    set s2 new ~Date
    if config's options's speedometer
      debug 'SAI: Compiled ${name} in ${s2-s1}ms.'
    set sources\name source
    return protogen

  return protogens\name
  
  
// Expression
//
// Compile a single SAI expression, out of context except for the runtime library.
//

Expression task given source
  set js 'return ${Parse(source, undefined, undefined)}'
  return Compile(js)(@@, blank, ~require, SAILIB, DIRNAME)


// GetAncestors
//
// Build a list of objects that the given object depends on
//

GetAncestors task given name
  set
    heritage array name
    ancestors blank
    nodupes blank
    
  while shift'd heritage as leaf
    unless nodupes\leaf
      set nodupes\leaf to true
      set obj to new protoConstructor name
      set protogen from GetProtogen leaf
      set opts: name leaf
      protogen obj, opts, ~require, SAILIB, DIRNAME
      obj.Constructor
      unless obj.isa
        throw new Error 'SAI GetPrototype: object loaded as ${leaf} does not have an isa type identifier.'
      with obj.__inherits
        set ancestors\leaf it
        ply it
          heritage.push it

  return ancestors
  

// GetPrototype
// 
// Given a name, locate all ancestors, create all prototypes,
// initialize primary prototype object, describe properties,
// save the result in a cache (SAI.prototypes) and return it.
//

GetPrototype task given name, bindings
  set prototypes\name default from task
    set ancestors from GetAncestors name
    set prototype to new protoConstructor name
    set adopt to task given name
      ply ancestors\name
        adopt it
      set protogen from GetProtogen name
      protogen prototype, fields name name;, require, SAILIB, DIRNAME
    
    adopt name
    
    ~Object.defineProperty prototype, 'isa', :enumerable false, value prototype.isa;
    if isas[prototype.isa]
      throw new Error 'SAI: object defined by ${name} has a duplicate.isa type ${prototype.isa} identical to ${isas[prototype.isa]}'
    set isas[prototype.isa] name

    SAILIB.finalizePrototype prototype
    return prototype
    
  return prototypes\name


// GetSource
//
// Get full native JS source code for an object, by name.
//

GetSource task as name
  set ancestors from GetAncestors name
  set islib to 0 <= name.indexOf('sailib')

  if islib
    debug 'Building SAILIB specifically to refer to iteself; not requiring sai-library.'

  set source '''
    #!/usr/bin/env node
    
    // Javascript source for ${name} transpiled by SAI
    //
    
    "use strict";
    
    var prototype=new function() {
      this.Constructor=function(){};
      this.__tobelocked=[];
      this.__tobefrozen=[];
      this.__contracts=[];
      this.__unverified=true;
      this.isof={};
      return this;
    }();
    var $AI=${islib ?? 'prototype' :: 'require("sai-library")'};
    // Generated code follows
    
  set adopt task given name
    ply ancestors\name
      adopt it
    set source + sources\name + '\n'
  
  adopt name

  set source + '''
    // End of generated code
    
    $AI.finalizePrototype(prototype);
    if (prototype.isof[prototype.isa].type === "singleton") { prototype.Constructor(); prototype.Instantiate(); ${'}'}
    var result=prototype.isof[prototype.isa].type === "main" ? prototype.constructor() : prototype;
    exports=result; try { module.exports=result; ${'}'} catch(e) ${'{}'};
    return result;
    
  return source


// Require
//
// Return a prototype object by name
//

Require task given name
  exists from GetPrototype name
    exists .constructor
      return it
  throw new Error 'SAI.Require: do not know how to create object ${name}'
  


// Create
//
// Create an object by name (an alternative to using new on what Require gives you)
//

Create task given name, parameters
  exists from GetPrototype name
    set obj from ~Object.create it
    if obj.Constructor .. obj.Constructor
    if obj.Instantiate .. obj.Instantiate.apply obj, parameters
    return obj
  throw new Error 'SAI.Create: do not know how to create object ${name}'


// Configure
//
// Update configuration settings individually or as a group
//

Configure task given c
  exists c.paths
    set config.paths it
  exists c.verbs
    set config.verbs | update it
  exists c.options
    set config.options | update it
  exists c.constructs
    set config.constructs | update it
  exists c.Loader
    set config.Loader it
  
  if config.options.beautify
    set Beautify require('js-beautify').js_beautify
