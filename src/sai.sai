////////////////////////////////////////////////////////////////////////////////////
//
// SAI.JS
//
// Framework for SAI language.
//
// Designed by Sean M Puckett
//

reference:
  FS from require 'fs'
  PATH from require 'path'
  SAILIB from require 'sai-library'
  DIRNAME ~__dirname
  
  ////////////////////////////////////////////////////////////////////////////////////
  //
  //  default configuration
  //
  //  VERBS
  //  You can add your own case-sensitive verbs by adding them to the _verbs_ array.
  //  Verbs should be text that compiles to an executable function.
  //
  //  PATHS
  //  The list of paths is searched when calling SAI.Require when using the default loader.
  //
  //  OPTIONS
  //  as shown
  //
  //  LOADER
  //  The Loader is a function that, when passed the name of an object, returns the SAI
  //  source code for that object. Change the loader if you want to load code from somewhere
  //  other than the disk.
  //

  DEFAULT_config:
    verbs:
      'debug' '$AI.debug_op'
      'require' 'require'
      'assert' '$AI.assert'
    paths:
      DIRNAME + '/'
    options:
      speedometer false
      beautify true
    Loader:
      'default source loader linked later in file'


object SAI singleton

// Instantiate
//
// object wake-up
//

Instantiate task
  
  my Clean
  
  
// Clean
//
// Initialize all caches
//

Clean task
  set 
    my prototypes blank
    my source blank
    my protogens blank
    my isas blank
    my config copy DEFAULT_config
    my persist: globalcount 1
    my proto task
      orphan
      set
        my Constructor task
          nop
        my __tobelocked empty
        my __tobefrozen empty
        my __contracts empty
        my __unverified true
        my isof blank
      return me
      
    my Parse from my GetParser

    my config.Loader task 
      return from my GetSourceFromPaths.apply me, arguments
    SAILIB.import task
      return from my Require.apply me, arguments
    SAILIB.create_op task 
      return from my Create.apply me, arguments

  
// Dedenter
//
// Converts semantic whitespace into braces for easier parsing.
//

Dedenter task given src

  set 
    rawlines from src.split /\r\n|[\r\n\u0085\u2028\u2029]/
    heredocstate 0
    heredepth 0
    indent: 0
    lines empty

    Context task given lineno
      set result 'near line ${lineno}:\n'
      count lineno-3 to lineno+4
        exists rawlines[counter]
          set result + '${counter}:${counter is lineno ?? '->' :: '  '} ${it}\n'
      return result
    
  if '#!' is (rawlines.0 limit 0, 2)
    shift'd rawlines
    
  ply rawlines as line, lineno
  
    set trail line.length
    while ' ' is line[trail-1] .. dec trail
    set line (self limit 0, trail)
    
    set depth 0
    while ' ' is line\depth .. inc depth
    set trimmed (line limit depth, undefined)
    
    set isComment '//' is (trimmed limit 0, 2)
    set isBlank 0 is trimmed's length
    
    unless isComment or isBlank
      set heredoc "'''" is (line limit -3)

      switch heredocstate
        case 0
          if heredoc
            set heredocstate 1
            set heredepth depth
          if depth > indent.0
            unshift'd indent depth
            push'd lines '{'
        case 1
          if depth <= heredepth
            throw new ~Error "SAI: multi-line quotes must be indented ${from Context lineno}"
          push'd lines '{'
          unshift'd indent depth
          set heredepth depth
          set heredocstate 2
        case 2
          if depth < heredepth
            set heredocstate 0
          else if depth > heredepth
            set trimmed (line limit heredepth, undefined)
      if depth < indent.0
        while depth < indent.0
          push'd lines '}'
          shift'd indent 
        if depth isnt indent.0
          throw new ~Error "SAI: incorrect indentation ${from Context lineno}"

    push'd lines trimmed
    
  while shift'd indent
    push'd lines '}'

  push'd lines ''

  return join'd lines '\n'
  
  
// WrapExtract
//
// Extracts context from a string
//

WrapExtract task given source, location
  return source.substring(location-100,location)+"<HERE>"+source.substring(location,location+100)
  
  
// Contextualize
//
// transforms a segment of parse-ready code back into indented for inspection
//

Contextualize task given source, offset
  set
    context from my WrapExtract source, offset
    lines from context.split '\n'

    ind 0
    minind 0
    newcontext ''
    
  ply lines as line
    if line is '{' .. inc ind
    else if line is '}' .. dec ind
    set minind ?< ind
  set ind to - minind

  ply lines as line
    if line is '{' .. inc ind
    else if line is '}' .. dec ind
    else 
      set newcontext + (repeat'd '  ' ind) + line + '\n'
      
  return newcontext



// GetParser
//
// Returns a function that will parse SAI code into Javascript
//
// If the grammar file (saigrammar.peg) is newer than the current parser
// (saigrammar.js), uses PEGjs to recompile the grammar and save the parser.
//

GetParser task

  try
  
    set grammarFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.peg'
    set parserFile from PATH.resolve from PATH.join DIRNAME, 'saigrammar.js'

    if (not FS.existsSync(parserFile))
    ... or (FS.statSync(grammarFile).mtime > FS.statSync(parserFile).mtime) 

      set 
        PEG require('pegjs')
        grammar FS.readFileSync(grammarFile).toString()
        
        mainParser from PEG.generate grammar, fields
          allowedStartRules list startFile, startExpression
          output 'source'
          optimize 'size'
          trace 0
          cache true
          
      FS.writeFileSync parserFile, mainParser

    else
      set mainParser FS.readFileSync(parserFile).toString()

  catch
      
    set msg '''
      SAI: Could not compile saigrammar.peg.
      Is pegjs available? Is there a syntax error in the grammar?

      ${error}
    
    if grammar
      set msg from my WrapExtract grammar, error.location.start.offset
        
    throw new ~Error msg
    
  set mainParser from ~eval mainParser
  
  return task given rawsource, bound, fn
  
    set
      rawsource + '\n\n'
      source from my Dedenter rawsource
  
    try
      set js from mainParser.parse source, fields
        startrule fn ?? 'startFile' :: 'startExpression'
        bound bound
        globals my config.verbs
        persist my persist
        filename fn
    
    catch
      set location to undefined
      if error.location
        set location to trial.start.offset
      if  match'd error.message /at:([0-9]+)/ 
        set location to number trial.1 

      if location
        throw new ~Error '''
          SAI: Syntax error <HERE> in ${~JSON.stringify(fn)}
          
          ${my Contextualize(source, location)}
          
          ${error.message}
          
      else
        throw new ~Error '''
          SAI: Error creating prototype:
          
          ${error.toString()}
          
    if my config.options.beautify
      set js from my Beautify js, fields
        indent_size 2
        preserve_newlines false
        brace_style 'collapse'
    
    return js

  
// Parse
//
// Build and bind parser
//
// (see my Clean)


// GetSourceFromPaths -> config.Loader
//
// The basic loader which fetches SAI source by name from the provided list of 
// directories.
//

GetSourceFromPaths task given name

  ply my config's paths as path
    ply array '.sai', ''; as extension
      set filename from PATH.join path, name+extension
      try
        return:
          success true
          source toString'd FS.readFileSync(filename)
          context:
            name name
            loader 'SAI.GetSourceFromPaths'
            path filename
            mtime FS.statSync(filename).mtime
            fetched new ~Date
      catch
        nop
          
  return:
    success false
    context '''
      SAI.GetSourceFromPaths: cannot load ${name}
      Check paths: ${my config.paths.join(';')}

      
// Compile
//
// Create a function that compiles parsed SAI source, binding the variables
// needed to integrate necessary scope and the SAI runtime library.
//

Compile task given source
  return new ~Function 'prototype','options','require','$AI','__dirname', source


// ProtoGen
//
// Create a fully scoped Javascript prototype for a single object (ignoring inheritance)
//

GetProtogen task given name
  
  set my protogens[name] default from task
    set s1 new ~Date
    set load from my config's Loader name
    unless load.success
      throw new ~Error `SAI.GetProtogen: Could not load object ${name}, reason given: ${load.context}'
    set source from my Parse load's source, undefined, load's context
    set source 'var __context=${~JSON.stringify(load.context)};\n${source}'
    set protogen from my Compile source
    //debug source
    unless protogen
      throw new ~Error 'SAI.GetProtogen: Error in generated code ${name}'
    set s2 new ~Date
    if my config's options's speedometer
      debug 'SAI: Compiled ${name} in ${s2-s1}ms.'
    set my source[name] source
    return protogen

  return my protogens[name]
  
  
// Expression
//
// Compile a single SAI expression, out of context except for the runtime library.
//

Expression task given source
  set js 'return ${my Parse(source, undefined, undefined)}'
  return my Compile(js)(@@, blank, ~require, SAILIB, DIRNAME)


// GetAncestors
//
// Build a list of objects that the given object depends on
//

GetAncestors task given name
  set
    heritage array name
    ancestors blank
    nodupes blank
    
  while shift'd heritage as leaf
    unless nodupes\leaf
      set nodupes\leaf to true
      set obj to new my proto name
      set protogen from my GetProtogen leaf
      set opts: name leaf
      protogen obj, opts, ~require, SAILIB, DIRNAME
      obj.Constructor
      unless obj.isa
        throw new ~Error 'SAI GetPrototype: object loaded as ${leaf} does not have an isa type identifier.'
      with obj.__inherits
        set ancestors\leaf it
        ply it
          heritage.push it

  return ancestors
  

// GetPrototype
// 
// Given a name, locate all ancestors, create all prototypes,
// initialize primary prototype object, describe properties,
// save the result in a cache (SAI.prototypes) and return it.
//

GetPrototype task given name, bindings
  set my prototypes[name] default from task
    set ancestors from my GetAncestors name
    set proto to new my proto name
    set adopt to task given name
      ply ancestors[name]
        adopt it
      set protogen from my GetProtogen name
      protogen proto, fields name name;, require, SAILIB, DIRNAME
    
    adopt name
    
    ~Object.defineProperty proto, 'isa', :enumerable false, value proto.isa;
    if my isas[proto.isa]
      throw new ~Error 'SAI: object defined by ${name} has a duplicate.isa type ${proto.isa} identical to ${my isas[proto.isa]}'
    set my isas[proto.isa] name

    SAILIB.finalizePrototype proto
    return proto
    
  return my prototypes[name]


// GetSource
//
// Get full native JS source code for an object, by name.
//

GetSource task as name
  set ancestors from my GetAncestors name
  set islib to 0 <= name.indexOf('sailib')

  if islib
    debug 'Building SAILIB specifically to refer to iteself; not requiring sai-library.'

  set source '''
    #!/usr/bin/env node
    
    \/\/ Javascript source for ${name} transipled by SAI
    \/\/
    
    "use strict";
    
    var prototype=new function()${'{'}
    this.Constructor=function()${'{}'};
    this.__tobelocked=[];
    this.__tobefrozen=[];
    this.__contracts=[];
    this.__unverified=true;
    this.isof=${'{}'};
    return this;
    ${'}'}();
    var $AI=${islib ?? 'prototype' :: 'require("sai-library")'};
    // Generated code follows
    
  set adopt task given name
    ply ancestors[name]
      adopt it
    set source + my source[name] + '\n'
  
  adopt name

  set source + '''
    // End of generated code
    
    $AI.finalizePrototype(prototype);
    if (prototype.isof[prototype.isa].type === "singleton") { prototype.Constructor(); prototype.Instantiate(); ${'}'}
    var result=prototype.isof[prototype.isa].type === "main" ? prototype.constructor() : prototype;
    exports=result; try { module.exports=result; ${'}'} catch(e) ${'{}'};
    return result;
    
  return source


// Require
//
// Return a prototype object by name
//

Require task given name
  exists from my GetPrototype name
    exists .constructor
      return it
  throw new ~Error 'SAI.Require: do not know how to create object ${name}'
  


// Create
//
// Create an object by name (an alternative to using new on what Require gives you)
//

Create task given name, parameters
  exists from my GetPrototype name
    set obj from ~Object.create it
    if obj.Constructor .. obj.Constructor
    if obj.Instantiate .. obj.Instantiate.apply obj, parameters
    return obj
  throw new ~Error 'SAI.Create: do not know how to create object ${name}'


// Configure
//
// Update configuration settings individually or as a group
//

Configure task given config
  exists config.paths
    set my config.paths it
  exists config.verbs
    set my config.verbs update it
  exists config.options
    set my config.options update it
  exists config.Loader
    set my config.Loader it
  
  if my config.options.beautify
    set my Beautify require('js-beautify').js_beautify
