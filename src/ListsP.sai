
object ListsP

inherit: Construct

given:
  SPLIT '^&*SP.L.I.' + ~Math.random() + 'T.H.E.RE*&^'

// MANIFEST

manifest get 
  return:
  
    'pipers':

      'set':
        clauses:
         'set': #expr, #outblock, #use
        handler bind ThruPiper
        tools empty

      'thru':
        clauses:
         'thru': #expr, #outblock, #use
        handler bind ThruPiper
        tools empty


      'audit':
        clauses:
          'audit': #expr, #outblock, #use
        handler bind AuditPiper
        tools empty
        
      'observe':
        clauses:
          'observe': #expr, #outblock, #use
        handler bind AuditPiper
        tools empty


      'into':
        clauses:
          'into': #valexpr, #valoutblock, #valuse
        handler bind IntoPiper
        tools empty


      'total':
        clauses:
          'total': #expr, #use, #none
        handler bind TotalPiper
        tools empty


      'keys':
        clauses:
          'keys': #none
        handler bind KVPiper
        tools empty
    
      'values':
        clauses:
          'values': #none
        handler bind KVPiper
        tools empty


      'iterate':
        clauses:
          'iterate': #none
        handler bind ArraysPiper
        tools empty

      'concat':
        clauses:
          'concat': #expr
        handler bind ArraysPiper
        tools empty

      'collect':
        clauses:
          'collect': #none
        handler bind ArraysPiper
        tools empty

      'enlist':
        clauses:
          'enlist': #none
        handler bind ArraysPiper
        tools empty

      'entrait':
        clauses:
          'entrait': #none
        handler bind ArraysPiper
        tools empty

      'enkey':
        clauses:
          'enkey': #none, #expr
        handler bind ArraysPiper
        tools empty

    
      'replicate':
        clauses:
          'replicate': #expr
        handler bind ReplicatePiper
        
        tools array '''
          var $piper$replicate=function(a,c){
            var r=new Array(c);
            while (c>0) r[--c]=a;
            return r;
          }



docs get
  return:
    pipers:

      'observe':
        subtitle 'inspect a value without changing it'
        summary '''
          Evaluates the right expression using the left expression value as the **it** pronoun; 
          however, **observe** always returns the original left hand expression, no matter the result 
          of the right expression.
        detail '''
          For example:
        
              set b to 'Fred'
              set c to b observe debug '$\{it.length} letters.'
              debug c

              > 4 letters.
              > Fred

          See the example for __audit__ for a more interesting reason why __observe__ is nice.

          A warning: while you can **observe** an iterable expression, all you will see is a function.
          Take care not to invoke it, lest you drain it inadvertently.
          Heisenberg's uncertainty principle is very much at play with iterables: 
          you can either have it or know what's in it.

          N.B. **observe** very useful in **chain** expressions.

      'set':
        subtitle 'replacement operator'
        summary '''
          A chainable comprehension operator that allows direct reference and replacement of the incoming dataset within an expression or code block, using the  **it**  pronoun. 
        detail '''
          **Set** can be used with an expression:

              debug 4 | set 5*it+2 | set it/7 

              > 3.142857142857143

          **Set** can use an indented code block:

              debug friends by .age | set
                set .length to 3

              > [ { name: 'Doug', age: 18, province: 'ON' },
              >    { name: 'John', age: 19, cat: true, dog: true, province: 'ON' },
              >    { name: 'Marshal', age: 21, dog: true, province: 'ON' } ]

          _If you don’t specifically **return** a value or object from within an **set** code block, the original value will be used (as in the example above). In other words, there is an implicit `return it` at the end of every **set** block._

          **Set** supports the **using** clause, in which case the function specified receives the original value as its first parameter, and the return value is passed forward. The two debug statements below are equivalent

              set ExtractFirst to task
                return $[0]

              debug friends #cat | set Extract(it)    
              debug friends #cat | set using Extract  

              > { name: 'Sara', age: 23, cat: true, province: 'ON' }
              > { name: 'Sara', age: 23, cat: true, province: 'ON' }

          You must specifically return a value in the function called by **set using**.

          
      
      'audit':
        subtitle 'observe the elements of a collection'
        summary '''
          Audit is used to pass all values in a collection into an expression, code block or method. 
          Audit doesn’t alter the collection, it just observes all values and keys/indices going by.
        detail '''      
          For example:
          
              set b to chain fruit 
                |observe debug('Pre-sort')
                |audit debug('Fruit #$\{key} is $\{it}') 
                |by desc
                |observe debug('Post-sort')
                |audit debug('Fruit #$\{key} is $\{it}') 
              debug b
            
              > Pre-sort
              > Fruit #0 is Apple
              > Fruit #1 is Banana
              > Fruit #2 is Citron
              > Post-sort
              > Fruit #0 is Citron
              > Fruit #1 is Banana
              > Fruit #2 is Apple
              > [ 'Citron', 'Banana', 'Apple’ ] 

          This example shows how one could add instrumentation to a process in a light-weight fashion.

          Neither **observe** nor **audit** alter the chained data. _A side effect of this is that
          **observe** can’t be used with non-reproducible iterators as it’s impossible to statically observe 
          an iterator without draining it._
        
        



//// INTO PIPER 

IntoPiper task expects $work, $tools

  set 
    pattern '(${SPLIT})'
    tools empty
    outs from my OutVarHelper $work.args.out
    startvalue $work.args.val 
    
  switch $work.type
  case 'into.valexpr', 'total.expr'
    set 
      vars:
        'this' false
        'key' false
        'sum' false
        'block' $work.args.expr

      fn '''
        function(^{sum},^{this},^{key}) { 
          return ^{block};
        }
        
      fn from $tools.replacer fn, vars
      pattern '$AI.reduce_op_fast(${SPLIT},${fn},${startvalue})'

  case 'into.valoutblock', 'total.outblock'
    set 
      vars:
        'this' outs.0
        'key' outs.1
        'sum' outs.2
        'block' $work.args.block

      fn '''
        function(^{sum},^{this},^{key}) { 
          ^{block};
          return ^{sum};
        }
        
      fn from $tools.replacer fn, vars
      pattern '$AI.reduce_op_fast(${SPLIT},${fn},${startvalue})'

  case 'into.valuse', 'total.use'
    set pattern '$AI.reduce_op_fast(${SPLIT},${$work.args.use},${startvalue})'

  else
    return: error "Unhandled piper type ${trial} in IntoPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools



//// TOTAL PIPER

TotalPiper task expects $work, $tools

  set 
    pattern '(${SPLIT})'
    tools empty
    
  switch $work.type
  case 'total.expr'
    set 
      vars:
        'this' false
        'key' false
        'sum' false
        'block' $work.args.expr

      fn '''
        function(^{sum},^{this},^{key}) {
          var $t=^{block};
          return (undefined===^{sum}) ? $t : (^{sum}+$t);
        }
        
      fn from $tools.replacer fn, vars
      pattern '$AI.reduce_op_fast(${SPLIT},${fn},undefined)'

  case 'total.use'
    set pattern '$AI.reduce_op_fast(${SPLIT},${$work.args.use},undefined)'

  case 'total.none'
    set pattern '''
      $AI.reduce_op_fast(${SPLIT},function(s,i){
        return (undefined===s) ? i : s+i;
      },undefined)

  else
    return: error "Unhandled piper type ${trial} in IntoPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


//// AUDIT PIPER (AND OBSERVE)

AuditPiper task expects $work, $tools

  set
    pattern '(${SPLIT})'
    tools empty
    op $work.clause is 'audit' ?? 'audit_op' :: 'observe_op'
  
  switch $work.type

  case 'audit.expr', 'observe.expr'
    set 
      vars:
        'this' false
        'key' false
        'block' $work.args.expr
      fn '''
        function(^{this},^{key}){ 
          ^{block}; 
        }
      fn from $tools.replacer fn, vars
      pattern '$AI.${op}(${SPLIT},${fn})'

  case 'audit.outblock', 'observe.outblock'
    set
      outs from my OutVarHelper $work.args.out      
      vars:
        'this' outs.0
        'key' outs.1
        'block' $work.args.block
      fn '''
        function(^{this},^{key}){ 
          ^{block}; 
        }
      fn from $tools.replacer fn, vars  
      pattern '$AI.${op}(${SPLIT},${fn})'

  case 'audit.use', 'observe.use'
    set pattern '$AI.${op}(${SPLIT},${$work.args.use})'

  else
    return: error "Unhandled piper type ${trial} in ThruPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


//// THRU PIPER (AND SET)

ThruPiper task expects $work, $tools

  set
    pattern '(${SPLIT})'
    tools empty
    op $work.clause is 'thru' ?? 'map_op' :: 'alter_op'
  
  switch $work.type

  case 'thru.expr', 'set.expr'
    set 
      vars:
        'this' false
        'key' false
        'block' $work.args.expr
      fn '''
        function(^{this},^{key}){ 
          return ^{block}; 
        }
      fn from $tools.replacer fn, vars
      pattern '$AI.${op}(${SPLIT},${fn})'

  case 'thru.outblock', 'set.outblock'
    set
      outs from my OutVarHelper $work.args.out      
      vars:
        'this' outs.0
        'key' outs.1
        'block' $work.args.block
      fn '''
        function(^{this},^{key}){ 
          ^{block}; 
          return ^{this}; 
        }
      fn from $tools.replacer fn, vars  
      pattern '$AI.${op}(${SPLIT},${fn})'

  case 'thru.use', 'set.use'
    set pattern '$AI.${op}(${SPLIT},${$work.args.use})'

  else
    return: error "Unhandled piper type ${trial} in ThruPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


//////////////////////// ARRAYS PIPER

ArraysPiper task expects $work, $tools

  set pattern '(${SPLIT})'
  set tools empty
  
  switch $work.type

  case 'iterate.none'
    set pattern '$AI.iterate_op(${SPLIT})'

  case 'concat.expr'
    set pattern '$AI.concat_op(${SPLIT},${$work.args.expr})'

  case 'collect.none'
    set pattern '$AI.collect_op(${SPLIT})'

  case 'enlist.none'
    set pattern '$AI.enlist_op(${SPLIT})'

  case 'entrait.none'
    set pattern '$AI.entrait_op(${SPLIT})'

  case 'enkey.none'
    set pattern '$AI.reduce_op(${SPLIT},function(s,a){s[a]=true;return s;},{})'

  case 'enkey.expr'
    set 
      vars:
        'this' 'v'
        'key' 'k'
        'block' $work.args.expr
      fn '''
        ^{block}
      fn from $tools.replacer fn, vars
      pattern '$AI.reduce_op(${SPLIT},function(s,v,k){s[v]=${fn};return s;},{})'


  else
    return: error "Unhandled piper type ${trial} in KVPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


//// KV PIPER

KVPiper task expects $work, $tools

  set pattern '(${SPLIT})'
  set tools empty
  
  switch $work.type

  case 'keys.none'
    set pattern '$AI.keys_op(${SPLIT})'

  case 'values.none'
    set pattern '$AI.values_op(${SPLIT})'

  else
    return: error "Unhandled piper type ${trial} in KVPiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


//// REPLICATE PIPER

ReplicatePiper task expects $work, $tools

  set pattern '(${SPLIT})'
  set tools empty
  
  switch $work.type
  
  case 'replicate.expr'

    set pattern '$piper$replicate((${SPLIT}),(${$work.args.expr}))'

  else
    return: error "Unhandled piper type ${trial} in ReplicatePiper"
      
  return: leftright pattern.split('${SPLIT}'), tools tools


